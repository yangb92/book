{"./":{"url":"./","title":"介绍","keywords":"","body":" 代码笔记 希望你该坚持主见的时候，坚持主见，该沉默的时候，学会沉默，宁愿卑微如灰尘,不可扭曲成蛆虫。 杨斌 local: Hangzhou,China email: 523084685@qq.com blog: github: https://github.com/yangb92 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-07 16:34:47 "},"program/":{"url":"program/","title":"软件编程","keywords":"","body":"程序设计 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 10:03:25 "},"program/SpringBoot/":{"url":"program/SpringBoot/","title":"SpringBoot","keywords":"","body":"Spring Boot 项目结构 定位程序主类 默认推荐将启动类放在根目录中，高于其他的类。 @SpringBootApplication 注解放在主类上面，它还隐式的定义基础的所要扫描的包。 如果你不想用@SpringBootApplication， 可以使用@EnableAutoConfiguration 和 @ComponentScan 注解来定义这些。 典型的布局结构 com +- example +- myapplication +- Application.java | +- customer | +- Customer.java | +- CustomerController.java | +- CustomerService.java | +- CustomerRepository.java | +- order +- Order.java +- OrderController.java +- OrderService.java +- OrderRepository.java 配置类 Spring Boot 支持 java类配置和xml同事配置， 在配置类使用一个@Configuration， 通常定义 main 方法的主类很适合使用@Configuration。 导入其他配置类 你不需要将所有的@Configuration放入一个类中， @Import 注解能够用来加入配置类，或者，您可以使用@ComponentScan自动获取所有包括 @Configuration 类的Spring组件 导入XML配置 如果你必须要使用xml配置，我们建议您仍然从@Configuration类开始，你可以使用一个@ImportResource 注解加载xml配置文件。 自动配置 禁用特定的自动配置类 您可以使用@EnableAutoConfiguration的exclude属性禁用它们，如下面的示例所示: import org.springframework.boot.autoconfigure.*; import org.springframework.boot.autoconfigure.jdbc.*; import org.springframework.context.annotation.*; @Configuration @EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class}) public class MyConfiguration { } Spring Bean 和 依赖注入 您可以自由地使用任何标准Spring框架技术来定义bean及其注入的依赖项。为了简单起见，我们经常发现使用@ComponentScan(查找bean)和使用@Autowired(执行构造函数注入)工作得很好。 如果按照上面的建议构造代码(将应用程序类定位在根包中)，可以添加@ComponentScan，而不需要任何参数。所有应用程序组件(@Component、@Service、@Repository、@Controller等)都自动注册为Spring bean。 注意使用构造注入的bean 使用final 防止被更改。 使用@SpringBootApplication注解 使用一个@SpringBootApplication注释来启用这三个特性，即: @EnableAutoConfiguration: enable Spring Boot’s auto-configuration mechanism • @ComponentScan: enable @Component scan on the package where the application is located (see the best practices) • @Configuration: allow to register extra beans in the context or import additional configuration classes @SpringBootApplication还提供别名来定制@EnableAutoConfiguration和@ComponentScan的属性 这些特性都不是强制性的，您可以选择用它支持的任何特性替换这个注释。例如，你可能不想在你的应用程序中使用组件扫描: package com.example.myapplication; import org.springframework.boot.SpringApplication; import org.springframework.context.annotation.ComponentScan import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Import; @Configuration @EnableAutoConfiguration @Import({ MyConfig.class, MyAnotherConfig.class }) public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 开发工具 添加开发依赖 org.springframework.boot spring-boot-devtools true 开发依赖将在打包时关闭，并且用java -jar 运行时认为是生产环境，会自动关闭。 若要手动关闭，请设置Dspring.devtools.restart.enabled=false 属性 自动重启 类路径上的文件发生更改，将会自动重启，静态资源或模板发生更改，不会重启， 触发自动重启的唯一方法是更新类路径， Eclipse 自动更新， ide需要build 排除一些资源变动，不重启 spring.devtools.restart.exclude=static/,public/ 远程开发 需要添加插件 org.springframework.boot spring-boot-maven-plugin false 然后需要设置spring.devtools.remote.secret属性，如下面的示例所示: spring.devtools.remote.secret=mysecret 存在安全风险，不建议用在生产服务器上。 远程开发工具由两部分提供支持，接受连接的服务器端端点和在IDE中运行的客户机应用程序。当设置spring.devtools.remote.secret属性时，服务器组件将自动启用。客户端组件必须手动启动。 jar包部署至远程服务器 在服务器上运行jar包，address=5005 是调试端口 java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 demo-0.0.1-SNAPSHOT.jar IDE 上开启远程调试 只需要输入主机地址和调试端口即可热更新和调试，实现本地开发，远程运行，降低对开发电脑的资源占用。 运行远程客户端程序 远程客户端程序被设计运行在IDE，您需要运行org.springframework.boot.devtools.RemoteSpringApplication，其类路径与您连接到的远程项目相同，应用程序唯一需要的参数是它连接到的远程URL。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 10:17:40 "},"program/SpringBoot/SpringBootDruid.html":{"url":"program/SpringBoot/SpringBootDruid.html","title":"SpringBoot整合Druid","keywords":"","body":"SpringBoot 整合 Druid 引入依赖 在pom文件引入druid依赖 com.alibaba druid-spring-boot-starter 1.1.22 引入数据库连接依赖 mysql mysql-connector-java runtime 配置application.yml spring: datasource: druid: url: jdbc:mysql://ip:port/dbname?useUnicode=true&characterEncoding=utf-8&useSSL=false username: root password: 123456 initial-size: 1 min-idle: 1 max-active: 20 test-on-borrow: true # MySQL 8.x: com.mysql.cj.jdbc.Driver driver-class-name: com.mysql.jdbc.Driver Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-13 15:13:04 "},"program/SpringBoot/SpringBootTkMybaits.html":{"url":"program/SpringBoot/SpringBootTkMybaits.html","title":"SpringBoot整合tk.mybatis","keywords":"","body":"SpringBoot 整合 tk.mybatis 引入依赖 在pom.xml引入依赖,该依赖会自动引入MyBaits依赖 tk.mybatis mapper-spring-boot-starter 2.0.2 配置 application.yml 配置 MyBatis mybatis: type-aliases-package: 实体类的存放路径，如：com.funtl.hello.spring.boot.entity mapper-locations: classpath:mapper/*.xml 创建一个通用的父级接口 主要作用是让 DAO 层的接口继承该接口，以达到使用 tk.mybatis 的目的 package com.funtl.utils; import tk.mybatis.mapper.common.Mapper; import tk.mybatis.mapper.common.MySqlMapper; /** * 自己的 Mapper * 特别注意，该接口不能被扫描到，否则会出错 * Title: MyMapper * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/5/29 0:57 */ public interface MyMapper extends Mapper, MySqlMapper { } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-13 15:26:24 "},"program/SpringBoot/SpringBootPageHelper.html":{"url":"program/SpringBoot/SpringBootPageHelper.html","title":"SpringBoot整合PageHelper","keywords":"","body":"SpringBoot 整合 PageHelper 引入依赖 在pom.xml文件中引入pagehelper-spring-boot-starter com.github.pagehelper pagehelper-spring-boot-starter 1.2.5 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-13 15:29:07 "},"program/SpringBoot/generator.html":{"url":"program/SpringBoot/generator.html","title":"Mybatis Maven插件生成代码","keywords":"","body":"Mybatis Maven插件生成代码 配置插件 在pom.xml文件中增加mybatis-generator-maven-plugin插件 org.mybatis.generator mybatis-generator-maven-plugin 1.3.5 ${basedir}/src/main/resources/generator/generatorConfig.xml true true mysql mysql-connector-java ${mysql.version} tk.mybatis mapper 3.4.4 configurationFile：自动生成所需的配置文件路径 自动生成的配置 在 src/main/resources/generator/ 目录下创建 generatorConfig.xml 配置文件： 配置数据源 在 src/main/resources/generator 目录下创建 jdbc.properties 数据源配置： # MySQL 8.x: com.mysql.cj.jdbc.Driver jdbc.driverClass=com.mysql.jdbc.Driver jdbc.connectionURL=jdbc:mysql://ip:port/dbname?useUnicode=true&characterEncoding=utf-8&useSSL=false jdbc.username=root jdbc.password=123456 插件自动生成命令 mvn mybatis-generator:generate Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-15 09:08:07 "},"SpringBoot/thymeleaf.html":{"url":"SpringBoot/thymeleaf.html","title":"thymeleaf 模板引擎","keywords":"","body":"thymeleaf pom org.springframework.boot spring-boot-starter-thymeleaf 显示Controller传递的数据 显示配置文件中的数据 Oranges 0.99 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-08 10:29:15 "},"program/SpringBoot/SpringDataJPA.html":{"url":"program/SpringBoot/SpringDataJPA.html","title":"SpringDataJPA","keywords":"","body":"Spring Data JPA Repostory @Repository public interface AppUserRepostory extends JpaRepository { } Example 使用 public AppUser loadUserByUsername(String username) throws UsernameNotFoundException { AppUser user = new AppUser(); user.setUsername(username); ExampleMatcher matcher = ExampleMatcher.matching().withIgnoreNullValues() .withMatcher(\"username\", match -> match.contains() ); Example example =Example.of(user,matcher); Optional optional = userRepostory.findOne(example); AppUser appUser = userRepostory.queryByUsername(username); if (!optional.isPresent()) { throw new UsernameNotFoundException(\"用户名不存在\"); } return optional.get(); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 10:23:08 "},"program/SpringBoot/SpringDataJdbc.html":{"url":"program/SpringBoot/SpringDataJdbc.html","title":"SpringDataJDBC","keywords":"","body":"Spring Data Jdbc 添加依赖 org.springframework.boot spring-boot-starter-data-jdbc 创建实体 @Data @Table(\"t_user\") public class UserDto { @Id private String id; private String username; private String password; private String fullname; private String mobile; } 创建Dao @Repository public interface UserDao extends CrudRepository { @Query(\"SELECT * FROM `t_user` where username=:username\") UserDto findByUsername(@Param(\"username\") String username); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 10:23:08 "},"program/SpringBoot/LinuxService.html":{"url":"program/SpringBoot/LinuxService.html","title":"部署为linux服务","keywords":"","body":"Linux 服务化部署 官方文档: https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/html/deployment.html#deployment-install 配置Maven插件 org.springframework.boot spring-boot-maven-plugin true 安装为init.d服务 假设你的SpringBoot程序部署在/var/myapp路径，要将SpringBoot程序作为init.d服务，需要创建一个软链接，如下: $ sudo ln -s /var/myapp/myapp.jar /etc/init.d/myapp 安装后，就可以按系统服务的方式启动和停止。例如，在基于debian的系统上，可以使用以下命令启动它: $ service myapp start 日志在/var/log/\\.log中可以查看. FQ spring boot 在Linux下服务启动报错Unable to find Java 将java 连接到/sbin 文件夹下 ln -s /usr/local/jdk/bin/java /sbin/java Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 17:47:57 "},"program/SpringCloud/":{"url":"program/SpringCloud/","title":"Spring Cloud","keywords":"","body":"Spring Cloud Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-29 09:25:51 "},"program/SpringCloud/stopdesc.html":{"url":"program/SpringCloud/stopdesc.html","title":"SpringCloud组件状态","keywords":"","body":"Spring Cloud 组件停更说明 参考资料: 见官网 说明: [ ] 停更 [x] 建议使用 服务注册 [ ] Eureka [x] Zookeeper [x] Consul [x] Nacos (Alibaba) 服务调用 [x] Ribbon [x] LoadBalancer 服务调用2 [ ] Feign [x] OpenFeign 服务降级 [ ] Hystrix [x] resilience4j (国外推荐) [x] Sentine (国内推荐- 来自Alibaba组件) 服务网关 [ ] Zuul [ ] Zuul2 (未开发完成) [x] Gateway 服务配置 [ ] Config [x] Apollo (上海携程) [x] Nacos (Alibaba) 服务总线 [ ] Bus [x] Nacos Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-23 11:15:23 "},"program/SpringCloud/version..html":{"url":"program/SpringCloud/version..html","title":"版本选型","keywords":"","body":"版本选型 Spring Boot 版本选型: 19年以后不再使用 1.5 版本, 一定要使用2.x版本 Spring Cloud 版本选型: H版 采用伦敦地铁站来命名. Hoxton.SR3 Spring Boot 和 Spring Cloud 版本匹配对应 Release Train Boot Version Hoxton 2.2.x Greenwich 2.1.x Finchley 2.0.x Edgware 1.5.x Dalston 1.5.x 查看版本匹配关系 https://start.spring.io/actuator/info \"Hoxton.SR3\":\"Spring Boot >=2.2.0.M4 and 或者在Spring官网Spring Cloud Reference Doc点进去可以看到,推荐的匹配版本 Release Train Version: Hoxton.SR3 Supported Boot Version: 2.2.5.RELEASE Spring Cloud 和 Spring Cloud Alibaba版本对应关系 https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E Spring Cloud Version Spring Cloud Alibaba Version Spring Boot Version Spring Cloud Hoxton.SR3 2.2.1.RELEASE 2.2.5.RELEASE Spring Cloud Hoxton.RELEASE 2.2.0.RELEASE 2.2.X.RELEASE Spring Cloud Greenwich 2.1.2.RELEASE 2.1.X.RELEASE Spring Cloud Finchley 2.0.2.RELEASE 2.0.X.RELEASE Spring Cloud Edgware 1.5.1.RELEASE 1.5.X.RELEASE Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-22 14:14:05 "},"program/SpringCloud/project.html":{"url":"program/SpringCloud/project.html","title":"微服务框架","keywords":"","body":"Spring Cloud 工程搭建 源码: https://github.com/yangb92/spring-cloud-yoyo 环境准备 约定 > 配置 > 编码 工程结构 project --module Maven Maven 选择3.5.2以上 开启跳过maven单元测试 skip test 字符编码 settings - Editor - File Encodings: Global Encoding UTF-8 Project Encoding UTF-8 Default encoding for properties files: UTF-8 注解激活生效 setting-build-compiler-Annotation Processors 打钩 Enable annotation processing Java编译版本 setting-build-compiler-Java Compiler 选择java版本8 File Type 过滤 settings - Editor - File Types 添加不需要显示的文件 父工程 (聚合模块) 项目创建 创建标准maven项目, 项目下面只保留pom文件. pom文件 4.0.0 org.springframework.boot spring-boot-starter-parent 2.2.5.RELEASE com.yangb microservice 0.0.1-SNAPSHOT pom microservice 微服务框架 http://book.yangb.xyz 2.2.5.RELEASE Hoxton.SR3 2.2.1.RELEASE UTF-8 1.8 1.8 4.12 1.2.17 1.16.18 5.1.47 1.1.16 1.3.0 org.springframework.boot spring-boot-dependencies ${spring-boot.version} pom import org.springframework.cloud spring-cloud-dependencies ${spring-cloud.version} pom import com.alibaba.cloud spring-cloud-alibaba-dependencies ${spring-cloud-alibaba.version} mysql mysql-connector-java ${mysql.version} com.alibaba druid ${druid.version} org.mybatis.spring.boot mybatis-spring-boot-starter ${mybatis.spring.boot.version} junit junit ${junit.version} log4j log4j ${log4j.version} org.projectlombok lombok ${lombok.version} true org.springframework.boot spring-boot-maven-plugin true true 业务模块 微服务模块步骤: 建model 改POM 写YML 主启动 业务类 例如: 支付模块 pom.xml microservice com.yangb 0.0.1-SNAPSHOT 4.0.0 business-payment jar 业务模块 - 支付 org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-actuator org.mybatis.spring.boot mybatis-spring-boot-starter com.alibaba druid-spring-boot-starter 1.1.10 mysql mysql-connector-java org.springframework.boot spring-boot-starter-jdbc org.springframework.boot spring-boot-devtools runtime true org.projectlombok lombok true org.springframework.boot spring-boot-starter-test test application.yml server: port: 8001 spring: application: name: payment-service datasource: druid: url: jdbc:mysql://localhost:3306/quick_db?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=UTC username: root password: root initial-size: 1 min-idle: 1 max-active: 20 test-on-borrow: true # driver-class-name: com.mysql.jdbc.Driver driver-class-name: com.mysql.cj.jdbc.Driver # MySql8.x mybatis: mapper-locations: classpath:mapper/*.xml type-aliases-package: com.yangb.business.payment.entity 主启动 /** * Created by YangBin on 2020/4/22 * Copyright (c) 2020 杨斌. All rights reserved. */ @SpringBootApplication public class PaymentServer { public static void main(String[] args) { SpringApplication.run(PaymentServer.class, args); } } 整合Spring Boot 单体应用快速开发框架 https://github.com/yangb92/SpringBootQuickDevlop 授权模块我们最后使用OAuth2.0统一认证, 先不进行整合. 可参考本文档SpringBoot章节 模块名称 描述 tk.mybatis 使用tk.mybatis框架,简化数据库操作。 PageHelper 分页插件 generator 自动生成Entity,Mapper和Dao 注册中心 见文档 服务发现 负载均衡 见文档 负载均衡 服务调用 见文档 服务调用 服务降级 参考文档Hystrix 服务网关 参考文档服务网关 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-24 17:04:18 "},"program/SpringCloud/Discover.html":{"url":"program/SpringCloud/Discover.html","title":"服务发现","keywords":"","body":"服务注册与发现 Eureka 服务端 建model 改POM 写YML 主启动 业务类 POM microservice com.yangb 0.0.1-SNAPSHOT 4.0.0 serve-discover jar org.springframework.cloud spring-cloud-starter-netflix-eureka-server org.springframework.boot spring-boot-maven-plugin true true application.yml server: port: 35001 eureka: instance: hostname: localhost client: register-with-eureka: false # 不向注册中心注册自己 fetch-registry: false # 注册中心不需要去检索服务 service-url: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ # 服务地址 主启动类 /** * Created by yangb on 2020/4/22 * Copyright (c) 2020 杨斌 All rights reserved. */ @SpringBootApplication @EnableEurekaServer public class DiscoverServer { public static void main(String[] args) { SpringApplication.run(DiscoverServer.class, args); } } 访问http://localhost:35001/ 客户端 POM org.springframework.cloud spring-cloud-starter-netflix-eureka-client application.yml # 服务注册 eureka: client: service-url: defaultZone: http://localhost:35001/eureka 在最新版本的Eurika,不需要在主启动类添加@EnableEurekaClient注解来开启了, 引入依赖自动注册服务 注册中心集群 互相注册,相互守望 修改系统hosts文件 127.0.0.1 eureka35001.com 127.0.0.1 eureka35002.com 服务端 application.yml 35001 服务 server: port: 35001 eureka: instance: hostname: eureka35001.com client: register-with-eureka: false # 不向注册中心注册自己 fetch-registry: false # 注册中心不需要去检索服务 service-url: defaultZone: http://eureka35002:35002/eureka/ # 服务地址 35002 服务 server: port: 35002 eureka: instance: hostname: eureka35002.com client: register-with-eureka: false # 不向注册中心注册自己 fetch-registry: false # 注册中心不需要去检索服务 service-url: defaultZone: http://eureka35001:35001/eureka/ # 服务地址 客户端 application.yml # 服务注册 eureka: client: service-url: defaultZone: http://eureka35001:35001/eureka,http://eureka35002:35002/eureka # 这里不一定要配置,因为默认提供的已经够用了 instance: instance-id: ${spring.application.name}:${server.port} # 实例信息 prefer-ip-address: true # 带实例IP地址 这里如果不改hosts文件, 所有地址使用默认的localhost也没有问题 Eureka自我保护机制 EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE. 如果我们在Eureka Server看到了这段提示, 说明Eureka进入了保护模式 原因 某时刻一个微服务不可用了,Eureka不会立刻清理,依旧会对该微服务的信息保存. 什么是自我保护 默认情况下, 如果Eureka在一定时间内没有接收到某个微服务实例的心跳, EurekaServer将会注销该实例(默认90s) 属于CAP里面的AP分支设计思想: 好死不如赖活着的设计哲学 关闭自我保护 服务端 eureka: server: enable-self-preservation: false # 关闭自我保护 eviction-interval-timer-in-ms: 3000 # 如果超过3秒收不到心跳,剔除此服务 客户端 eureka: instance: lease-renewal-interval-in-seconds: 30 # Eureka 客户端向服务端发送心跳的时间间隔 lease-expiration-duration-in-seconds: 90 # Eureka服务端在收到最后一次心跳后等待的时间上限, 超时将剔除服务 DiscoverClient @Autowired private DiscoveryClient discoveryClient; String clients = discoveryClient.getServices().stream() .map(item -> discoveryClient.getInstances(item).stream() .map(instance -> instance.getHost() + instance.getPort() + instance.getUri() + instance.getScheme() ).collect(Collectors.joining(\"|\"))) .collect(Collectors.joining(\"/\")); Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-23 17:58:18 "},"program/SpringCloud/ServiceCall.html":{"url":"program/SpringCloud/ServiceCall.html","title":"服务调用","keywords":"","body":"服务调用 OpenFeign 申明式的Web服务客户端, 只需要创建一个接口并在接口上添加注解即可. 本身已经集成了Ribbon支持负载均衡. pom.xml org.springframework.cloud spring-cloud-starter-openfeign 启动类配置 @SpringBootApplication @EnableFeignClients public class OrderServer { ... 远程接口 /** * Created by yangb on 2020/4/23 * Copyright (c) 2020 杨斌 All rights reserved. */ @FeignClient(\"PAYMENT-SERVICE\") public interface PaymentFeignService { @GetMapping(\"/payment/{id}\") ResultVo getPayment(@PathVariable(\"id\") Long id); } 超时控制 Feign 默认只等待1秒钟, 超时报错. 因为使用了ribbon, 所以配置ribbon的连接建立时间 配置超时时间: # feign 连接超时配置 ribbon: ReadTimeout: 5000 # 连接建立后响应时间 ConnectTimeout: 5000 # 建立连接所用的时间 日志功能 日志级别 NONE: 默认,不显示日志 BASIC: 记录请求方法,url,响应状态码和执行时间 HEADERS: 增加请求和响应头 FULL: 增加请求和响应的正文 配置类 /** * Created by yangb on 2020/4/23 * Copyright (c) 2020 杨斌 All rights reserved. */ @Configuration public class FeignConfig { @Bean Logger.Level feignLoggerLevel(){ return Logger.Level.FULL; } } application.yml logging: level: com.yangb.business.order.service.PaymentFeignService: debug # feign日志以什么级别监控哪个接口 断路器 启用feign断路器,会导致令牌中继失败 SecurityContextHolder.getContext().getAuthentication() 为null 启用断路器 # 启用feign熔断器 feign: hystrix: enabled: true 创建FeignClient接口的实现类,用于处理异常情况 @Service public class PaymentFeignServiceFallbackImpl implements PaymentFeignService { @Override public ResultVo error() { return ResultVo.makeFailed(\"服务响应失败\"); } } 配置在fallback属性 @FeignClient(value = \"PAYMENT-SERVICE\",fallback = PaymentFeignServiceFallbackImpl.class) public interface PaymentFeignService { @GetMapping(\"/payment/timeout\") ResultVo error(); } Ribbon + HttpTemplate Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-26 15:54:48 "},"program/SpringCloud/gateway.html":{"url":"program/SpringCloud/gateway.html","title":"服务网关","keywords":"","body":"服务网关 Spring Cloud Gateway Gateway 是 Zull1.x 的替代. 概念 (1) 功能特性 基于异步非阻塞模型上进行开发, 在 Spring Framework 5, Project Reactor 和 Spring Boot 2.0 进行构建. 特性: 动态路由 对路由指定 Predicate (断言) 和 Filter (过滤器). 集成 Hystrix 断路器 集成 Spring Cloud 服务发现 限流 路径重写 (2) 与Zuul的区别 Zuul1.x 基于 Servlet2.5 之上的一个阻塞式处理模型, 在高并发不具优势. Gateway 用的是 Spring WebFlux 是 Spring 5.0 引入新的响应式框架. (3) 核心概念 Route (路由) Predicate (断言) Filter (过滤) (4) 工作流程 Client -> Spring Cloud Gateway -> Gateway Handler Mapping -> Gateway Web Handler -> Filter -> Proxied Service 用法 (1) pom.xml 配置 org.springframework.cloud spring-cloud-starter-gateway org.springframework.cloud spring-cloud-starter-netflix-eureka-client (2) application.yml 配置 server: port: 35002 spring: application: name: gateway-serve cloud: gateway: routes: - id: payment-service # 路由的id, 要求唯一 uri: http://localhost:8001 # 匹配后提供服务的路由地址 predicates: - Path=/payment/** # 断言,路径匹配进行路由 - id: order-service uri: http://localhost:8002 predicates: - Path=/order/** eureka: instance: hostname: gateway-serve client: service-url: defaultZone: http://localhost:35001/eureka (3) 编码方式配置路由 参考官方文档. Tip: 你会发现还是通过yml配置路由简单一点. (4) 动态路由配置 application.yml ... spring: application: name: gateway-serve cloud: gateway: discovery: locator: enabled: true # 开启从注册中心动态创建路由的功能 routes: - id: payment-service uri: lb://PAYMENT-SERVICE # 注册中心服务地址 predicates: - Path=/payment/** ... lb://... 说明: lb 指 loadbalance (5) 断言 Predicate 官方文档 断言列表: After Route Predicate 在指定日期时间之后请求 predicates: - After=2017-01-20T17:42:47.789-07:00[America/Denver] Before Route Predicate 在指定日期时间之前请求 predicates: - Before=2017-01-20T17:42:47.789-07:00[America/Denver] Between Route Predicate 在指定日期时间之间请求 predicates: - Between=2017-01-20T17:42:47.789-07:00[America/Denver], 2017-01-21T17:42:47.789-07:00[America/Denver] Cookie Route Predicate 匹配具有给定名称且其值与正则表达式匹配的 cookie predicates: - Cookie=chocolate, ch.p Header Cookie Route Predicate 名称且其值与正则表达式匹配的 head 匹配 predicates: - Header=X-Request-Id, \\d+ Host Route Predicate 主机名匹配 predicates: - Host=**.somehost.org,**.anotherhost.org Method Route Predicate 方法匹配 predicates: - Method=GET,POST Path Route Predicate 路径匹配 predicates: - Path=/red/{segment},/blue/{segment} Query Route Predicate 参数匹配, 参数名称和参数值得正则表达式 predicates: - Query=red, gree. RemoteAddr Route Predicate IP地址匹配 ip地址/子网掩码 predicates: - RemoteAddr=192.168.1.1/24 Weight Route Predicate 配置权重, 组名称和权重值,权重是按组计算的,将20%的流量转发到这个路由 predicates: - Weight=group1, 2 (6) 过滤器 Filter 官方文档 官方自带30个过滤器网关过滤器和10个全局过滤器. 自定义过滤器 @Component @Slf4j public class AuthorizationFilter implements GlobalFilter, Ordered { @Override public Mono filter(ServerWebExchange exchange, GatewayFilterChain chain) { log.info(\"*** Coming to AuthorizationFilter\"); String uname = exchange.getRequest().getQueryParams().getFirst(\"uname\"); if (uname == null) { log.info(\"*** 用户名为Null,非法用户!\"); exchange.getResponse() .setStatusCode(HttpStatus.NON_AUTHORITATIVE_INFORMATION); return exchange.getResponse().setComplete(); } return chain.filter(exchange); } @Override public int getOrder() { // 过滤器顺序.数字越小,优先级越高 return 0; } } Spring Cloud Netflix Zuul ( 已停用 ) Zuul 1.x 版本已停用, Zuul2.0 还在开发中. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-24 11:31:28 "},"program/SpringCloud/hystrix.html":{"url":"program/SpringCloud/hystrix.html","title":"服务降级/熔断/限流","keywords":"","body":"服务降级/熔断/限流 概念解释 服务雪崩 \"扇出效应\": 服务A -> 服务B, 服务C; B和C又调用其他微服务. \"雪崩效应\": 如果链路上某个服务调用的时间过长或者不可用, 对服务A的调用就会占用越来越多的系统资源.进而服务崩溃. 服务熔断/服务隔离 (Fallback) 顾名思义，它是指将系统按照一定的原则划分为若干个服务模块，各个模块之间相对独立，无强依赖。当有故障发生时，能将问题和影响隔离在某个模块内部，而不扩散风险，不波及其它模块，不影响整体的系统服务。 分布式系统中,许多依赖不可避免的会调用失败, Hystrix能保证在一个依赖出问题的情况下, 不会导致整体服务失败,避免级联故障,提高分布式系统弹性. \"断路器\" 本身是一种开关装置, 某个服务单元发生故障时,向调用方返回一个预期的.可处理的备选响应(fullback) 这样就可以保证服务调用方的线程不会被长时间占用 服务降级 (Break) 什么是服务降级？当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。 服务限流 (Flowlimit) 限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。 Hystrix 项目构建 pom.xml org.springframework.cloud spring-cloud-starter-hystrix 启动类添加@EnableCircuitBreaker 启用断路器注解 @SpringBootApplication @EnableCircuitBreaker public class PaymentServer { public static void main(String[] args) { SpringApplication.run(PaymentServer.class, args); } } 降级处理 服务异常或者超时,都将执行timeoutHandler中的方法. @Override @HystrixCommand(fallbackMethod = \"timeoutHandler\",commandProperties = { @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\", value = \"5000\")}) public String errrMethod(Integer id){ try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } return \"服务超时演示!\"; } public String timeoutHandler(Integer id){ return \"服务超时\" + id; } 全局服务降级 添加全局@DefaultProperties服务降级属性 @Service @DefaultProperties(defaultFallback = \"globalFallbackMethod\") public class PaymentServiceImpl implements PaymentService { @HystrixCommand public String errrMethod(Integer id){ int x = 1/0; try { TimeUnit.SECONDS.sleep(8); } catch (InterruptedException e) { e.printStackTrace(); } return \"服务演示!\"; } public String globalFallbackMethod(){ return \"调用异常,这是全局降级方案!\"; } } 哪些情况会导致降级 程序运行异常 超时 服务熔断处罚降级 线程池/信号量 打满也会导致服务降级 熔断机制 当扇出链路的某个微服务出错不可用或者响应时间太长时, 进而熔断该节点的微服务调用,快速返回错误信息. 当检测到该节点微服务调用响应正常后,恢复调用链路. 熔断注解@HystrixCommand 半开效果, 断路器打开时,会尝试调用远程服务,如果远程服务可用, 断路器会自动关闭. HystrixCommandProperties.class 包含了熔断的默认配置属性. 隔离策略 THREAD 线程池隔离, SEMAPHORE 信号池隔离, 如果采用线程池隔离,令牌中继的时候获取登录的Authorization为空, 所以无法进行令牌传递. hystrix: command: default: #default全局有效，service id指定应用有效 execution: isolation: strategy: SEMAPHORE # 隔离策略: THREAD 线程池隔离, SEMAPHORE 信号池隔离, 如果采用线程池隔离,令牌中继的时候无法获取Authorization thread: timeoutInMilliseconds: 3000 #断路器超时时间，默认1000ms Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-26 16:09:46 "},"program/SpringSecurity/":{"url":"program/SpringSecurity/","title":"SpringSecurity","keywords":"","body":"Spring Security Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-15 09:09:31 "},"program/SpringSecurity/AuthenticationProvider.html":{"url":"program/SpringSecurity/AuthenticationProvider.html","title":"自定义认证对象","keywords":"","body":"自定义认证方式 自定义认证提供者 @Component public class DaoAuthenticationProvider implements AuthenticationProvider { @Autowired private AppUserMapper appUserMapper; @Autowired private AppPermissionMapper permissionMapper; @Autowired private PasswordEncoder passwordEncoder; @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException { String username = authentication.getName(); String password = authentication.getCredentials().toString(); AppUser user = appUserMapper.queryByUsername(username); if(user == null){ throw new UsernameNotFoundException(\"用户未找到\"); } if(!passwordEncoder.matches(password,user.getPassword())){ throw new BadCredentialsException(\"密码错误\"); } List permissions = permissionMapper.queryByUserid(user.getId()); return new UsernamePasswordAuthenticationToken(user,password, AuthorityUtils.createAuthorityList(permissions.stream().map(item -> item.getCode()).toArray(String[]::new))); } @Override public boolean supports(Class authentication) { return (UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication)); } } 在WebSecurityConfig中注入 /** * @author Created by yangb on 2020/4/14 */ @Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled = true) public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Resource private DaoAuthenticationProvider daoAuthenticationProvider; @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.authenticationProvider(daoAuthenticationProvider); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\").hasAuthority(\"ADMIN\") .anyRequest().authenticated() .and() .formLogin() .loginProcessingUrl(\"/login\") .successHandler((request, response, authentication) -> { //登陆陈宫返回json数据 response.setContentType(\"application/json;charset=utf-8\"); PrintWriter out = response.getWriter(); out.write(JSON.toJSONString(ResultVo.makeSuccess(\"登陆成功\"))); out.flush(); out.close(); }) .failureHandler((request, response, exception) -> { //登陆失败返回json数据 response.setContentType(\"application/json;charset=utf-8\"); PrintWriter out = response.getWriter(); ResultVo result = ResultVo.makeFailed(exception.getMessage()); out.write(JSON.toJSONString(result)); out.flush(); out.close(); }) .permitAll() .and() .csrf().disable() .exceptionHandling().authenticationEntryPoint((request, response, authException) -> { //访问未授权的资源返回数据 response.setContentType(\"application/json;charset=utf-8\"); PrintWriter out = response.getWriter(); out.write(JSON.toJSONString(ResultVo.makeFailed(\"请登录后访问\"))); out.flush(); out.close(); }); } } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-15 08:51:03 "},"program/SpringSecurity/SpringSecurity.html":{"url":"program/SpringSecurity/SpringSecurity.html","title":"SpringSecurity单体应用","keywords":"","body":"Spring Security 基础概念 认证 会话 授权 授权的数据模型 主体 资源 权限 角色 角色和权限关系 主体和角色关系 通常企业开发中将资源和权限表合并为一张表. 数据模型如下: 用户 - 用户角色关系 -> 角色 - 角色权限关系 -> 权限 RBAC 业界的授权方案 基于角色的访问控制 Role-Base Access Control 基于资源的访问控制 Resource-Based Access Control 基于Session的认证方式 Spring Security WebSecurityConfig 用户信息 密码编码器 安全拦截机制 结构总览 解决用户的 安全访问控制, Spring Security 对web资源的保护是靠Filter实现的. SpringSecurityFilterChain 是一个 Servlet 过滤器 实现了 javax.servlet.Filter. 过滤外部请求. FilterChainProxy代理了多个Filter, 形成Filter链表. AuthenticationManager 负责授权, AccessDecisionManager 负责认证, 自定义UserDetailService @Service public class SpringDataUserDetailService implements UserDetailsService PasswordEncoder 使用BCryptPasswordEncoder加密 @Bean public PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } BCrypt 加密,每次加密结果都不一样,但是校验可以通过,增加了安全性 // 加密原始密码 String hashpw = BCrypt.hashpw(\"123\", BCrypt.gensalt()); System.out.println(hashpw); //校验密码一致性 boolean checkpw = BCrypt.checkpw(\"123\", \"$2a$10$e/Vgw1zKQDdyxd/DvyNSMeeT0TQhaDB9KbUoN8jC2f8MV9lGUobcy\"); System.out.println(checkpw); boolean checkpw1 = BCrypt.checkpw(\"123\", \"$2a$10$jIueZHE5S7WJjnZrD//HDugBxKsdLdYfuarmXC.R8S6rJqCv3ifEu\"); System.out.println(checkpw1); 安全拦截 @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/r/r1\").hasAuthority(\"p1\") .antMatchers(\"/r/r2\").hasAuthority(\"p2\") .antMatchers(\"/r\").authenticated() .anyRequest().permitAll() .and() .formLogin(); } 自定义登录页面 增加登录页面 @GetMapping(\"/login-view\") public String login(){ return \"login\"; } 自定义登录页面 login.html 用户名: 密码: 配置http安全设置 @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() ... .formLogin() .loginPage(\"/login-view\") // 登录页面 .loginProcessingUrl(\"/login\") //登录路径 .successForwardUrl(\"/r\") //登录成功跳转路径 .permitAll() .and() .csrf().disable(); // 关闭csrf安全验证 连接数据库认证 添加数据库依赖 org.springframework.boot spring-boot-starter-data-jdbc mysql mysql-connector-java 5.1.48 配置数据库 spring: datasource: username: root password: root url: jdbc:mysql://localhost:3306/user_db driver-class-name: com.mysql.jdbc.Driver 实体DTO @Data @Table(\"t_user\") public class UserDto { @Id private String id; private String username; private String password; private String fullname; private String mobile; } Dao @Repository public interface UserDao extends CrudRepository { @Query(\"SELECT * FROM `t_user` where username=:username\") UserDto findByUsername(@Param(\"username\") String username); } UserDetailService @Autowired private UserDao userDao; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { UserDto userDto = userDao.findByUsername(username); if(userDto == null){ // 如果用户查不到, 返回null, 由provider抛出异常 return null; } UserDetails details = User.withUsername(userDto.getUsername()).password(userDto.getPassword()).authorities(\"p1\").build(); return details; } 会话管理 获取用户身份 //获取当前用户信息 private String getUsername(){ Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); Object principal = authentication.getPrincipal(); if(principal == null){ return \"匿名用户\"; } if (principal instanceof UserDetails){ UserDetails userDetails = (UserDetails) principal; return userDetails.getUsername(); }else { return principal.toString(); } } 会话控制 机制 描述 always 如果没有session存在就创建一个 ifRequired 如果需要就创建一个Session(默认)登录时 never SpringSecurity将不会创建Session,但是如果应用中其他地方创建了Session,那么SpringSecurity将使用它 stateless 绝对不会创建和使用 配置方式 @Override protected void configure(HttpSecurity http) throws Exception { http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED); 自定义退出 .logout() .logoutUrl(\"/logout\") //退出地址 .logoutSuccessUrl(\"/index\"); //退出页面 Web的授权 使用资源授权, 更灵活. http.authorizeRequests() .antMatchers(\"/r/r1\").hasAuthority(\"p1\") .antMatchers(\"/r/r2\").hasAuthority(\"p2\") .antMatchers(\"/r/r3\").hasAnyAuthority(\"p1\",\"p2\") .antMatchers(\"/r/r4\").access(\"hasAuthority('p1') and hasAuthority('p2')\") .antMatchers(\"/r/**\").authenticated() .anyRequest().permitAll() 方法授权 建议基于Controller进行拦截 开启方法拦截 @EnableGlobalMethodSecurity(prePostEnabled = true) //开启方法授权 public class WebSecurityConfig extends WebSecurityConfigurerAdapter{ @PreAuthorize 在方法上加注解 p1 权限才能访问 @RequestMapping(\"/r/r1\") @PreAuthorize(\"hasAuthority('p1')\") public String r1(ModelMap map){ map.put(\"name\", \"权限1页面\"); return \"index\"; } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 10:16:54 "},"program/SpringSecurity/SpringSecurityOAuth2.html":{"url":"program/SpringSecurity/SpringSecurityOAuth2.html","title":"SpringSecurityOAuth2.0认证中心","keywords":"","body":"分布式系统认证方案 基于Token的认证方式更适合分布式认证. 项目搭建 https://github.com/yangb92/SpringAuthorization/tree/spring-cloud-security-oauth2 配置授权服务 创建配置类,开启认证服务 @Configuration @EnableAuthorizationServer public class AuthorizationServer extends AuthorizationServerConfigurerAdapter { 配置客户端详细信息 clentId: (必须) 客户id标识 secret: 客户端安全码 scope: 客户端权限 authorizedGrantTypes: 客户端授权类型,默认为空 authorities: 此客户端可以使用的授权类型,默认为空 内存方式配置客户端 @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient(\"c1\") .secret(new BCryptPasswordEncoder().encode(\"secret\")) //客户端秘钥 .resourceIds(\"res1\", \"res2\") //可访问资源列表 .authorizedGrantTypes(\"authorization_code\", \"password\", \"client_credentials\", \"implicit\", \"refresh_token\") //运行授权的类型 .scopes(\"all\") //允许授权的范围 .autoApprove(false) // false 跳转到授权页面 .redirectUris(\"http://www.baidu.com\") //授权回调地址 .and() .withClient ... } 配置令牌访问的端点和令牌服务 令牌服务 TokenStore: 令牌存储策略 InMemoryTokenStore: 存储在内存 工作在单服务器 JdbcTokenStore: 存储在数据库 可以在多个服务器共享 JwtTokenStore: 不需要后端存储 配置存储方式令牌 存在内存 @Configuration public class TokenConfig { @Bean public TokenStore tokenStore() { return new InMemoryTokenStore(); } } 配置令牌管理服务 @Autowired private TokenStore tokenStore; @Autowired private ClientDetailsService clientDetailsService; // 令牌管理服务 @Bean public AuthorizationServerTokenServices tokenServices() { DefaultTokenServices services = new DefaultTokenServices(); services.setClientDetailsService(clientDetailsService); // 客户端详情服务 services.setSupportRefreshToken(true); // 支持令牌刷新 services.setTokenStore(tokenStore); // 令牌存储策略 services.setAccessTokenValiditySeconds(7200); // 令牌有效期2小时 services.setRefreshTokenValiditySeconds(259200); // 刷新令牌默认有效期3天 return services; } 令牌访问端点配置 AuthorizationServerEndpointsConfigurer 通过设定以下属性决定支持的授权类型(Grant Types) authenticationManager: 认证管理器,password授权类型.用于密码模式需要配置 UserDetailService: 用于密码模式需要配置 authorizationCodeServices: 设置授权码服务的,用于authorization_code授权类型 implicitGrantService: 用于设置隐式授权模式. tokenGranter: 当设置了即TokenGranter接口实现, 授权将由自己掌控, 这个一般用来做扩展用途. 配置授权端点的URL(Endpoint URLs) AuthorizationServerEndpointsConfiguration 这个配置对象有一个叫做pathMapping()的方法用来配置端点的URL连接 第一个参数:默认连接, 第二个参数:你需要替换的连接 框架默认的连接如下: /oauth/authorize: 授权端点 /oauth/token: 令牌端点 /oauth/confirm_access: 用户确认授权端点 /oauth/error: 授权服务错误信息端点 /oauth/check_token: 用于资源服务访问的令牌解析端点 /oauth/token_key: 提供公有密匙的端点, 如果使用JWT令牌的话 WebSecurity配置 @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) @Configuration public class WebSecurityConfig extends WebSecurityConfigurerAdapter { // 认证管理器 @Bean @Override protected AuthenticationManager authenticationManager() throws Exception { return super.authenticationManager(); } // 密码编码器 @Bean public PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } // 安全拦截机制 @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/r/r1\").hasAuthority(\"p1\") .antMatchers(\"/login**\").permitAll() .anyRequest().authenticated() .and() .formLogin(); } } 配置令牌访问端点和授权码服务 @Configuration @EnableAuthorizationServer public class AuthorizationServer extends AuthorizationServerConfigurerAdapter { @Autowired private TokenStore tokenStore; @Autowired private ClientDetailsService clientDetailsService; @Autowired private AuthorizationCodeServices authorizationCodeServices; @Autowired private AuthenticationManager authenticationManager; @Autowired private AuthorizationServerTokenServices tokenServices; // 令牌访问端点 @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints.authenticationManager(authenticationManager) //认证管理器 .authorizationCodeServices(authorizationCodeServices) // 授权码服务 .tokenServices(tokenServices) // 令牌管理服务 .allowedTokenEndpointRequestMethods(HttpMethod.POST); } // 配置授权码服务 @Bean public AuthorizationCodeServices authorizationCodeServices() { // 设置授权码模式的授权码如何存取,暂时采用内存方式 return new InMemoryAuthorizationCodeServices(); } ... 配置令牌端点的安全约束 // 令牌访问安全约束 @Override public void configure(AuthorizationServerSecurityConfigurer security) throws Exception { security .tokenKeyAccess(\"permitAll()\") //oauth/token_key 是公开 .checkTokenAccess(\"permitAll()\") //oauth/check_token 公开 .allowFormAuthenticationForClients(); //表单认证 } 授权码模式 最为安全 资源拥有者打开客户端,客户端要求资源拥有者给予授权,它将被浏览器重定向到服务器,重定向时会附加客户端身份信息./uaa/oauth/authorize?client_id=c1&response_type=code&scope=all&redirect_url=http://www.baidu.com/ 参数: client_id: 客户端标识 response_type: 授权码模式固定位code scope:客户端权限 redirect: 跳转url,授权码申请成功后跳转到此地址,并在后面带上code参数(授权码) 和配置客户端跳转url一致 浏览器重定向授权服务器授权页面,之后用户将同意授权 授权服务器授权码(AuthorizationCode)带到url参数上发送给client(通过redirect_uri) 客户端拿着授权码向授权服务器索要访问access_token/uaa/oauth/token?client_id=c1&client_secret=secret&grant_type=authorization_code&code=5pgxfcD&redirect_uri=http://www.baidu.com/ 参数: cilent_id: 客户端标识 secret: 客户端密匙 grant_type: 授权类型 code: 授权码, 注意:授权码只使用一次就无效了. redirect_uri: 和配置客户端跳转url一致 服务器返回授权码 { \"access_token\": \"6b94c4c1-1803-484e-b5da-943b96266ff1\", \"token_type\": \"bearer\", \"refresh_token\": \"8b4a2631-ef09-4145-9f32-f96b0904e5d8\", \"expires_in\": 43199, \"scope\": \"all\" } 简化模式 资源拥有者打开客户端,要求资源拥有者给与授权,它将被浏览器重定向到授权服务器, 重定向时会附加客户端信息. /uaa/oauth/authorize?client_id=c1&response_type=token&scope=all&redirect_uri=http://www.baidu.com response_type=token 说明是简化模式 浏览器重定向到授权服务器页面,用户同意授权 授权服务器将令牌,以Hash的形式存放在重定向uri的fragment发送给浏览器.https://www.baidu.com/#access_token=6b94c4c1-1803-484e-b5da-943b96266ff1&token_type=bearer&expires_in=42776 注: fragment http://example.com#L18 这个L18就是fragment的值. 一般来说,简化模式用于没有服务端的第三方单页面应用. 密码模式 资源拥有者将用户名,密码发送给客户端. 客户端拿着用户名和密码向授权服务器请求令牌/uaa/oauth/token?client_id=c1&client_secret=secret&grant_type=password&username=lisi&password=123 授权服务器将令牌发送给client] 这种模式十分简单,意味着直接将用户敏感信息泄露给了client, 因此这种模式只适用于我们自己的系统 客户端模式 客户端向授权服务器发送自己的身份信息,并请求令牌 确认客户端身份无误后,将令牌发送给clien /uaa/oauth/token?client_id=c1&client_secret=secret&grant_type=client_credentials 资源服务器配置 资源服务配置 测试: GET http://localhost:53021/order/r1 首先申请Token,将Token放在请求头中,访问资源服务接口 Authorization:Bearer 6b94c4c1-1803-484e-b5da-943b96266ff1 JWT 令牌 介绍 JWT令牌本身存储了用户信息.不需要进行存储. 优点: 基于json 自定义内容,易扩展. 非对称加密,防篡改,安全 资源服务使用JWT不依赖认证服务. 缺点: 令牌过长, 占用空间大. JWT令牌结构 Header Payload Signture UAA 认证端配置 配置: JWT TockenStore private String SIGN_KEY = \"123\"; @Bean public TokenStore tokenStore() { // JWT 令牌存储方案 return new JwtTokenStore(accessTokenConverter()); } // 令牌转换器 @Bean public JwtAccessTokenConverter accessTokenConverter() { JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); converter.setSigningKey(SIGN_KEY); // 对称密匙 return converter; } 配置令牌管理服务 // 令牌管理服务 @Bean @DependsOn({\"tokenStore\",\"accessTokenConverter\"}) public AuthorizationServerTokenServices tokenServices(ClientDetailsService clientDetailsService) { DefaultTokenServices services = new DefaultTokenServices(); services.setClientDetailsService(clientDetailsService); // 客户端详情服务 services.setSupportRefreshToken(true); // 支持令牌刷新 services.setTokenStore(tokenStore); // 令牌存储策略 // 令牌增强 TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain(); tokenEnhancerChain.setTokenEnhancers(Arrays.asList(accessTokenConverter)); services.setTokenEnhancer(tokenEnhancerChain); services.setAccessTokenValiditySeconds(7200); // 令牌有效期2小时 services.setRefreshTokenValiditySeconds(259200); // 刷新令牌默认有效期3天 return services; } 资源服务配置 TokenConfig @Configuration public class TokenConfig { private String SIGN_KEY = \"123\"; @Bean public TokenStore tokenStore() { // JWT 令牌存储方案 return new JwtTokenStore(accessTokenConverter()); } // 令牌转换器 @Bean public JwtAccessTokenConverter accessTokenConverter() { JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); converter.setSigningKey(SIGN_KEY); // 对称密匙 return converter; } } 资源服务配置 @Override public void configure(ResourceServerSecurityConfigurer resources) throws Exception { resources.resourceId(RESOURCE_ID) // .tokenServices(tokenServices) //验证令牌的服务 .tokenStore(tokenStore) .stateless(true); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 10:50:18 "},"program/SpringSecurity/ContextRepository.html":{"url":"program/SpringSecurity/ContextRepository.html","title":"Redis会话共享","keywords":"","body":"定制 Security 上下文存储 使用Redis管理会话 Docker Redis安装 在目录/usr/local/docker/redis创建docker-compose.yml配置文件 docker-compose.yml version: '3' services: redis: image: redis:5 container_name: redis restart: always ports: - '6379:6379' volumes: - ./data:/data 运行 docker-compose up -d 加入Redis依赖 org.springframework.boot spring-boot-starter-data-redis application.yml配置文件 spring: redis: host: 192.168.10.45 timeout: 3000 配置RedisConfig.java配置文件 /** * Created by yangb on 2020/4/17 */ @Configuration public class RedisConfig { @Bean public RedisTemplate securityContextRedisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); template.setValueSerializer(new SecurityContextSerializer()); return template; } /** * SecurityContext 序列化 */ private class SecurityContextSerializer implements RedisSerializer{ @Override public byte[] serialize(SecurityContext securityContext) throws SerializationException { if (securityContext == null) { return null; } String s = JSON.toJSONString(securityContext); return s.getBytes(Charset.forName(\"UTF-8\")); } @Override public SecurityContext deserialize(byte[] bytes) throws SerializationException { SecurityContextImpl securityContext = new SecurityContextImpl(); if (bytes == null) { return securityContext; } String json = new String(bytes, Charset.forName(\"UTF-8\")); final JSONObject jb = JSON.parseObject(json); JSONObject authentication = jb.getJSONObject(\"authentication\"); if(authentication == null) { return securityContext; } AppUser user = authentication.getObject(\"principal\", AppUser.class); JSONArray authorities = authentication.getJSONArray(\"authorities\"); String [] authoritiesArray = new String[authorities.size()]; for (int i = 0; i 配置RedisSecurityContextRepository.java上下文仓库 /** * Created by yangb on 2020/4/17 */ @Component public class RedisSecurityContextRepository implements SecurityContextRepository { @Resource private RedisTemplate securityContextRedisTemplate; @Override public SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder) { String requestedSessionId = requestResponseHolder.getRequest().getRequestedSessionId(); return securityContextRedisTemplate.opsForValue().get(requestedSessionId); } @Override public void saveContext(SecurityContext context, HttpServletRequest request, HttpServletResponse response) { String requestedSessionId = request.getRequestedSessionId(); securityContextRedisTemplate.opsForValue().set(requestedSessionId,context,30, TimeUnit.MINUTES); } @Override public boolean containsContext(HttpServletRequest request) { return securityContextRedisTemplate.hasKey(request.getRequestedSessionId()); } /** * 清除Redis上下文 */ public boolean cleanContext(HttpServletRequest request){ return securityContextRedisTemplate.delete(request.getRequestedSessionId()); } } 配置上下文仓库 和 退出时执行清除Redis中上下环境, @Override protected void configure(HttpSecurity http) throws Exception { http .securityContext() .securityContextRepository(redisSecurityContextRepository); .logout() .logoutSuccessHandler((request, response, authentication) -> { redisSecurityContextRepository.cleanContext(request); //清除缓存会话 }) ... Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 17:24:32 "},"program/SpringMVC/":{"url":"program/SpringMVC/","title":"SpringMVC","keywords":"","body":"Spring MVC Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-15 09:00:55 "},"program/SpringMVC/HandlerMethodArgumentResolver.html":{"url":"program/SpringMVC/HandlerMethodArgumentResolver.html","title":"自定义参数解析器","keywords":"","body":"自定义参数解析器 HandlerMethodArgumentResolver 定义注解 /** * 标记当前用户注解, 由MVC参数解析器注入 * @author Created by yangb on 2020/4/14 */ @Target({ElementType.PARAMETER}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface CurrentUser { } 定义参数解析器UserHandlerMethodArgumentResolver.java /** * 自定义参数解析器 * @author Created by yangb on 2020/4/14 */ public class UserHandlerMethodArgumentResolver implements HandlerMethodArgumentResolver { @Override public boolean supportsParameter(MethodParameter methodParameter) { //判断是否需要解析参数, 如果方法参数有CurrentUser注解,需要解析返回true return methodParameter.hasParameterAnnotation(CurrentUser.class); } @Override public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception { // 解析参数,返回参数对象 Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal(); if(principal instanceof AppUser){ return (AppUser) principal; } return null; } } 在MVC中配置该参数解析器 @Configuration public class WebMvcConfig implements WebMvcConfigurer { /** * 添加参数解析器 * @param resolvers */ @Override public void addArgumentResolvers(List resolvers) { resolvers.add(new UserHandlerMethodArgumentResolver()); } } 在Controller中使用 @RequestMapping(\"/admin\") public ResultVo admin(@CurrentUser AppUser user) { return ResultVo.makeSuccess(user); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-15 09:01:55 "},"program/Docker/":{"url":"program/Docker/","title":"Docker","keywords":"","body":"Docker Docker 文档: https://www.funtl.com/zh/docs-docker/ 基本概念 Docker 包括三个基本概念 镜像（Image） Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 分层存储:镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。 容器（Container） 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。 按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。 仓库（Repository） 公有仓库 私有仓库 标题 说明 镜像(Images) Docker 镜像是用于创建 Docker 容器的模板。 容器(Container) 容器是独立运行的一个或一组应用。 客户端(Client) Docker 客户端通过命令行或者其他工具使用 Docker API (https://docs.docker.com/reference/api/docker_remote_api) 与 Docker 的守护进程通信。 主机(Host) 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。 仓库(Registry) Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。 Docker Machine Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 13:41:37 "},"program/Docker/install.html":{"url":"program/Docker/install.html","title":"Docker 安装","keywords":"","body":"Docker安装 Ubuntu 安装 脚本自动安装: curl -fsSL get.docker.com -o get-docker.sh sh get-docker.sh --mirror Aliyun 检测Docker是否安装成功 docker version 配置阿里云Docker镜像加速器 下载镜像 docker pull 镜像名称 启动镜像 docker run -p 80:8080 tomcat Docker 仓库 公共仓库: https://hub.docker.com Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 13:41:59 "},"program/Docker/Compose.html":{"url":"program/Docker/Compose.html","title":"Docker-Compose安装卸载","keywords":"","body":"Docker Compose 学习地址https://www.funtl.com/zh/docker-compose/ Docker 三剑客之一, 必会. 负责实现对Docker集群的快速编排. 安装 Compose 支持 Linux、macOS、Windows 10 三大平台。Compose 可以通过 Python 的包管理工具 pip 进行安装 二进制包 $ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose $ sudo chmod +x /usr/local/bin/docker-compose PIP 安装 $ sudo pip install -U docker-compose 测试 docker-compose version bash 补全命令 $ curl -L https://raw.githubusercontent.com/docker/compose/1.8.0/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose 容器中执行 Compose 既然是一个 Python 应用，自然也可以直接用容器来执行它。 $ curl -L https://github.com/docker/compose/releases/download/1.8.0/run.sh > /usr/local/bin/docker-compose $ chmod +x /usr/local/bin/docker-compose 卸载 如果是二进制包方式安装的，删除二进制文件即可。 $ sudo rm /usr/local/bin/docker-compose 如果是通过 pip 安装的，则执行如下命令即可删除。 $ sudo pip uninstall docker-compose 基本使用 编写docker-compose.yml 这个是Compose使用的主模板文件 version: '3' services: tomcat: restart: always image: tomcat container_name: tomcat ports: - 80:8080 运行compose项目 docker-compose up [--build] [-d] --build: 重新构建Dockerfile -d: 后台运行 关闭docker项目 docker-compose down [--rmi all] 关闭并移除构建的镜像 环境变量 compose file 中为容器设置环境变量： web: environment: DEBUG: 1 shell 写法 docker run -e DEBUG=1 使用文件设置环境变量 web: env_file: - web-variables.env shell写法: docker run --env-file=web-variables.env .env 文件为 docker-compose.yml 文件引用的所有环境变量设置默认值！ # define env var default value. IMAGETAG=defaultwebimage APPNAME=default app name AUTHOR=default author name VERSION=default version is 1.0 使用.env中的环境变量 version: '3' services: web: image: ${IMAGETAG} Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-29 14:15:59 "},"program/Docker/ComposeCommand.html":{"url":"program/Docker/ComposeCommand.html","title":"Docker-Compose命令说明","keywords":"","body":"Docker-Compose 命令说明 命令对象与格式 对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。 执行 docker-compose [COMMAND] --help 或者 docker-compose help [COMMAND] 可以查看具体某个命令的使用格式。 docker-compose 命令的基本的使用格式是 docker-compose [-f=...] [options] [COMMAND] [ARGS...] 命令选项 -f, --file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。 -p, --project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。 --x-networking 使用 Docker 的可拔插网络后端特性 --x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge --verbose 输出更多调试信息。 -v, --version 打印版本并退出。 build 格式为 docker-compose build [options] [SERVICE...]。 构建（重新构建）项目中的服务容器。 服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。 可以随时在项目目录下运行 docker-compose build 来重新构建服务。 选项包括： --force-rm 删除构建过程中的临时容器。 --no-cache 构建镜像过程中不使用 cache（这将加长构建过程）。 --pull 始终尝试通过 pull 来获取更新版本的镜像。 #config 验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。 #down 此命令将会停止 up 命令所启动的容器，并移除网络 #exec 进入指定的容器。 #help 获得一个命令的帮助。 #images 列出 Compose 文件中包含的镜像。 #kill 格式为 docker-compose kill [options] [SERVICE...]。 通过发送 SIGKILL 信号来强制停止服务容器。 支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。 $ docker-compose kill -s SIGINT 1 #logs 格式为 docker-compose logs [options] [SERVICE...]。 查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 --no-color 来关闭颜色。 该命令在调试问题的时候十分有用。 #pause 格式为 docker-compose pause [SERVICE...]。 暂停一个服务容器。 #port 格式为 docker-compose port [options] SERVICE PRIVATE_PORT。 打印某个容器端口所映射的公共端口。 选项： --protocol=proto 指定端口协议，tcp（默认值）或者 udp。 --index=index 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。 #ps 格式为 docker-compose ps [options] [SERVICE...]。 列出项目中目前的所有容器。 选项： -q 只打印容器的 ID 信息。 #pull 格式为 docker-compose pull [options] [SERVICE...]。 拉取服务依赖的镜像。 选项： --ignore-pull-failures 忽略拉取镜像过程中的错误。 #push 推送服务依赖的镜像到 Docker 镜像仓库。 #restart 格式为 docker-compose restart [options] [SERVICE...]。 重启项目中的服务。 选项： -t, --timeout TIMEOUT 指定重启前停止容器的超时（默认为 10 秒）。 #rm 格式为 docker-compose rm [options] [SERVICE...]。 删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。 选项： -f, --force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。 -v 删除容器所挂载的数据卷。 #run 格式为 docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]。 在指定服务上执行一个命令。 例如： $ docker-compose run ubuntu ping docker.com 1 将会启动一个 ubuntu 服务容器，并执行 ping docker.com 命令。 默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。 该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。 两个不同点： 给定命令将会覆盖原有的自动运行命令； 不会自动创建端口，以避免冲突。 如果不希望自动启动关联的容器，可以使用 --no-deps 选项，例如 $ docker-compose run --no-deps web python manage.py shell 1 将不会启动 web 容器所关联的其它容器。 选项： -d 后台运行容器。 --name NAME 为容器指定一个名字。 --entrypoint CMD 覆盖默认的容器启动指令。 -e KEY=VAL 设置环境变量值，可多次使用选项来设置多个环境变量。 -u, --user=\"\" 指定运行容器的用户名或者 uid。 --no-deps 不自动启动关联的服务容器。 --rm 运行命令后自动删除容器，d 模式下将忽略。 -p, --publish=[] 映射容器端口到本地主机。 --service-ports 配置服务端口并映射到本地主机。 -T 不分配伪 tty，意味着依赖 tty 的指令将无法运行。 #scale 格式为 docker-compose scale [options] [SERVICE=NUM...]。 设置指定服务运行的容器个数。 通过 service=num 的参数来设置数量。例如： $ docker-compose scale web=3 db=2 1 将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。 一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。 选项： -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 #start 格式为 docker-compose start [SERVICE...]。 启动已经存在的服务容器。 #stop 格式为 docker-compose stop [options] [SERVICE...]。 停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。 选项： -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 #top 查看各个服务容器内运行的进程。 #unpause 格式为 docker-compose unpause [SERVICE...]。 恢复处于暂停状态中的服务。 #up 格式为 docker-compose up [options] [SERVICE...]。 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。 链接的服务都将会被自动启动，除非已经处于运行状态。 可以说，大部分时候都可以直接通过该命令来启动一个项目。 默认情况，docker-compose up 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。 当通过 Ctrl-C 停止命令时，所有容器将会停止。 如果使用 docker-compose up -d，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。 默认情况，如果服务容器已经存在，docker-compose up 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 docker-compose up --no-recreate。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 docker-compose up --no-deps -d 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。 选项： -d 在后台运行服务容器。 --no-color 不使用颜色来区分不同的服务的控制台输出。 --no-deps 不启动服务所链接的容器。 --force-recreate 强制重新创建容器，不能与 --no-recreate 同时使用。 --no-recreate 如果容器已经存在了，则不重新创建，不能与 --force-recreate 同时使用。 --no-build 不自动构建缺失的服务镜像。 -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 #version 格式为 docker-compose version。 打印版本信息。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-15 10:51:07 "},"program/Docker/ComposeTemplate.html":{"url":"program/Docker/ComposeTemplate.html","title":"Docker-Compose模板文件","keywords":"","body":"Docker Compose 模板文件 模板文件是使用 Compose 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 docker run 相关参数的含义都是类似的。 默认的模板文件名称为 docker-compose.yml，格式为 YAML 格式。 version: \"3\" services: webapp: image: examples/web ports: - \"80:80\" volumes: - \"/data\" 注意每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）等来自动构建生成镜像。 如果使用 build 指令，在 Dockerfile 中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在 docker-compose.yml 中再次设置。 下面分别介绍各个指令的用法。 build 指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。 version: '3' services: webapp: build: ./dir 你也可以使用 context 指令指定 Dockerfile 所在文件夹的路径。 使用 dockerfile 指令指定 Dockerfile 文件名。 使用 arg 指令指定构建镜像时的变量。 version: '3' services: webapp: build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 使用 cache_from 指定构建镜像的缓存 build: context: . cache_from: - alpine:latest - corp/web_app:3.14 cap_add, cap_drop 指定容器的内核能力（capacity）分配。 例如，让容器拥有所有能力可以指定为： cap_add: - ALL 去掉 NET_ADMIN 能力可以指定为： cap_drop: - NET_ADMIN command 覆盖容器启动后默认执行的命令。 command: echo \"hello world\" configs 仅用于 Swarm mode cgroup_parent 指定父 cgroup 组，意味着将继承该组的资源限制。 例如，创建了一个 cgroup 组名称为 cgroups_1。 cgroup_parent: cgroups_1 container_name 指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式。 container_name: docker-web-container 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。 deploy 仅用于 Swarm mode devices 指定设备映射关系。 devices: - \"/dev/ttyUSB1:/dev/ttyUSB0\" #depends_on 解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web version: '3' services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres 注意：web 服务不会等待 redis db 「完全启动」之后才启动。 #dns 自定义 DNS 服务器。可以是一个值，也可以是一个列表。 dns: 8.8.8.8 dns: - 8.8.8.8 - 114.114.114.114 #dns_search 配置 DNS 搜索域。可以是一个值，也可以是一个列表。 dns_search: example.com dns_search: - domain1.example.com - domain2.example.com #tmpfs 挂载一个 tmpfs 文件系统到容器。 tmpfs: /run tmpfs: - /run - /tmp #env_file 从文件中获取环境变量，可以为单独的文件路径或列表。 如果通过 docker-compose -f FILE 方式来指定 Compose 模板文件，则 env_file 中变量的路径会基于模板文件路径。 如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准。 env_file: .env env_file: - ./common.env - ./apps/web.env - /opt/secrets.env 环境变量文件中每一行必须符合格式，支持 # 开头的注释行。 # common.env: Set development environment PROG_ENV=development #environment 设置环境变量。你可以使用数组或字典两种格式。 只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。 environment: RACK_ENV: development SESSION_SECRET: environment: - RACK_ENV=development - SESSION_SECRET 如果变量名称或者值中用到 true|false，yes|no 等表达 布尔 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括 y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF #expose 暴露端口，但不映射到宿主机，只被连接的服务访问。 仅可以指定内部端口为参数 expose: - \"3000\" - \"8000\" #external_links 注意：不建议使用该指令。 链接到 docker-compose.yml 外部的容器，甚至并非 Compose 管理的外部容器。 external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql #extra_hosts 类似 Docker 中的 --add-host 参数，指定额外的 host 名称映射信息。 extra_hosts: - \"googledns:8.8.8.8\" - \"dockerhub:52.1.157.61\" 会在启动后的服务容器中 /etc/hosts 文件中添加如下两条条目。 8.8.8.8 googledns 52.1.157.61 dockerhub #healthcheck 通过命令检查容器是否健康运行。 healthcheck: test: [\"CMD\", \"curl\", \"-f\", \"http://localhost\"] interval: 1m30s timeout: 10s retries: 3 #image 指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。 image: ubuntu image: orchardup/postgresql image: a4bc65fd #labels 为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。 labels: com.startupteam.description: \"webapp for a startup team\" com.startupteam.department: \"devops department\" com.startupteam.release: \"rc3 for v1.0\" #links 注意：不推荐使用该指令。 #logging 配置日志选项。 logging: driver: syslog options: syslog-address: \"tcp://192.168.0.42:123\" 目前支持三种日志驱动类型。 driver: \"json-file\" driver: \"syslog\" driver: \"none\" options 配置日志驱动的相关参数。 options: max-size: \"200k\" max-file: \"10\" #network_mode 设置网络模式。使用和 docker run 的 --network 参数一样的值。 network_mode: \"bridge\" network_mode: \"host\" network_mode: \"none\" network_mode: \"service:[service name]\" network_mode: \"container:[container name/id]\" #networks 配置容器连接的网络。 version: \"3\" services: some-service: networks: - some-network - other-network networks: some-network: other-network: #pid 跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。 pid: \"host\" #ports 暴露端口信息。 使用宿主端口：容器端口 (HOST:CONTAINER) 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。 ports: - \"3000\" - \"8000:8000\" - \"49100:22\" - \"127.0.0.1:8001:8001\" 注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。 #secrets 存储敏感数据，例如 mysql 服务密码。 version: \"3.1\" services: mysql: image: mysql environment: MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password secrets: - db_root_password - my_other_secret secrets: my_secret: file: ./my_secret.txt my_other_secret: external: true #security_opt 指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。 security_opt: - label:user:USER - label:role:ROLE #stop_signal 设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。 stop_signal: SIGUSR1 #sysctls 配置容器内核参数。 sysctls: net.core.somaxconn: 1024 net.ipv4.tcp_syncookies: 0 sysctls: - net.core.somaxconn=1024 - net.ipv4.tcp_syncookies=0 #ulimits 指定容器的 ulimits 限制值。 例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。 ulimits: nproc: 65535 nofile: soft: 20000 hard: 40000 #volumes 数据卷所挂载路径设置。可以设置宿主机路径 （HOST:CONTAINER） 或加上访问模式 （HOST:CONTAINER:ro）。 该指令中路径支持相对路径。 volumes: - /var/lib/mysql - cache/:/tmp/cache - ~/configs:/etc/configs/:ro #其它指令 此外，还有包括 domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir 等指令，基本跟 docker run 中对应参数的功能一致。 指定服务容器启动后执行的入口文件。 entrypoint: /code/entrypoint.sh 指定容器中运行应用的用户名。 user: nginx 指定容器中工作目录。 working_dir: /code 指定容器中搜索域名、主机名、mac 地址等。 domainname: your_website.com hostname: test mac_address: 08-00-27-00-0C-0A 允许容器中运行一些特权命令。 privileged: true 指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 always 或者 unless-stopped。 restart: always 以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。 read_only: true 打开标准输入，可以接受外部输入。 stdin_open: true 模拟一个伪终端。 tty: true #读取变量 Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 .env 文件中的变量。 例如，下面的 Compose 文件将从运行它的环境中读取变量 ${MONGO_VERSION} 的值，并写入执行的指令中。 version: \"3\" services: db: image: \"mongo:${MONGO_VERSION}\" 如果执行 MONGO_VERSION=3.2 docker-compose up 则会启动一个 mongo:3.2 镜像的容器；如果执行 MONGO_VERSION=2.8 docker-compose up 则会启动一个 mongo:2.8 镜像的容器。 若当前目录存在 .env 文件，执行 docker-compose 命令时将从该文件中读取变量。 在当前目录新建 .env 文件并写入以下内容。 # 支持 # 号注释 MONGO_VERSION=3.6 执行 docker-compose up 则会启动一个 mongo:3.6 镜像的容器。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-15 11:07:19 "},"program/Docker/demo.html":{"url":"program/Docker/demo.html","title":"Docker-Compose常用配置","keywords":"","body":"Docker 实战 Tomcat version: '3.1' services: tomcat: restart: always image: tomcat container_name: tomcat ports: - 8080:8080 volumes: - /usr/local/docker/tomcat/webapps/test:/usr/local/tomcat/webapps/test environment: TZ: Asia/Shanghai MySql MySQL5 version: '3.1' services: mysql: restart: always image: mysql:5.7.22 container_name: mysql ports: - 3306:3306 environment: TZ: Asia/Shanghai MYSQL_ROOT_PASSWORD: 123456 command: --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 --max_allowed_packet=128M --sql-mode=\"STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO\" volumes: - mysql-data:/var/lib/mysql volumes: mysql-data: MySQL8 version: '3.1' services: db: image: mysql restart: always environment: MYSQL_ROOT_PASSWORD: 123456 command: --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 ports: - 3306:3306 volumes: - ./data:/var/lib/mysql adminer: image: adminer restart: always ports: - 8080:8080 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-15 11:10:42 "},"program/CI/":{"url":"program/CI/","title":"持续集成 CI","keywords":"","body":"持续集成 方案一: gitlab -> gitrunner -> docker -> docker-compose Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 09:44:41 "},"program/CI/GitLabOnDocker.html":{"url":"program/CI/GitLabOnDocker.html","title":"Gitlab On Docker","keywords":"","body":"Gitlab Docker 安装 Gitlab Docker安装 获取Gitlab镜像 汉化版的gitlab docker pull twang2218/gitlab-ce-zh docker-compose.yml 配置gitlab 在 /usr/local/docker/gitlab'目录下,创建docker-compose.yml文件 version: '3' services: web: image: 'twang2218/gitlab-ce-zh' restart: always hostname: 'gitlab.yangb.xyz' environment: TZ: 'Asia/Shanghai' GITLAB_OMNIBUS_CONFIG: | external_url 'http://gitlab.yangb.xyz' prots: - '80:80' - '443:443' - '22:22' volumes: - /usr/local/docker/gitlab/config:/etc/gitlab - /usr/local/docker/gitlab/data:/var/opt/gitlab - /usr/local/docker/logs:/var/log/gitlab GITLAB_OMNIBUS_CONFIG: | 配置详解 external_url 'http://gitlab.yangb.xyz:8080' # 访问地址和端口 gitlab_rails['gitlab_shell_ssh_port'] = 2222 # ssh 访问端口,免密访问 unicorn['port'] = 8888 # 内部端口 nginx['listen_port'] = 8080 # nginx端口和上面端口需要一致 ports: #上面端口映射关系 '8080:8080' '8443:443' '2222:22' Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 09:42:23 "},"program/CI/GitLabRunnerDocker.html":{"url":"program/CI/GitLabRunnerDocker.html","title":"GilabRunner","keywords":"","body":"GitLab Runner linux 系统安装 添加依赖库 # For Debian/Ubuntu/Mint curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash # For RHEL/CentOS/Fedora curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh | sudo bash 安装 # MacOS sudo brew install gitlab-ci-multi-runner # For Debian/Ubuntu/Mint sudo apt-get install gitlab-ci-multi-runner # For RHEL/CentOS/Fedora sudo yum install gitlab-ci-multi-runner 常见问题: GitRunner 执行Docker 命令启动Permission Denied,需要将gitlab-runner加入Docker组 gpasswd -a gitlab-runner docker newgrp docker GitLab Runner Docker安装 使用GitLab CI 运行构建任务会影响GitLab性能. GitLab CI最大的作用是管理项目的构建状态,因此构建任务由GitLab Runner(GitLab 高级技能)来做. 环境准备 创建工作目录: /usr/local/docker/runner 创建构建目录: /usr/local/runner/evironment 下载jdk-8u152-linux-x64.tar.gz并复制到/usr/local/runner/evironment 下载apache-maven-3.5.3-bin.tar.gz并复制到/usr/local/docker/runner/environment daemon.json 在 /usr/local/docker/runner/environment 目录下创建 daemon.json，用于配置加速器和仓库地址 { \"registry-mirrors\": [ \"https://registry.docker-cn.com\" ], \"insecure-registries\": [ \"192.168.10.133:5000\" ] } Dockerfile 在 /usr/local/docker/runner/environment 目录下创建 Dockerfile FROM gitlab/gitlab-runner MAINTAINER Lusifer # 修改软件源 RUN echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse' > /etc/apt/sources.list && \\ echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse' >> /etc/apt/sources.list && \\ echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse' >> /etc/apt/sources.list && \\ echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse' >> /etc/apt/sources.list && \\ apt-get update -y && \\ apt-get clean # 安装 Docker RUN apt-get -y install apt-transport-https ca-certificates curl software-properties-common && \\ curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add - && \\ add-apt-repository \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\" && \\ apt-get update -y && \\ apt-get install -y docker-ce COPY daemon.json /etc/docker/daemon.json # 安装 Docker Compose WORKDIR /usr/local/bin RUN wget https://raw.githubusercontent.com/topsale/resources/master/docker/docker-compose RUN chmod +x docker-compose # 安装 Java RUN mkdir -p /usr/local/java WORKDIR /usr/local/java COPY jdk-8u152-linux-x64.tar.gz /usr/local/java RUN tar -zxvf jdk-8u152-linux-x64.tar.gz && \\ rm -fr jdk-8u152-linux-x64.tar.gz # 安装 Maven RUN mkdir -p /usr/local/maven WORKDIR /usr/local/maven # RUN wget https://raw.githubusercontent.com/topsale/resources/master/maven/apache-maven-3.5.3-bin.tar.gz COPY apache-maven-3.5.3-bin.tar.gz /usr/local/maven RUN tar -zxvf apache-maven-3.5.3-bin.tar.gz && \\ rm -fr apache-maven-3.5.3-bin.tar.gz # COPY settings.xml /usr/local/maven/apache-maven-3.5.3/conf/settings.xml # 配置环境变量 ENV JAVA_HOME /usr/local/java/jdk1.8.0_152 ENV MAVEN_HOME /usr/local/maven/apache-maven-3.5.3 ENV PATH $PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin WORKDIR / docker-compose.yml 在 /usr/local/docker/runner 目录下创建 docker-compose.yml version: '3.1' services: gitlab-runner: build: environment restart: always container_name: gitlab-runner privileged: true volumes: - ./config:/etc/gitlab-runner - /var/run/docker.sock:/var/run/docker.sock version: '3.1' services: gs-wsbs: image: gs-wsbs restart: always container_name: gs-wsbsdt privileged: true ports: - '8090:8080' 注册 Runner docker exec -it gitlab-runner gitlab-runner register # 输入 GitLab 地址 Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/): http://192.168.10.132/ # 输入 GitLab Token Please enter the gitlab-ci token for this runner: 1Lxq_f1NRfCfeNbE5WRh # 输入 Runner 的说明 Please enter the gitlab-ci description for this runner: 可以为空 # 设置 Tag，可以用于指定在构建规定的 tag 时触发 ci Please enter the gitlab-ci tags for this runner (comma separated): deploy # 这里选择 true ，可以用于代码上传后直接执行 Whether to run untagged builds [true/false]: true # 这里选择 false，可以直接回车，默认为 false Whether to lock Runner to current project [true/false]: false # 选择 runner 执行器，这里我们选择的是 shell Please enter the executor: virtualbox, docker+machine, parallels, shell, ssh, docker-ssh+machine, kubernetes, docker, docker-ssh: shell 使用Runner GitLab CI 地址与令牌参数 项目 –> 设置 –> CI/CD –> Runner 设置 .gitlab-ci.yml 在项目工程下编写.gitlab-ci.yml配置文件： stages: - build - run - clean build: stage: build only: - v5 script: - mvn clean package -Dmaven.test.skip=true - mv ygzw_wsbsdt_front/target/ygzw_wsbsdt_front.war docker/ROOT.war - cd docker - docker build -t gs-wsbs . run: stage: run only: - v5 script: - cd docker - docker-compose down - docker-compose up -d clean: stage: clean only: - v5 script: - docker rmi $(docker images -q -f dangling=true) 上面的配置把一次 Pipeline 分成五个阶段： 安装依赖(install_deps) 运行测试(test) 编译(build) 部署测试服务器(deploy_test) 部署生产服务器(deploy_production) 注意： 设置 Job.only 后，只有当 develop 分支和 master 分支有提交的时候才会触发相关的 Jobs。 节点说明： stages：定义构建阶段，这里只有一个阶段 deploy deploy：构建阶段 deploy 的详细配置也就是任务配置 script：需要执行的 shell 脚本 only：这里的 master 指在提交到 master 时执行 tags：与注册 runner 时的 tag 匹配 其它命令 删除注册信息 gitlab-ci-multi-runner unregister --name \"名称\" 查看注册列表 gitlab-ci-multi-runner list 附：项目配置 Dockerfile 案例 FROM tomcat:8 MAINTAINER yangb http://yangb.xyz COPY ROOT.war /usr/local/tomcat/webapps/ROOT.war FROM openjdk:8-jre MAINTAINER Lusifer ENV APP_VERSION 1.0.0-SNAPSHOT ENV DOCKERIZE_VERSION v0.6.1 # 检测其他服务的插件 RUN wget https://github.com/jwilder/dockerize/releases/download/$DOCKERIZE_VERSION/dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \\ && tar -C /usr/local/bin -xzvf dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \\ && rm dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz RUN mkdir /app COPY myshop-service-user-provider-$APP_VERSION.jar /app/app.jar ENTRYPOINT [\"dockerize\", \"-timeout\", \"5m\", \"-wait\", \"tcp://192.168.10.131:3306\", \"java\", \"-Djava.security.egd=file:/dev/./urandom\", \"-jar\", \"/app/app.jar\"] EXPOSE 8501 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 09:42:09 "},"Shell/":{"url":"Shell/","title":"Shell","keywords":"","body":"Shell 定时任务crontab 命令行分屏screen tldr命令手册 root权限用户 测试连接远程主机端口 ssh -v -p 80 username@10.0.250.3 -v 调试模式(会打印日志). -p 指定端口 username 可以随意 失败: ssh: connect to host 10.0.250.3 port 80: Connection refused 成功: debug: Connection established. omyzsh 安装 安装zsh apt install zsh 安装git apt install zsh 安装ohmyzsh sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" 配置主题 vi ~/.zshrc 修改 ZSH_THEME=\"agnoster\" # 这是最花哨的一个 java 环境变量配置 编辑profile文件 vi /etc/profile 添加环境变量 JAVA_HOME=/opt/jdk1.8.0_152 #jdk存放位置 JRE_HOME=/opt/jdk1.8.0_152/jre #jre存放位置 PATH=$PATH:$JRE_HOME/bin:$JAVA_HOME/bin export JAVA_HOME export JRE_HOME export PATH 编译profile文件 source /etc/profile 测试一下 java -version Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 18:15:44 "},"Shell/screen.html":{"url":"Shell/screen.html","title":"screen分屏命令","keywords":"","body":"screen 安装 screen，使用命令 apt-get install screen 即可完成。 screen 常用快捷键如下： Ctrl+a 再按shift + s 水平分割当前窗口 Ctrl+a | 垂直分割当前窗口 Ctrl+a c 创建一个新的运行 shell 的窗口并切换到该窗口 Ctrl+a X 关闭当前窗口 Ctrl+a x 锁定当前窗口 Ctrl+a k 杀死当前窗口 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-03-24 21:17:18 "},"Shell/crontab.html":{"url":"Shell/crontab.html","title":"crontab定时任务","keywords":"","body":"crontab 定时任务 1. 列出定时任务 crontal -l 可以使用这种方法在$HOME目录中对crontab文件做一备份: $ crontab -l > $HOME/mycron 2. 编辑crontab文件 crontab -e 3. 删除 crontab -r 使用实例 实例1：每1分钟执行一次myCommand * * * * * myCommand 实例2：每小时的第3和第15分钟执行 3,15 * * * * myCommand 实例3：在上午8点到11点的第3和第15分钟执行 3,15 8-11 * * * myCommand 实例4：每隔两天的上午8点到11点的第3和第15分钟执行 3,15 8-11 */2 * * myCommand 实例5：每周一上午8点到11点的第3和第15分钟执行 3,15 8-11 * * 1 myCommand 实例6：每晚的21:30重启smb 30 21 * * * /etc/init.d/smb restart 实例7：每月1、10、22日的4 : 45重启smb 45 4 1,10,22 * * /etc/init.d/smb restart 实例8：每周六、周日的1 : 10重启smb 10 1 * * 6,0 /etc/init.d/smb restart 实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb 0,30 18-23 * * * /etc/init.d/smb restart 实例10：每星期六的晚上11 : 00 pm重启smb 0 23 * * 6 /etc/init.d/smb restart 实例11：每一小时重启smb * */1 * * * /etc/init.d/smb restart 实例12：晚上11点到早上7点之间，每隔一小时重启smb 0 23-7 * * * /etc/init.d/smb restart Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"Shell/tldr.html":{"url":"Shell/tldr.html","title":"tldr命令手册","keywords":"","body":"tldr 命令手册 https://tldr.sh/ 安装请参考此文档。 TLDR是社区努力通过实际示例来简化的命令手册页 例：tar命令的用法 $ tldr tar tar Archiving utility. Often combined with a compression method, such as gzip or bzip. More information: . - Create an archive from files: tar cf target.tar file1 file2 file3 - Create a gzipped archive: tar czf target.tar.gz file1 file2 file3 - Extract a (compressed) archive into the current directory: tar xf source.tar[.gz|.bz2|.xz] - Extract an archive into a target directory: tar xf source.tar -C directory - Create a compressed archive, using archive suffix to determine the compression program: tar caf target.tar.xz file1 file2 file3 - List the contents of a tar file: tar tvf source.tar - Extract files matching a pattern: tar xf source.tar --wildcards \"*.html\" Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-03-24 21:17:18 "},"Shell/root.html":{"url":"Shell/root.html","title":"root权限用户","keywords":"","body":"创建root权限用户 # 创建用户 adduser tomcat # 设置密码 passwd tomcat # 赋予root权限 vim /etc/sudoers # 文件下面添加如下内容 ----------- # User privilege specification root ALL=(ALL:ALL) ALL tomcat ALL=(ALL:ALL) ALL Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-03-24 21:17:18 "},"Shell/ufw.html":{"url":"Shell/ufw.html","title":"UFW 防护墙","keywords":"","body":"UFW 防火墙管理 教程: https://linuxize.com/post/how-to-setup-a-firewall-with-ufw-on-ubuntu-18-04/ 切记: UFW必须先配置把ssh端口配进去,再开启, 不然连不上服务器就没办法了 Install UFW sudo apt install ufw Check UFW Status sudo ufw status verbose 使用apt命令安装软件包时，它将在/etc/ufw/applications.d目录中添加应用程序配置文件。 该配置文件描述了服务并包含UFW设置。 开放端口 ufw allow 4422/tcp Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-03-28 15:44:19 "},"program/Java/":{"url":"program/Java/","title":"Java","keywords":"","body":"Java Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 17:51:35 "},"program/Java/GuavaCache.html":{"url":"program/Java/GuavaCache.html","title":"GuavaCache定时缓存","keywords":"","body":"Guava Cache Maven 依赖 com.google.guava guava 18.0 延时缓存 指定缓存条目的有效期5分钟, 缓存数量最多不超过1000个, 如果超出,缓存清除那些不经常使用的条目. import com.google.common.cache.Cache; import com.google.common.cache.CacheBuilder; ... public static Cache cache = CacheBuilder .newBuilder() .expireAfterWrite(5,TimeUnit.MINUTES) .maximumSize(1000).build(); // 插入 cache.put(key, value); // 获取 cache.getIfPresent(key); // 移除 cache.invalidate(key); ... Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 17:51:23 "},"program/Java/functioncode.html":{"url":"program/Java/functioncode.html","title":"函数式编程(未完成)","keywords":"","body":"函数式编程 函数式编程语言操纵代码片段就像操作数据一样容易。 虽然 Java 不是函数式语言，但 Java 8 Lambda 表达式和方法引用 (Method References) 允许你以函数式编程。 OO（object oriented，面向对象）是抽象数据，FP（functional programming，函数式编程）是抽象行为。 代码演示 interface Strategy { String approach(String msg); } class Unrelated { static String twice(String msg) { return msg + \" \" + msg; } } public class Fuctioncodetest { public static void main(String[] args) { Strategy[] strategies = { msg -> msg + \"Tom\", // Lambda Unrelated::twice // 方法应用 }; for (Strategy strategy : strategies) { String goodmorning = strategy.approach(\"Goodmorning \"); System.out.println(goodmorning); } } } Lambda表达式 Lambda 表达式产生函数，而不是类。 在 JVM（Java Virtual Machine，Java 虚拟机）上，一切都是一个类，因此在幕后执行各种操作使 Lambda 看起来像函数 —— 但作为程序员，你可以高兴地假装它们“只是函数”。 Lambda 语法尽可能少，这正是为了使 Lambda 易于编写和使用。 递归 接受 int 型参数并生成 int 的接口： // functional/IntCall.java interface IntCall { int call(int arg); } 整数 n 的阶乘将所有小于或等于 n 的正整数相乘。 阶乘函数是一个常见的递归示例： // functional/RecursiveFactorial.java public class RecursiveFactorial { static IntCall fact; public static void main(String[] args) { fact = n -> n == 0 ? 1 : n * fact.call(n - 1); for(int i = 0; i 方法引用 Java 8 方法引用没有历史包袱。方法引用组成：类名或对象名，后面跟 :: 然后跟方法名称。 Runnable接口 class Go { static void go() { System.out.println(\"Go::go()\"); } } new Thread(Go::go).start(); 未绑定的方法引用 未绑定的方法引用是指没有关联对象的普通（非静态）方法。 使用未绑定的引用之前，我们必须先提供对象： class Go { void go() { System.out.println(\"Go::go()\"); } } Go g_o = new Go(); new Thread(g_o::go).start(); 构造函数引用 class Dog { String name; int age = -1; // For \"unknown\" Dog() { name = \"stray\"; } Dog(String nm) { name = nm; } Dog(String nm, int yrs) { name = nm; age = yrs; } } interface MakeNoArgs { Dog make(); } interface Make1Arg { Dog make(String nm); } interface Make2Args { Dog make(String nm, int age); } public class Fuctioncodetest { public static void main(String[] args) { MakeNoArgs mna = Dog::new; Make1Arg m1a = Dog::new; Make2Args m2a = Dog::new; } } Dog 有三个构造函数，函数接口内的 make() 方法反映了构造函数参数列表（ make() 方法名称可以不同）。 注意我们如何对 [1]，[2] 和 [3] 中的每一个使用 Dog :: new。 这 3 个构造函数只有一个相同名称：:: new，但在每种情况下都赋值给不同的接口。编译器可以检测并知道从哪个构造函数引用。 编译器能识别并调用你的构造函数（ 在本例中为 make()）。 函数式接口 方法引用和 Lambda 表达式必须被赋值，同时编译器需要识别类型信息以确保类型正确。 假设你要传递 System.out :: println 到你正在编写的方法 ，你怎么知道传递给方法的参数的类型？ 为了解决这个问题，Java 8 引入了 java.util.function 包。它包含一组接口，这些接口是 Lambda 表达式和方法引用的目标类型。 每个接口只包含一个抽象方法，称为函数式方法。 在编写接口时，可以使用@FunctionalInterface注解强制执行此“函数式方法”模式： 下表描述了 java.util.function 中的目标类型（包括例外情况）： 特征 函数式方法名 示例 无参数； 无返回值 Runnable (java.lang) run() Runnable 无参数； 返回类型任意 Supplier get() getAs类型() Supplier BooleanSupplier IntSupplier LongSupplier DoubleSupplier 无参数； 返回类型任意 Callable (java.util.concurrent) call() Callable 1 参数； 无返回值 Consumer accept() Consumer IntConsumer LongConsumer DoubleConsumer 2 参数 Consumer BiConsumer accept() BiConsumer 2 参数 Consumer； 1 引用； 1 基本类型 Obj类型Consumer accept() ObjIntConsumer ObjLongConsumer ObjDoubleConsumer 1 参数； 返回类型不同 Function apply() To类型 和 类型To类型 applyAs类型() Function IntFunction LongFunction DoubleFunction ToIntFunctionToLongFunction`ToDoubleFunction IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction 1 参数； 返回类型相同 UnaryOperator apply() UnaryOperator IntUnaryOperator LongUnaryOperator DoubleUnaryOperator 2 参数类型相同； 返回类型相同 BinaryOperator apply() BinaryOperator IntBinaryOperator LongBinaryOperator DoubleBinaryOperator 2 参数类型相同; 返回整型 Comparator (java.util) compare() Comparator 2 参数； 返回布尔型 Predicate test() Predicate BiPredicate IntPredicate LongPredicate DoublePredicate 参数基本类型； 返回基本类型 类型To类型Function applyAs类型() IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction 2 参数类型不同 Bi操作 (不同方法名) BiFunction BiConsumer BiPredicate ToIntBiFunction ToLongBiFunction ToDoubleBiFunction 多参数函数式接口 java.util.functional 中的接口是有限的。比如有了 BiFunction，但它不能变化。 如果需要三参数函数的接口怎么办？ 其实这些接口非常简单，很容易查看 Java 库源代码并自行创建。代码示例： // functional/TriFunction.java @FunctionalInterface public interface TriFunction { R apply(T t, U u, V v); } 高阶函数 这个名字可能听起来令人生畏，但是：高阶函数（Higher-order Function）只是一个消费或产生函数的函数。 我们先来看看如何产生一个函数： // functional/ProduceFunction.java import java.util.function.*; interface FuncSS extends Function {} // [1] public class ProduceFunction { static FuncSS produce() { return s -> s.toLowerCase(); // [2] } public static void main(String[] args) { FuncSS f = produce(); System.out.println(f.apply(\"YELLING\")); } } 闭包 考虑一个更复杂的 Lambda，它使用函数作用域之外的变量。 返回该函数会发生什么？ 也就是说，当你调用函数时，它对那些 “外部 ”变量引用了什么? 如果语言不能自动解决这个问题，那将变得非常具有挑战性。 能够解决这个问题的语言被称为支持闭包，或者叫作在词法上限定范围( 也使用术语变量捕获 )。Java 8 提供了有限但合理的闭包支持，我们将用一些简单的例子来研究它。 函数组合 函数组合（Function Composition）意为“多个函数组合成新函数”。它通常是函数式编程的基本组成部分。在前面的 TransformFunction.java 类中，有一个使用 andThen() 的函数组合示例。一些 java.util.function 接口中包含支持函数组合的方法 7。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 13:47:02 "},"program/Java/flowcode.html":{"url":"program/Java/flowcode.html","title":"流式编程(未完成)","keywords":"","body":"流式编程 流创建 你可以通过 Stream.of() 很容易地将一组元素转化成为流 Stream.of(\"it\", \"is\", \"of\", \"yang\", \"b\").forEach(System.out::println); 除此之外，每个集合都可以通过调用 stream() 方法来产生一个流。 List worlds = Arrays.asList(\"it\", \"is\", \"of\", \"yang\", \"b\"); worlds.stream() .mapToInt(item -> item.length()) .forEach(System.out::println); 随机数流 控制流的大小和界限 Random random = new Random(24); random.ints(10,2,10).boxed().forEach(System.out::println); Random 类只能生成基本类型 int， long， double 的流,boxed() 流操作将会自动地把基本类型包装成为对应的装箱类型stream int 类型的范围 IntStream 类提供了 range() 方法用于生成整型序列的流。编写循环时，这个方法会更加便利： range(10, 20).sum(); 实用的repeat函数,产生的循环更加清晰, public static void repeat(int n, Runnable action) { range(0, n).forEach(i -> action.run()); } generate() public class Fuctioncodetest implements Supplier { Random rand = new Random(47); char[] letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray(); @Override public String get() { return \"\" + letters[rand.nextInt(letters.length)]; } public static void main(String[] args) { String word = Stream.generate(new Fuctioncodetest()).limit(30).collect(Collectors.joining()); System.out.println(word); } } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-22 11:16:09 "},"program/Java/hutool.html":{"url":"program/Java/hutool.html","title":"糊涂工具包","keywords":"","body":"糊涂工具包 文档网站: https://hutool.cn/docs Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-23 09:09:47 "},"Python/Python.html":{"url":"Python/Python.html","title":"Python","keywords":"","body":"Python 依赖管理requirement 生成当前项目的requirement.txt pip freeze > requirements.txt 安装requirements.txt依赖 pip install -r requirements.txt 虚拟环境 虚拟环境相当于一个容器，在这个容器中安装的任何软件包都不会影响整个环境 Python3 虚拟环境 环境安装: sudo apt-get install python3-venv 创建虚拟环境 python3 -m venv myvenv（名称随意） 激活虚拟环境 ./myvenv venv/bin/activate 退出虚拟环境 deactivate Python2 虚拟环境 安装 pip install virtualenv 创建虚拟环境 virtualenv [虚拟环境的名字] 创建环境的时候指定Python解释器 virtualenv -p C:\\Python36\\python.exe [virutalenv name] 进入环境 Linux 虚拟环境 source /path/bin/activate 退出 deactivate Python 国内镜像源使用 让PIP源使用国内镜像，提升下载速度和安装成功率。 对于Python开发用户来讲，PIP安装软件包是家常便饭。但国外的源下载速度实在太慢，浪费时间。而且经常出现下载后安装出错问题。所以把PIP安装源替换成国内镜像，可以大幅提升下载速度，还可以提高安装成功率。 国内源： 新版ubuntu要求使用https源，要注意。 清华：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学：http://pypi.hustunique.com/ 山东理工大学：http://pypi.sdutlinux.org/ 豆瓣：http://pypi.douban.com/simple/ 临时使用： 可以在使用pip的时候加参数-i https://pypi.tuna.tsinghua.edu.cn/simple 例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider，这样就会从清华这边的镜像去安装pyspider库。 永久修改，一劳永逸： Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹) 内容如下： [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host=mirrors.aliyun.com windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini。内容同上。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-12-19 10:20:36 "},"DesignPatterns/":{"url":"DesignPatterns/","title":"设计模式","keywords":"","body":"设计模式 学习资料 https://design-patterns.readthedocs.io/ 示例代码 https://github.com/yangb92/DesignPattern4J Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-22 15:37:08 "},"React/React.html":{"url":"React/React.html","title":"React","keywords":"","body":"React 核心概念 虚拟DOM (Virtual Document Object Model) 本质: 在框架的概念中,程序员使用js对象模拟浏览器上的DOM和DOM嵌套关系, 目的: 为了实现页面中DOM元素的高效更新 Diff 算法 (Different 差异算法) Tree Diff : 新旧两颗DOM树逐层对比. Domponent Diff: 在进行tree diff中,每一层中的组件对比, 如果类型不同进行更新 Element Diff: 在组件进行对比的时候,如果组件组件类型相同,则需要进行元素对比 总结 虚拟DOM用JS模拟页面的DOM, Diff算法负责向页面更新JS模拟的DOM 项目实践 环境安装 webpack 开发环境安装 参考资料 安装React组件 cnpm i react react-dom -S -S 代表该模块生产需要使用, -D代表开发使用 Hello React index.js 只需要三步 //1. 这两个包导入格式固定 import React from 'react' //创建组件, 虚拟DOM元素,生命周期 import ReactDOM from 'react-dom' // 把创建好的组件 和 虚拟DOM 放到页面展示 //2. 创建虚拟DOM /* 参数1: 创建元素的类型 [字符串] 元素的名称 参数2: 是一个对象或null, 表示这个DOM元素的属性. 参数3: 子节点 (包括其他虚拟DOM) 参数n: 其他子节点 例: Hello World! */ const myh1 = React.createElement('h1', {id:'myh1',title:'这是h1'},\"Helo World!\") //3. 使用ReactDOM 把虚拟DOM渲染到页面上 /* 参数1: 要渲染的那个虚拟DOM元素 参数2: 指定页面上的一个容器 DOM对象 */ ReactDOM.render(myh1,document.getElementById(\"app\")) index.html 中要存在一个id为app的容器 两个元素的嵌套 const myh1 = React.createElement('h1', {id:'myh1',title:'这是h1'},\"Helo World!\") // mydiv 嵌套 myh1 const mydiv = React.createElement('div',null,'这是一个div',myh1) 启用JSX语法 通过React.createElement方式创建虚拟DOM的方式过于麻烦, JSX是可以直接再JS中写HTML的语法 可以使用babel来将JSX语法转换成React.create Element的形式来执行. babel 插件安装 安装babel插件 cnpm i babel-core babel-loader babel-plugin-transform-runtime -D cnpm i babel-preset-env babel-preset-stage-0 -D 安装能够识别转换jsx语法的包 cnpm i babel-preset-react -D 添加至webpack的module webpack.config.js module: { //所有第三方模块的配置 rules: [ //匹配规则 {test: /\\.js|jsx$/, use: 'babel-loader', exclude: /node_modules/} ] } 在根目录添加.babelrc配置文件 { \"presets\": [\"env\",\"stage-0\",\"react\"], \"plugins\": [\"transform-runtime\"] } 语法注意事项 jsx 中注释使用{/*这是注释*/} 元素的class属性用className代替 label 的for 属性用 hemlFor 代替 数组的map迭代 {names.map(item => {item})} key放在迭代元素上面 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"React/components.html":{"url":"React/components.html","title":"组件","keywords":"","body":"React 组件 创建组件: 方式一 import React from 'react' //创建组件, 虚拟DOM元素,生命周期 import ReactDOM from 'react-dom' // 把创建好的组件 和 虚拟DOM 放到页面展示 /*************定义一个组件******************/ function Hello(props){ // props为组件接收的参数, 为只读属性 return 姓名: {props.name} 年龄: {props.age} 性别: {props.gender} } /********************************************/ ReactDOM.render( {/* 使用组件,传递props数据 */} , document.getElementById(\"app\")) TIP: 组件函数的首字母必须大写 展开运算符 ... 将对象属性展开传递给组件 const user = { name:'Yangb', age:27, gender:'Nan' } 将组件抽出到单独的文件 创建Hello.jsx src/ |--components/ |--Hello.jsx |--index.js |--index.html Hello.jsx import React from 'react' //定义一个组件 props为组件接收的参数, 为只读属性 export default function Hello(props){ return 姓名: {props.name} 年龄: {props.age} 性别: {props.gender} } 在index.js中导入使用Hello组件 import Hello from './components/Hello.jsx' //后缀名jsx不能省略 ... 配置省略 jsx 后缀名 如果看到导入import Hello from '@/components/Hello' ,定义了@为绝对路径 webpack.config.json 中配置 resolve: { extensions: ['.js','.jsx','.json'], //表示这几个后缀名可省略不写 alias: { '@': path.join(__dirname,'./src') //@ 表示src这个路径 } } 创建组件: 方式二 ES6 的 class 定义 // 定义一个动物类 // 注意1: 在class 内部只能写构造器,静态方法,静态属性 // 注意2: class关键字内部,还是用原来的配方,我们把class称为语法糖 class Animal{ // 构造器 constructor(name,age){ this.name = name this.age = age } // 在class内部通过static修饰的属性是静态属性 static info = 'xxx' //实例方法 -> 存在原型中 say(){ console.log(\"我是实例方法\") } //静态方法 -> 存在构造中 static show(){ console.log(\"我是静态方法\") } } 继承: this 只能在super()后面使用 class Person extends Animal{ constructor(name, age, hair){ super(name,age) this.hair = hair } } 使用Class创建一个组件 class Hello extends React.Component{ // 在render方法中返回虚拟jsx的dom, 传入参数可通过this.props获取 render(){ return 姓名: {this.props.name} } } 两种方式的对比 class Hello extends React.Component{ constructor(){ super() this.state = { //这里面的数据可自由修改 msg:'我是一个组件' } } render(){ this.state.msg += '!' //修改值 return 姓名: {this.state.msg} } } class 创建的组件有自己的私有数据和生命周期函数 用构造函数创建出的组件,叫做\"无状态组件\" class 关键字创建出来的组件叫做\"有状态组件\" 1.有状态组件和无状态组件的本质却别就是:有无state属性 2.无状态组件的运行效率更高 例子1: 用组件展示一个简单的评论列表 文件结构 |src ​ |components ​ |CmtItem.jsx ​ |CmtList.jsx ​ |index.js ​ |index.html CmtItem.jsx import React from 'react' // 一个无状态组件,接收参数返回一个评论的条目 export default function(props){ return 姓名: {props.user} 评论: {props.content} } CmtList.jsx import React from 'react' import CmtItem from '@/components/CmtItem' // 评论列表组件 初始化数据,传递给条目 export default class CmtList extends React.Component{ constructor(){ super() this.state = { CommentList:[ {id:1,user:'张三',content:'nice'}, {id:2,user:'李四',content:'good'}, {id:3,user:'王五',content:'excting'} ] } } render(){ return this.state.CommentList.map(Item => ) } } index.js //1. 这两个包导入格式固定 import React from 'react' //创建组件, 虚拟DOM元素,生命周期 import ReactDOM from 'react-dom' // 把创建好的组件 和 虚拟DOM 放到页面展示 import CmtList from '@/components/CmtList' ReactDOM.render( , document.getElementById(\"app\")) 样式 行内样式定义如下, 样式属性类型要按照json规范书写 定义样式的三种方法 方法一和方法二: /* 第一种封装方法 */ const itemStyle = {border:'1px dashed #ccc',margin:'10px',padding:'10px',boxShadow:'0 0 10px #ccc'} const userStyle = {fontSize:\"14px\"} const contentStyle = {fontSize:\"12px\"} /** 第二种封装方法 */ const styles = { itemStyle : {border:'1px dashed #ccc',margin:'10px',padding:'10px',boxShadow:'0 0 10px #ccc'}, userStyle : {fontSize:\"14px\"}, contentStyle : {fontSize:\"12px\"} } {/*使用第一种封装*/} 评论人: {props.user} {/*使用第二种封装*/} 评论内容: {props.content} 方法三: 导入css样式文件 安装插件npm i style-loader css-loader -D webpack.config.js 中配置插件, 为了避免css全局化互相影响,启用css-loader模块化 ... module: { //所有第三方模块的配置 rules: [ //匹配规则 ... //css 样式插件, css-loader的modules参数代表css样式模块化, 只在当前引入的模块起作用, 不添加此参数,样式会在全局中起作用 {test: /\\.css$/, use: ['style-loader', 'css-loader?modules']} ] } ... 编写css文件 .title { text-align:center; color:red; font-size:28px; font-weight:300; } 导入css文件 import cssobj from '@/components/cmt.css' //启用css模块化 评论列表 //如果没启用模块化,直接用css定义的class名称即可 评论列表 设置模块化后的类名称 css-loader添加参数 'css-loader?modules&localIdentName=[path][name]-[local]-[hash:5]' 设置类名是否被模块化 :global不会被模块化 :local 会被模块化, 默认 :global(.test){ italic } 在项目中启用模块化并同时使用bootstrap 把自己的样式表定义为.scss文件 第三方样式表以.css样式结尾 我们只需要为自己的.scss文件启用模块化即可. 操作步骤 安装插件 cnpm i sass-loader node-sass -D 配置插件,处理.scss文件,不处理.css文件 {test: /\\.scss$/,use:['style-loader','css-loader?modules&localIdentName=[path][name]-[local]-[hash:5]','sass-loader']} {test: /\\.css$/, use:['style-loader','css-loader']} 安装bootstrap npm i bootstrap@3.3.7 -S 导入 import 'bootstrap/dist/css/bootstrap.css' > > 如果出现.svg .ttf .woff .eot 字体无法处理, 添加一下插件 cnpm i url-loader file-loader -D 配置插件处理字体文件 {test: /\\.ttf|woff|woff2|eot|svg$/, use: ['url-loader']} React 的生命周期 生命周期函数 (或者钩子函数) React组件的生命周期分为三部分 一个定时器的例子 import React from 'react' export default class Lifecycle extends React.Component{ constructor(){ super() this.state = {date: new Date()} } /** * 组件挂载的时候初始化一个定时器 调用tick方法 */ componentDidMount(){ this.timerID = setInterval( () => this.tick(), 1000 ); } /** * 组件卸载的时候清除定时器 */ componentWillUnmount(){ clearInterval(this.timerID); } /** * 定时器中更新状态 */ tick(){ this.setState({ date: new Date() }) } render(){ return ( 北京时间: {this.state.date.toLocaleTimeString()} ) } } 条件渲染 function Greeting(props){ if(props.loginState){ return } return } function LoginButton(props){ if(props.loginState){ return 退出 } return 登陆 } FORM表单 import React from 'react' export default class Form extends React.Component{ constructor(){ super() this.state = {value: ''} } render(){ return( 名字: ) } handleSubmit = (event)=>{ alert('提交的名字:' + this.state.value) // 阻止事件的执行 event.preventDefault() } handleChange = (event) => { this.setState({value:event.target.value}) } } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"React/webpack.html":{"url":"React/webpack.html","title":"webpack","keywords":"","body":"Webpack 简单使用 基本的webpack项目 npm init -y 快速初始化项目目录 创建目录 dist/ src/ |--index.html |--index.js 执行cnpm i webpack webpack-cli -D 安装webpack工具. 在webpack.config.js中配置webpack module.exports = { mode:'development', // development, production 设置打包的格式,压缩格式和非压缩格式 } webpack 4.x 默认约定了 打包的入口是 src/index.js 打包的输出是 dist/main.js 运行 webpack 命令 在 index.html中引入打包好的../dist/main.js即可使用 webpack-dev-server 的基本使用 安装 cnpm i webpack-dev-server -D 提供默认的webpack.config.js 配置, 运行webpack-dev-server 日志中出现 i ｢wds｣: Project is running at http://localhost:8080/ i ｢wds｣: webpack output is served from / 代表 webpack 打包的文件输入托管路径在当前的/根路径下,访问http://localhost:8080/main.js 可以访问到打包好的main.js 但是由于webpack打包好的文件存在内存,在真实目录中并不能看得到. 但我们可以在文件中引用它. /main.js 即可 支持其他的命令 --open 自动打开浏览器 --port 3000 端口 --hot --progress --compress 传输压缩 --host 127.0.0.1 例如 \"scripts\": { \"dev\": \"webpack-dev-server --open --port 3000 --host 127.0.0.1 --progress --hot\" }, 现在有个问题,我们的首页在src中,需要能够从根目录访问.. html-webpack-plug的使用 在内存中自动生成index.html页面的插件 安装 cnpm i html-webpack-plugin -D 插件 插件的使用 在 webpack.config.js中加入插件 const path = require('path') const HtmlWebPackPlugin = require('html-webpack-plugin') //导入插件 const htmlPlugin = new HtmlWebPackPlugin({ template: path.join(__dirname,'./src/index.html'), //源文件 filename: 'index.html' //生成在内存中的名称 }) // 向外暴露打包的配置信息, webpack支持所有node api和语法 module.exports = { mode:'development', // development production plugins: [ htmlPlugin ] } 并且在 index.html中会自动引入main.js, 所以我们不需要再手动引入main.js了. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"React/event.html":{"url":"React/event.html","title":"事件","keywords":"","body":"React 事件 在React有一套自己的事件绑定机制, 事件名是驼峰规则. 示例: 箭头函数的好处是this 环境指的是当前class的环境.可以使用this获取当前class中的属性. 修改state的数据 在React中,想要为state中的数据重新赋值,不要使用 this.state.* = 值 应该调用 React提供的 this.setState({msg:123}) 在setState中,只会更新对应的值,而不会覆盖其他的值. this.setState的方法执行是异步的,在调用完setState之后要立即获取设置完的值,需要使用this.setState({},callable) 示例代码 import React from 'react' import 'bootstrap/dist/css/bootstrap.css' export default class BindEvent extends React.Component{ constructor(){ super() this.state = { msg: \"你好\" } } render(){ return {/* 在React有一套自己的事件绑定机制, 事件名是驼峰规则. */} this.show('哈哈')}> 按钮 {this.state.msg} } // 箭头函数的好处是this 环境指的是当前class的环境.可以使用this获取当前class中的属性. show = (args) => { // 在React中,想要为state中的数据重新赋值,不要使用 this.state.*** = 值 // 应该调用 React提供的 this.setState({msg:123}) // 在setState中,只会更新对应的值,而不会覆盖其他的值. // this.setState的方法执行是异步的,在调用完setState之后要立即获取设置完的值,需要使用this.setState({},callable) this.setState({ msg:\"你说: \"+args },() => { console.log(this.state.msg) }) } } 同步文本框的值 React 不支持双向绑定, 只支持将state传输到页面, 无法从页面自动绑定数据到state中, 不支持数据的逆向传输. 将属性绑定到文本框 value={this.state.xxx} 将文本框的值同步到属性: 第一步,手动监听文本框的onChange事件 第二部: 获取文本框的值 第三步: 调用setState方法同步最新的值 render(){ return {/* 在React有一套自己的事件绑定机制, 事件名是驼峰规则. */} this.show('哈哈')}> 按钮 {this.state.msg} {/* 第一步,手动监听文本框的onChange事件 */} this.changeTxt(e)} ref='txt' /> } changeTxt = (e) => { // 第二部: 获取文本框的值 //方式一: 通过参数 e 获取 console.log(e.target.value) //方式二: 通过refs属性获取 console.log(this.refs.txt.value) //第三步: 调用setState方法同步最新的值 this.setState({ msg: this.refs.txt.value }) } 绑定this并传参的几种方式 使用箭头函数 bing函数this.xx.bind(this) 传递当前this. 和call/apply的区别bind 只会修改指向不会调用, bind中的参数传递, 第一个参数是this this.method.bind(this,args1,...) 可以在构造函数中执行该方法或在事件中绑定 第三种: 使用箭头函数this的调用即可 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"Android/adb.html":{"url":"Android/adb.html","title":"操作系统","keywords":"","body":"ADB adb速查 https://www.wanandroid.com/blog/show/2310 最全ADB github: https://github.com/mzlogin/awesome-adb adb 常用命令 查看当前连接设备： adb devices 如果发现多个设备： adb -s 设备号 其他指令 查看日志： adb logcat 安装apk文件： adb install xxx.apk 此安装方式，如果已经存在，无法安装； 推荐使用覆盖安装： adb install -r xxx.apk 卸载App: adb uninstall com.zhy.app 1 如果想要保留数据，则： adb uninstall -k com.zhy.app 往手机SDCard传递文件： adb push 文件名 手机端SDCard路径 从手机端下载文件： adb pull /sdcard/xxx.txt 查看手机端安装的所有app包名: adb shell pm list packages 启动Activity: adb shell am start 包名/完整Activity路径 启动服务： adb shell am startservice \"com.zhy.aaa/com.zhy.aaa.MyService\" 屏幕截图： adb shell screencap /sdcard/screen.png 录制视频： adb shell screenrecord /sdcard/demo.mp4 清除APP数据： adb shell pm clear com.example.packagename 查看所有App的名称：该命令可以查看手机上的APP名称。可以在后面加上 -f ，这样还能显示该APP的路径。 即： adb shell pm list packages -f 使用adb shell input命令向屏幕输入一些信息， adb shell input text \"insert%stext%shere\" 注意：%s表示空格。 模拟屏幕点击事件 adb shell input tap 500 1450 1 表示在屏幕上（500，1450）的坐标点上进行一次点击。 模拟手势滑动事件，例如： adb shell input swipe 100 500 100 1450 100 用上面的命令还可以模拟”长按（long press）操作，也就是2个坐标点相同，耗时超过500ms. adb shell input swipe 100 500 100 500 500 模拟点按实体按钮的命令，例如： adb shell input keyevent 25 该命令表示调低音量。数字25是在AOSP源码中的KeyEvent类里定义的一个事件常量。该类定义了将近300个事件常量。 上面这个命令会启动浏览器打开谷歌网址页面。 adb shell am start -a \"android.intent.action.VIEW\" -d \"https://www.google.com\" am 也能发送广播和启动服务。比如启动一个广播，一般要添加一个-a： adb shell am broadcast -a \"our.specified.action\" 使用下面的命令可以直接让手机重启： adb shell am broadcast -a android.intent.action.BOOT_COMPILETED 启动一个服务也是类似，例如: adb shell am startservice \"com.example.crime/com.example.crime.MyService\" adb shell ps命令查看进程信息。可以在该命令后加包名，来查看某个应用程序的进程信息。 adb shell top 命令来查看系统CPU使用情况 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:10 "},"MCU/MicroControllerUnit.html":{"url":"MCU/MicroControllerUnit.html","title":"单片机","keywords":"","body":"单片机 MCU(Micro Controller Unit) 型号解释 STC 89C52 35I-PDIP40 1749HRX921.. STC：公司名称 89：89系列 C：CMOS 52：stc还有51，54，58，516后面的值*4k表示内存空间的大小。52的内存空间为8k。 35：表示单品机的工作频率 I：表示工业级（-40 - 125摄氏度）， C表示商业级（温度范围0-80）军品级别 PDIP：封装型号，包括单片机的形状和大小。 1749：代表生产时间，17年4月9日 80C51引脚封装 总线型 非总线型 总线分为三种：数据总线DB(Data Bus),地址总线AB(Adress Bus),控制总线CB(Control Bus) 单片机组成 CPU RAM ROM I/O T/C ：两个定时/计数器，既可以工作在定时模式，也可工作在计数模式。 C51 知识 很多硬件的开发都使用C语言编程，例如各种单片机，DSP，ARM等。 C51 数据类型 C-51基础数据类型 (有符号和无符号字节数 signed,unsigned) int(16) short(16) long(32) float(32) double(64) char(8) C51 数据类型扩充定义 sfr: 特殊功能寄存器申明 sfr16: sfr的16位数据申明 sbit: 特殊功能位声明 bit：位变量声明 C51 包含的头文件 常用头文件有 reg51.h reg52.h,定义特殊功能寄存器和位寄存器 math.h 定义常用数学运算 C51运算符 与C语言基本相同。 算数运算符 + - * / 布尔运算符： > >= \\ 逻辑运算符： && || ! 位运算: >> \\ & | 按位与或 ～ ^ 按位异或 取反 C51 基本语句 与C基本相同 if while for switch/case do-while 中断服务程序 I/O口定义 单片机要点掌握 最小系统能够运行起来的必要条件，1 电源 2 晶振 3 复位电路 对单片机任意I/O口的随意操作 输出控制的电频高低 输入检测电频高低 定时器 中断：外部中断，定时器中断，串口中断 串口通信：单片机之间，单片机与计算机间 单片机工作的基本时序 振荡周期: 也称时钟周期,指为单片机提供时钟脉冲信号振荡源的周期, TX实验板为11.0592MHZ 状态周期: 每个状态周期为时钟周期的两倍,是振荡周期经二分频后得到的. 机器周期: 一个机器周期包含6个状态周期,也就是12个时钟周期,在一个机器周期内,CPU可以完成一个独立的操作, 指令周期: 它指CPU完成一条操作所需的全部时间,每条指令执行时间都是有一个或几个机器周期组成 MCS-51系统中,有单周期指令,双周期指令和四周期指令. 80C51引脚封装 80C51/89C51 最大4k程序. 管脚: RST/Vpd: 复位/备用电源的输入端, P3.0/RXD, P3.1/TXD,P3.2/INTO ... P3.7/RD: 串口,程序下载命令,中断,定时器,计数器,外部数据存储器. XTAL2 XTAL1: 外部晶振输入端. ALE 中断 中断的概念: CPU 在处理某一事件A, 发生了另一事件B请求CPU迅速去处理(中断发生) CPU暂时中断当前的工作,转去处理事件B(中断响应和中断服务) 待CPU将事件B处理完毕后,再回到原来事件A被中断的地方继续处理事件A(中断返回),这一过程称为中断 中断的嵌套 在中断服务中再次发生中断 中断的优先级 中断源的响应优先级及中端服务入口程序表 中断源 中断标志 中断服务程序入口 优先级顺序 外部中断 0 (INT0) IE0 0003H 高 定时/计数器 0 (T0) TF0 000BH ⬇ 外部中断 1 (INT1) IE1 0013H ⬇ 定时/计数器 1(T1) TF1 001BH ⬇ 串行口 RI或T1 0023H 低 中断响应条件 中断源有中断请求 此中断源的中断允许位为1 CPU开中断 即 EA=1 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:10 "},"DB/db.html":{"url":"DB/db.html","title":"数据库","keywords":"","body":"数据库 PostgresSql 数据库 管理员登陆 su postgres psql \\l 查看数据库 Oracle 数据库表数据闪回 找回删除的数据或者表 闪回查询 查询过去某个时间段的数据库状态 select * from dept as of timestamp to_timestamp('2016-09-10 11:00:00','yyyy-mm-dd hh24:mi:ss'); 闪回表 启用表闪回首先要在表上支持行移动 闪回表操作 alter table dept enable row movement; flashback table dept to timestamp to_timestamp('2016-09-10 11:00:00','yyyy-mm-dd hh24:mi:ss'); 闪回表可能会失败，有可能有以下几种情况： 违反了数据库约束，比如用户不小心删除了子表中的数据，现在想利用闪回表技术进行回退，恰好在这中间，父表中与该数据对应的那条记录也被删除了，在这种情况下，由于违反了外键约束，导致闪回表操作失败了； 撤销数据失效，比如用于支撑闪回操作的撤销数据被覆盖了，这种情况闪回表操作自然会失败； 闪回不能跨越DDL，即在闪回点和当前点之间，表结构有过变更，这种情况闪回操作也会失败。 如果表和数据库被删除了，也可以闪回，请参考 https://www.cnblogs.com/chengxiao/p/5860823.html Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 18:15:44 "},"security/security.html":{"url":"security/security.html","title":"网络安全","keywords":"","body":"Security 网络安全 科学上网服务建设 使用V2Ray https://github.com/233boy/v2ray/wiki/V2Ray%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC v2ray url 可生成 vmess URL 链接 国外VPS服务器 https://bwh88.net/ 境外服务器不易受到监管 家用智能设备攻击思路 破解家用路由器或者控制一台肉鸡, 在内网扫描支持UPnP协议的只能设备, 使用UPnP利用工具miranda进行扫描和利用 UPnP 协议 UPnP为即插即用的缩写（Universal Plug and Play）是一套网络协议。适用于家庭网络，用于设备间的发现和连接。希望实现任何设备只要一接入网络就能被网络中的所有其它设备发现，做到完全的即插即用。 miranda Miranda是Kali提供的一款基于Python语言的UPNP客户端工具。它可以用来发现、查询和操作UPNP设备，尤其是网关设置。 pcap：被动发现设备通过嗅探设备接入网络时发送的NOTIFY消息获取设备信息。 msearch:通过主动发送M-serach消息来发现设备。（一般使用msearch比较快） 发现设备后可用host命令来查看详细信息。 host list：查看发现的设备列表 host get ：获取信息（查询summary之前需执行） host info ：显示查询到的信息 host summary 0 ：显示xml文件的摘要信息 （n为设备在列表中的编号） 获取设备列表 host info 0 deviceList 获取设备支持的命令/服务信息（命令很长使用Tab键补齐很方便 ） host info 0 deviceList WANConnectionDevice services WANIPConnection actions TCP 三次握手 SYN: synchronous 同步 ACK: acknowledgement 确认 client --SYN--> server server --ACK+SYN--> client client --ACK--> server Nmap 常用指令 主机发现: -sn Tcp ping扫描 -Pn 跳过主机发现 -PS/PA/PU/PY[portlist]: SYN/ACK/UDP/SCTP -n: 不做反向DNS查询 --dns-servers 8.8.8.8 : 指定dns服务器 -p-: 扫描所有端口 快速扫描主机的详细信息 nmap -sT -sV -Pn -v xxx.xxx.xxx.xxx 扫描所有的端口开放情况 nmap -sS -p 1-65535 -v 192.168.1.254 扫描网段主机(ping扫描) nmap -sn 192.168.16.100-150 深度扫描网络主机信息 nmap -A -T4 192.168.10.1 半开扫描(TCP SYN扫描) - 隐秘且速度快，比较常用 nmap -sS host Robots 扫描工具 parsero 扫描robots目录的地址 parsero -u url -o 只显示连接成功的 -sb 使用bing搜索引擎查找robots文件. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 18:14:01 "},"security/demo.html":{"url":"security/demo.html","title":"漏洞利用","keywords":"","body":"漏洞利用 CVE-2020-1938 文件包含漏洞 漏洞说明 该漏洞是由于Tomcat AJP协议存在缺陷而导致，攻击者利用该漏洞可通过构造特定参数，读取服务器webapp下的任意文件。若目标服务器同时存在文件上传功能，攻击者可进一步实现远程代码执行。目前，厂商已发布新版本完成漏洞修复。 受影响版本 Apache Tomcat 6 Apache Tomcat 7 Apache Tomcat 8 Apache Tomcat 9 不受影响版本 Apache Tomcat = 7.0.100 Apache Tomcat = 8.5.51 Apache Tomcat = 9.0.31 PoC github: https://github.com/yangb92/AJPy Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-03-24 21:17:18 "},"security/kali.html":{"url":"security/kali.html","title":"Kali","keywords":"","body":"Kali Linux 中文乱码问题 确定locales已经安装，用”apt-get install locales”命令；之后可用”locale -a”查看当前系统支持的字符集。 在命令行输入”dpkg-reconfigure locales”。进入图形化界面之后，（空格是选择，Tab是切换，*是选中），选中en_US.UTF-8和zh_CN.UTF-8，确定后，将en_US.UTF-8选为默认。 安装中文字体，”apt-get install xfonts-intl-chinese “和” apt-get install ttf-wqy-microhei”，这时发现网页不乱码，系统也不乱码。 重启 。 DDOS 洪水攻击 hping3 -c 1000 -d 120 -S -w 64 -p80 --flood --rand-source baidu.com -c: 发送包的数量 -d: 发送的每个数据包的大小,单位字节 -S: 只发送SYN数据包 -w: tcp窗口大小 -p: 目标端口 -flood: 尽可能快的发送数据包,不考虑显示入站回复 --rand-source: 随机性源头IP, 这里伪造的IP只是在局域网伪造,外网出口会还原 主动收集 netdiscover netdiscover 是一个主动/被动侦察工具. 可以扫描IP地址,检查在线主机或搜索为它们发送ARP请求 主动模式: 主动探测发现网络主机,但这种方式往往会引起网络管理员注意. netdiscover -i eth0 -r 192.168.1.0/24 被动模式: netdiscover -p scapy 启动 scapy ARP().display() # 查看ARP函数的用法 ###[ ARP ]### hwsrc: 源MAC地址 psrc: 源IP地址 hwdst: 目标MAC地址 pdst: 目的IP地址 sr1 函数发送请求sr1(ARP(pdst='192.168.1.1')) # 发送ARP请求 使用IP()和ICMP()生成ping包. 思路: 修改IP包头的dst(目的地址) 拼接ICMP的数据包类型 使用sr1进行发送数据包并接收数据包 sr1(IP(dst='192.168.1.1')/ICMP(),timeout=1) 构造TCP协议数据包 构造UDP协议数据包 僵尸扫描 nmap 扫描网络中的哪些机器可以被当成僵尸主机 被动收集 域名IP查询 dig (选项) 域名 @DNS服务地址: 指定域名进行解析 any: 显示所有类型域名记录.默认只显示A记录 dig yangb.xyz dig @114.114.114.114 yangb.xyz dig @114.114.114.114 yangb.xyz any -x ip:反查域名 子域名信息收集 使用搜索引擎: site:顶级域名 例如: site:qq.com Maltego 收集子域名(更加专业强大) 学习视频: http://www.shodan.io/ 超强搜索引擎, 可以搜索未经授权的站点, 包括网络摄像头. Kali 网络配置 实用Kali虚拟机需要开启桥接模式。 修改/etc/network/interfaces文件 dhcp 自动获取ip地址 auto eth0 iface eth0 dhcp 手动IP设置 auto eth0 iface eth0 inet static address 192.168.10.188 netmask 255.255.255.0 gateway 192.168.10.1 重启网络服务 /etc/init.d/networking restart 网络中图片嗅探 driftnet [options] [filter code] 主要参数： -b 捕获到新的图片时发出嘟嘟声 -i interface 选择监听接口 -f file 读取一个指定pcap数据包中的图片 -p 不让所监听的接口使用混杂模式 -a 后台模式：将捕获的图片保存到目录中（不会显示在屏幕上） -m number 指定保存图片数的数目 -d directory 指定保存图片的路径 -x prefix 指定保存图片的前缀名 使用举例： 1.实时监听： driftnet -i wlan0 2.读取一个指定pcap数据包中的图片： driftnet -f /home/linger/backup/ap.pcapng -a -d /root/drifnet/ Installing the Metasploit Framework on Linux curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb > msfinstall && chmod 755 msfinstall && ./msfinstall 如果安装失败 apt-get update 如果update出现key错误,先添加key apt-key adv --recv-keys --keyserver keyserver.ubuntu.com CDFB5FA52007B954 msfvenom 使用 https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom 查看能生成木马文件的格式类型,编码类型等等,都可以用-l参数来显示 msfvenom -l formats Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-07 10:26:14 "},"security/google.html":{"url":"security/google.html","title":"谷歌黑客语法","keywords":"","body":"谷歌黑客语法 site：可以限制你搜索范围的域名. inurl：用于搜索网页上包含的URL，这个语法对寻找网页上的搜索，帮助之类的很有用. intext: 只搜索网页部分中包含的文字(也就是忽略了标题、URL等的文字) intitle: 查包含关键词的页面，一般用于社工别人的webshell密码 filetype：搜索文件的后缀或者扩展名 intitle：限制你搜索的网页标题. link: 可以得到一个所有包含了某个指定URL的页面列表. 查找后台地址：site:域名 inurl:login|admin|manage|member|admin_login|login_admin|system|login|user|main|cms 查找文本内容：site:域名 intext:管理|后台|登陆|用户名|密码|验证码|系统|帐号|admin|login|sys|managetem|password|username 查找可注入点：site:域名 inurl:aspx|jsp|php|asp 查找上传漏洞：site:域名 inurl:file|load|editor|Files 找eweb编辑器：site:域名 inurl:ewebeditor|editor|uploadfile|eweb|edit 存在的数据库：site:域名 filetype:mdb|asp|# 查看脚本类型：site:域名 filetype:asp/aspx/php/jsp 迂回策略入侵：inurl:cms/data/templates/images/index/ Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-03-25 12:48:11 "},"Tool/":{"url":"Tool/","title":"工具插件","keywords":"","body":"工具插件 小技巧 b站看视频,右侧视屏选集栏显示完整名称 document.getElementById('multi_page').style=\"width:500px\" Chrome 插件 Infinity 标签页管理 安装方式 1. 谷歌市场搜索下载 2. 谷歌访问助手 免费访问: 谷歌搜索，Gmail邮箱，Chrome商店... 更好用的谷歌访问助手工具 pp访问助手 www.ppgoogle.net 沙拉查词 多个来源的网页翻译工具 Darkreader 网页暗色模式: https://darkreader.org/ Jetbrains系列产品 Jetbrains系列产品2019.2.3最新激活方法[持续更新] https://zhile.io/2018/08/25/jetbrains-license-server-crack.html?tdsourcetag=s_pctim_aiomsg 漂亮的 Markdown 编辑器 Typora https://www.typora.io/ Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-24 16:32:32 "},"Tool/PowerShell.html":{"url":"Tool/PowerShell.html","title":"PowerShell 美化主题","keywords":"","body":"PowerShell 美化 PowerShell 美化效果: 配置windows允许执行没有签名（远程）的Powershell脚本 在设置中面板中搜索PowerShell 找到开发人员设置,打勾这一项 下载Windows包管理工具 Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) 输入 choco -v验证是否安装成功 GIT choco install git 字体库 只需要安装字体库中 DejaVuSansMono 的字体就可以了. 字体下载好右键安装即可. powershell的git集成方案 posh-git Install-Module posh-git 基于posh-git的美化主题oh-my-posh Install-Module oh-my-posh 硬货在这里 刚刚前面做的全都是事前准备而已，这里才是真正影响Powershell主题的主要关键。直接复制到Powershell跑一下吧。 Install-Module -Name PSReadLine -Force -SkipPublisherCheck if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } @\" #requires -Version 2 -Modules posh-git function Write-Theme { param( [bool] `$lastCommandFailed, [string] `$with ) `$lastColor = `$sl.Colors.PromptBackgroundColor `$prompt = Write-Prompt -Object `$sl.PromptSymbols.StartSymbol -ForegroundColor `$sl.Colors.PromptForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor #check the last command state and indicate if failed If (`$lastCommandFailed) { `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.FailedCommandSymbol) \" -ForegroundColor `$sl.Colors.CommandFailedIconForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor } #check for elevated prompt If (Test-Administrator) { `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.ElevatedSymbol) \" -ForegroundColor `$sl.Colors.AdminIconForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor } `$user = [System.Environment]::UserName `$computer = [System.Environment]::MachineName `$path = Get-FullPath -dir `$pwd if (Test-NotDefaultUser(`$user)) { `$prompt += Write-Prompt -Object \"`$user@`$computer \" -ForegroundColor `$sl.Colors.SessionInfoForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor } if (Test-VirtualEnv) { `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.SegmentForwardSymbol) \" -ForegroundColor `$sl.Colors.SessionInfoBackgroundColor -BackgroundColor `$sl.Colors.VirtualEnvBackgroundColor `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.VirtualEnvSymbol) `$(Get-VirtualEnvName) \" -ForegroundColor `$sl.Colors.VirtualEnvForegroundColor -BackgroundColor `$sl.Colors.VirtualEnvBackgroundColor `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.SegmentForwardSymbol) \" -ForegroundColor `$sl.Colors.VirtualEnvBackgroundColor -BackgroundColor `$sl.Colors.PromptBackgroundColor } else { `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.SegmentForwardSymbol) \" -ForegroundColor `$sl.Colors.SessionInfoBackgroundColor -BackgroundColor `$sl.Colors.PromptBackgroundColor } # Writes the drive portion `$prompt += Write-Prompt -Object \"`$path \" -ForegroundColor `$sl.Colors.PromptForegroundColor -BackgroundColor `$sl.Colors.PromptBackgroundColor `$status = Get-VCSStatus if (`$status) { `$themeInfo = Get-VcsInfo -status (`$status) `$lastColor = `$themeInfo.BackgroundColor `$prompt += Write-Prompt -Object `$(`$sl.PromptSymbols.SegmentForwardSymbol) -ForegroundColor `$sl.Colors.PromptBackgroundColor -BackgroundColor `$lastColor `$prompt += Write-Prompt -Object \" `$(`$themeInfo.VcInfo) \" -BackgroundColor `$lastColor -ForegroundColor `$sl.Colors.GitForegroundColor } # Writes the postfix to the prompt `$prompt += Write-Prompt -Object `$sl.PromptSymbols.SegmentForwardSymbol -ForegroundColor `$lastColor `$timeStamp = Get-Date -UFormat %r `$timestamp = \"[`$timeStamp]\" `$prompt += Set-CursorForRightBlockWrite -textLength (`$timestamp.Length + 1) `$prompt += Write-Prompt `$timeStamp -ForegroundColor `$sl.Colors.PromptForegroundColor `$prompt += Set-Newline if (`$with) { `$prompt += Write-Prompt -Object \"`$(`$with.ToUpper()) \" -BackgroundColor `$sl.Colors.WithBackgroundColor -ForegroundColor `$sl.Colors.WithForegroundColor } `$prompt += Write-Prompt -Object (`$sl.PromptSymbols.PromptIndicator) -ForegroundColor `$sl.Colors.PromptBackgroundColor `$prompt += ' ' `$prompt } `$sl = `$global:ThemeSettings #local settings `$sl.PromptSymbols.StartSymbol = '' `$sl.PromptSymbols.PromptIndicator = [char]::ConvertFromUtf32(0x276F) `$sl.PromptSymbols.SegmentForwardSymbol = [char]::ConvertFromUtf32(0xE0B0) `$sl.Colors.PromptForegroundColor = [ConsoleColor]::White `$sl.Colors.PromptSymbolColor = [ConsoleColor]::White `$sl.Colors.PromptHighlightColor = [ConsoleColor]::DarkBlue `$sl.Colors.GitForegroundColor = [ConsoleColor]::Black `$sl.Colors.WithForegroundColor = [ConsoleColor]::DarkRed `$sl.Colors.WithBackgroundColor = [ConsoleColor]::Magenta `$sl.Colors.VirtualEnvBackgroundColor = [System.ConsoleColor]::Red `$sl.Colors.VirtualEnvForegroundColor = [System.ConsoleColor]::White \"@>$env:userprofile\"\\Documents\\WindowsPowerShell\\Modules\\oh-my-posh\\2.0.230\\Themes\\Paradox.psm1\" @\" chcp 65001 Set-PSReadlineOption -EditMode Emacs function which(`$name) { Get-Command `$name | Select-Object Definition } function rmrf(`$item) { Remove-Item `$item -Recurse -Force } function mkfile(`$file) { \"\" | Out-File `$file -Encoding ASCII } Import-Module posh-git Import-Module oh-my-posh Set-Theme Paradox \"@ > $PROFILE chcp 65001 Set-PSReadlineOption -EditMode Emacs Import-Module posh-git Import-Module oh-my-posh Set-Theme Paradox 设置powershell字体,选择安装的powerline字体. 其他主题参考 主题页面 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-31 10:48:01 "},"Tool/hexo.html":{"url":"Tool/hexo.html","title":"Hexo 博客框架","keywords":"","body":"Hexo 博客搭建 博客的基础搭建请参考: 官方文档 推荐主题 主题: https://github.com/jerryc127/hexo-theme-butterfly 主题预览: https://jerryc.me/ 主题安装文档:https://jerryc.me/posts/21cfbf15 博客扩展设置: https://jerryc.me/posts/31391d01 为博客添加宠物 详细资料: https://github.com/EYHN/hexo-helper-live2d 宠物包: https://github.com/xiazeyu/live2d-widget-models npm install --save hexo-helper-live2d 在站點配置文件或者主題配置文件添加以下内容 live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-wanko # 宠物的模型 display: position: right width: 150 height: 300 mobile: show: true 安裝需要的寵物文件: npm install {packagename} Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-11-07 15:10:18 "},"Tool/chromeExp.html":{"url":"Tool/chromeExp.html","title":"Chrome 插件开发","keywords":"","body":"Chrome 编辑页面 document.body.contentEditable = \"true\" 插件开发 mainfest.json { \"name\": \"WSBS\", \"description\": \"网上办事大厅扩展功能\", \"version\": \"1.0\", \"manifest_version\": 2, \"browser_action\": { \"default_popup\": \"main.html\", \"default_icon\": \"main.png\" }, \"permissions\": [ \"tabs\" ] } main.html body { width: 250px; text-align: center; } #build { width: 100%; background-color: brown; color: lightyellow; border: none; height: 30px; } 甘肃人力资源网上办事大厅 说明: 生成当前页面的授权地址, 实现信任传递. 生成授权地址 main.js document.getElementById('build').onclick = function(e){ chrome.tabs.getSelected(null,function(tab) { var pre_url = 'http://www.gszwfw.gov.cn/api/sso/loginTrust?backUrl=http://www.rst.gansu.gov.cn:8080/auth/sso/trust/common/' url = tab.url.match(/(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/).pop() document.getElementById('result').textContent = pre_url + window.btoa(url); }); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 14:13:59 "},"git/git.html":{"url":"git/git.html","title":"git","keywords":"","body":"Git 覆盖分支 把本地的devlop分支强制(-f)推送到远程mastergit push origin devlop:master -f 用devlop覆盖当前分支git reset –hard develop git push origin master –f Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 18:15:44 "},"git/gituse.html":{"url":"git/gituse.html","title":"在项目开发中使用git","keywords":"","body":"项目开发中使用Git 项目开发中如何使用git? 开发人员只需要在dev分支进行代码更新和提交就能满足日常工作需要. 拉取项目 复制项目的地址 2.创建一个文件夹,右键菜单中打开Git Bash命令行,如果没有安装Git,先安装Git工具. git clone git@192.168.10.45:zjapl/gov-gsrs.git 3.进入项目目录 gov-gsrs 进行开发 切换到开发分支 git checkout dev 更新代码 git pull origin dev 提交代码 git push origin dev Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-29 15:47:11 "},"Tool/gitbook.html":{"url":"Tool/gitbook.html","title":"Gitbook 电子书","keywords":"","body":"将GitBook文档托管到Github 将打包的文档发布至公共 gitpage 在 github|gitee 创建一个仓库 创建gitbook文档, 使用 gitbook build打包 安装推送插件cnpm install -g gh-pages 将文档发布到github|gitee gh-pages -d _book 开启仓库的gitpage, 选择gh-pages分支. 本文档使用插件 { \"title\":\"学习笔记\", \"author\":\"杨斌\", \"language\" : \"zh-hans\", \"plugins\": [ \"-search\", \"back-to-top-button\", \"chapter-fold\", \"sharing\", \"donate\", \"search-pro\", \"insert-logo\", \"theme-default\", \"theme-comscore\", \"code\", \"splitter\", \"tbfed-pagefooter\", \"github\", \"hide-element\", \"katex\" ], \"pluginsConfig\": { \"donate\": { \"wechat\": \"https://gitee.com/yangb92/book/raw/gh-pages/git/wxpay.png\", \"alipay\": \"https://gitee.com/yangb92/book/raw/gh-pages/git/alipay.png\", \"title\": \"\", \"button\": \"赏\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\" }, \"insert-logo\": { \"url\": \"https://gitee.com/yangb92/book/raw/gh-pages/favorite.png\", \"style\": \"background: none; max-height: 80px; min-height: 10px\" }, \"theme-default\": { \"showLevel\": true }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy yangb \", \"modify_label\": \"该文章修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"github\":{ \"url\":\"https://github.com/yangb92\" }, \"hide-element\":{ \"elements\": [\".gitbook-link\"] } } } 数学符号使用 行内公式:\\$\\$ x_0 \\$\\$ 公式块: \\$\\$ x_0 = y_2 \\$\\$ 在线符号编辑器 http://latex.codecogs.com/eqneditor/editor.php 公示参考文档: https://blog.csdn.net/weixin_43159148/article/details/88621318 https://blog.csdn.net/weixin_43159148/article/details/88623751 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 18:15:44 "},"Nginx/Nginx.html":{"url":"Nginx/Nginx.html","title":"Nginx","keywords":"","body":"Nginx Nginx 的主从热备 场景: Nginx代理主服务器对外提供服务, 主服务器失去连接后 Nginx 代理转向从服务器为外界提供服务. 当主服务器恢复时, 自动切换至主服务器继续为外界提供服务. Nginx 配置: http { upstream backend { server localhost:9090; server localhost:9999 backup; } server { listen 80; location / { proxy_pass http://backend; } } } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-12-10 16:31:23 "},"Netty/Netty.html":{"url":"Netty/Netty.html","title":"Netty","keywords":"","body":"Netty 问题 我们经常使用应用程序和库来相互通信，例如，浏览器和Web服务器之间的通信。但是通用协议有时不能很好的扩展，比如我们不用Http服务器传输大文件，电子邮件和近时时消息(比如股票信息和游戏数据) 解决方案 Netty 项目致力于提供一个异步事件驱动的网络应用框架，快速开发可维护的高性能，高可扩展性协议的服务器和客户端工具。 换句话说，Netty 是一个NIO 客户端服务器框架，可以快速轻松的开发服务器和客户端之间通信协议的网络应用程序。 “快速而简单” 并不意味着最终的应用程序会受到可维护性或性能问题的影响。Netty 经过精心设计，从实现FTP，SMTP，HTTP 等协议中学到了很多经验 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"Docker/Docker.html":{"url":"Docker/Docker.html","title":"Docker","keywords":"","body":"Docker Docker 文档: https://www.funtl.com/zh/docs-docker/ 基本概念 Docker 包括三个基本概念 镜像（Image） Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 分层存储:镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。 容器（Container） 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。 按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。 仓库（Repository） 公有仓库 私有仓库 标题 说明 镜像(Images) Docker 镜像是用于创建 Docker 容器的模板。 容器(Container) 容器是独立运行的一个或一组应用。 客户端(Client) Docker 客户端通过命令行或者其他工具使用 Docker API (https://docs.docker.com/reference/api/docker_remote_api) 与 Docker 的守护进程通信。 主机(Host) 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。 仓库(Registry) Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。 Docker Machine Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。 Docker安装 Ubuntu 安装 脚本自动安装: curl -fsSL get.docker.com -o get-docker.sh sh get-docker.sh --mirror Aliyun 检测Docker是否安装成功 docker version 配置阿里云Docker镜像加速器 下载镜像 docker pull 镜像名称 启动镜像 docker run -p 80:8080 tomcat Docker 仓库 公共仓库: https://hub.docker.com Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-13 13:47:32 "},"maven/maven.html":{"url":"maven/maven.html","title":"maven","keywords":"","body":"Maven maven 本地仓库导入jar包 mvn install:install-file -Dfile=C:\\Users\\DELL\\Documents\\mybash\\uids-sm-1.0.jar -DgroupId=com.zdww -DartifactId=uids-sm -Dversion=1.0 -Dpackaging=jar 注意: 此脚本在powershell中执行会出现错误, 请使用git_bash或其他支持shell的终端执行 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-01-02 15:43:21 "},"股票/股票趋势技术分析.html":{"url":"股票/股票趋势技术分析.html","title":"股票","keywords":"","body":"股票趋势技术分析 股票分析的两种流派: 基本统计分析: 依靠各种统计数据, 检查审计报表,损益报告,资产负债表等指标数据对股票进行评估, 如果其当前售价低于其评定价值, 则认为可以购买 技术分析: 指对市场本身行为研究而非对市场交易商品的研究. 通过股票的走势推断出发展趋势. 道氏理论 技术分析派 查看详情 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-24 10:41:38 "},"股票/道氏理论.html":{"url":"股票/道氏理论.html","title":"道氏理论","keywords":"","body":"道氏理论 要点: 三种趋势 长期趋势: 中期趋势 短期趋势 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-24 09:53:00 "},"高等数学/":{"url":"高等数学/","title":"高等数学","keywords":"","body":"数学 高等数学 函数与极限 离散数学 集合 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 18:15:44 "},"高等数学/函数与极限.html":{"url":"高等数学/函数与极限.html","title":"函数与极限","keywords":"","body":"函数与极限 1.1 集合 1.1.1 集合 概念 具有某种属性的事物的全体称为集合. a(元素) A(集合) a是A的元素 a∈A; a不是A的元素 a∉A 表示 表示法 列举 说明属性 A={x|使x属于A的属性} 运算 并(和): A∪B(A+B); 交(积): A∩B(AB); 差: A∖B; 1.1.2 实数集 实数集 R: 有理数集(Q)+无理数集; 有理数集的特性 有序性 对加减乘除运算的封闭性(构成数域) 稠密性 通过长度: 有理数 -> 数轴上的点; 数轴上的点不都是有理数. >> √2 实数集多一个特性: 完备性(或连续性) 实数 .. 数轴上的点 (一一对应) 在极限运算下是封闭的 1.1.3 区间 有界区间 设: a 开区间: (a,b) = {x|a 闭区间: [a,b] = {x|a 半开闭区间: (a,b] = {x|a 无界区间 (-∞,b)={x|x (-∞,-∞)={x|x ∈ R};[a,+∞]={x|a 一般区间表示 I 邻域 若 a ∈ R, 𝞭 > 0, 则:U(a,𝞭) = (a-𝞭,a+𝞭); a的𝞭邻域. 去心邻域 \\overset{ \\circ}{ U } (a,\\delta) = (a-\\delta,a)U(a,a+\\delta) a的去心𝞭 领域(只考虑点a邻近的点，不考虑点a) 1.1.4 一些符号 用逻辑符号表达某些数学语言较简洁 符号 说明 ∉ 不属于 ∈ 属于 ∀ 任意的 ∃ 存在 => 蕴含,必要条件 源于,充分条件 等价 ≜ 定义为 max E E中最大的 min E E中最小的 1.1.5 不等式 A-G 不等式 Bernoulli不等式 1.1.6 实数集的界 上界 设E为非空实数集 ∃M ∈ R; ∀x ∈ E; x ≤ M ; 称M是E的一个上界. ∃N ∈ R; ∀x ∈ E; x ≥ N; 称N是E的一个下界. 上确界 最小上界 设E为非空实数集 (1) ∀x ∈ E; x ≤ y; (2) ∀z>0, ∃x ∈ E; x>y-z; 公理: 如果集合有上界必有上确界 1.2 函数 1.2.1 概念与表示 什么是函数? 简言之: 函数是数集间的对应关系. 设D是一个数集 ∀x∈D,x→y,y∈R\\forall x \\in D, x \\rightarrow y, y \\in R∀x∈D,x→y,y∈R; 记为 y=f(x),x∈Dy = f(x), x \\in Dy=f(x),x∈D; 或f:D→R f:D \\rightarrow Rf:D→R; f: 函数, x:自变量 D: 定义域 函数在D上 x0x_0x​0​​ 的对应的f(x0)f(x_0)f(x​0​​) 称为函数在x0x_0x​0​​的值.有时记为∫∣x0\\int \\mid{x_0}∫∣x​0​​ 自变量的字母可以改变 y=f(Δ),Δ∈X\r y = f(\\Delta ), \\Delta \\in X\r y=f(Δ),Δ∈X 函数的表示 (1)定义域 (2)对应关系 可以用解析式,也可以用图表等方式 解析式往往用分段表示 例: 飞机托运行李(千克)与价格(元)之间的关系 p{ 0; 0≤m≤20 7(m-20); 20m≤200\r p\\begin{cases}\r & \\text{ 0; } 0 \\leq m \\leq 20 \\\\ \r & \\text{ 7(m-20); } 20 p{​​​​​ 0; 0≤m≤20​ 7(m-20); 20m≤200​​ 例: Dirichlet 函数 D(x)={ 1 x⇔Irrationalnumber 0 x⇔Rationalnumber\r D(x)=\\begin{cases}\r & \\text{ 1 } x \\Leftrightarrow Irrational number \\\\ \r & \\text{ 0 } x \\Leftrightarrow Rational number\r \\end{cases}\r D(x)={​​​​​ 1 x⇔Irrationalnumber​ 0 x⇔Rationalnumber​​ 函数的奇偶性 如何确定函数的奇偶性 - 根据子函数的奇偶性判断 有界性 有界联系区间 如何叙述无解 函数的单调性 区别单调与严格单调 单调联系区间 周期性 周期不唯一,通常指最小正周期 若f(x)的周期为T,那么f(ax+b)的周期为T/a 周期函数一定有最小正周期吗? (不一定,Dirichlet函数) 函数的运算 加减乘除 f+g, f-g,fg,f/g 复合函数 例: y=2sin3x⇒y=2x,u=sinv,v=3x\r y = 2^{sin3x} \\Rightarrow y=2^x, u=sin v,v=3x\r y=2​sin3x​​⇒y=2​x​​,u=sinv,v=3x Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 18:15:44 "},"Concurrent/Overview.html":{"url":"Concurrent/Overview.html","title":"Java","keywords":"","body":"java.util.concurrent 概述 官方英文文档 Description 实体类经常用于并发编程，这个包中包含了一些小型标准化可扩展框架，以及一些实用的实现类,否则就单调乏味且难以实现。以下是主要组件的描述。 Executors Interfaces. Executor 是一个简单的标准化接口, 用于自定义线程，线程池，异步I/O 和 轻量级任务框架, 这些功能取决于使用Executor哪个实现类。任务可以在一个新的线程执行，现有任务的执行线程或线程调用执行,并且可以顺序执行或者并发执行。ExecutorService 提供了一个更完整的异步任务执行框架,它管理了任务的排队的和调度,并允许控制关闭，ScheduledExecutorService子接口和相关接口添加了对延迟和周期性任务执行的支持。ExecutorServices提供了安排异步执行任何表示为Callable的函数的方法，Runnable 作为结果的承载。Future返回函数的结果，确定执行是否已完成,并提供取消执行的方法,RunnableFuture是一个拥有run方法的Future，在执行时设置其结果。 Implementations. 类ThreadPoolExecutor和ScheduledThreadPoolExecutor提供可调节的灵活的线程池，Executors类为Executor的最常见种类和配置提供工厂方法,以及一些使用它们的实用方法。其他基于Executor的实用程序包括具体的类FutureTask，它提供了future的公共可扩展实现,以及ExecutorCompletionService，它帮助协调异步任务组的处理。 ForkJoinPool类提供了一个Executor，主要用于处理ForkJoinTask及其子类的实例,这些类采用了一种工作窃取调度程序，可以获得符合计算密集型并行处理中常常存在的限制的任务的高吞吐量。 Queues ConcurrentLinkedQueue类提供了一个高效的可伸缩的线程安全非阻塞FIFO(先进先出)队列,ConcurrentLinkedDeque类与之类似，但还支持Deque(双向队列)接口。 该报中提供了五个BlockingQueue 接口实现类,它定义了put和take的阻塞版本,LinkedBlockingQueue，ArrayBlockingQueue，SynchronousQueue，PriorityBlockingQueue和DelayQueue。 不同的类涵盖了生产者 - 消费者，消息传递，并行任务和相关并发设计的最常见使用上下文。 扩展接口TransferQueue和实现LinkedTransferQueue引入了同步传输方法(以及相关特性)，其中生产者可以选择性地阻塞等待其消费者。 BlockingDeque接口扩展了BlockingQueue，支持FIFO和LIFO(基于堆栈)操作。类LinkedBlockingDeque提供了一个实现 Synchronizers 提供了5个工具类用户常见的同步操作。 Semaphore /seməfɔː/是一种经典的并发工具。 CountDownLatch是一个非常简单但非常常见的实用程序，用于阻塞，直到给定数量的信号，事件或条件成立。 CyclicBarrier是一种可重置的多路同步点，在某些并行编程风格中很有用。 Phaser提供了更灵活的屏障形式，可用于控制多个线程之间的分阶段计算。 Exchanger允许两个线程在集合点交换对象，并且在多个管道设计中很有用。 Concurrent Collections 此软件包提供了专为在多线程上下文中使用而设计的Collection实现,ConcurrentHashMap, ConcurrentSkipListMap, ConcurrentSkipListSet, CopyOnWriteArrayList, and CopyOnWriteArraySet 当预期多个线程访问给定集合的时候，ConcurrenthashMap 通常比一个同步的HashMap(Hash表数据结构) 可取.并且ConcurrentSkipListMap通常优于同步的TreeMap(红黑树数据结构),当预期的读取和遍历次数远远超过列表的更新次数时，CopyOnWriteArrayList优于同步的ArrayList。 包中 Concurrent 前缀 表示与类似的 synchronized 类几个不同之处. For example java.util.Hashtable and Collections.synchronizedMap(new HashMap()) are synchronized. Concurrent collection 是线程安全的, 但不用单一的排斥锁管理. 在ConcurrentHashMap特定情况下,它可以安全地允许任意数量的并发读取以及可调数量的并发写入,当您需要阻止通过一个锁对集合的所有访问时,\"Synchronized\" 非常有用. 以可扩展性较差为代价,在多线程访问公共集合的情况下, 通常优选\"Concurrent\"版本,如果集合不共享,最好使用非同步集合, 大多数异步集合包括队列 java.uti l Iterator 和 Spliterators 提供了弱实现而快速遍历 他们可以与其他业务同时进行 他们永远不会抛出ConcurrentModificationException 它们可以保证在构造时只存在一次元素，并且可以（但不保证）反映构造后的任何修改。 Memory Consistency Properties Chapter 17 of the Java Language Specification defines the happens-before relation on memory operations such as reads and writes of shared variables Java语言规范第17章定义了内存操作上的happens-before关系，比如共享变量的读写 只有当写的操作发生在读的操作之前,一个线程写的结果才可能被另一个线程的读操作看到. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:10 "},"Concurrent/Executor.html":{"url":"Concurrent/Executor.html","title":"Executor 线程池","keywords":"","body":"多线程 Executor public interface Executor 该接口提供了一个方法, 执行Runnable对象的任务。 提供了一种可以将任务本身和任务的运行机制(包括线程使用, 调度等细节)分离开来的方法 通常使用执行器而不是显试的创建线程。 例如：你不是为每一个任务去创建线程 new Thread(new(RunnableTask())).start()你可以使用 Executor executor = anExecutor; executor.execute(new RunnableTask1()); executor.execute(new RunnableTask2()); ... 然而，Executor 接口并不严格要求执行是异步的，最简单的情况如下，执行程序可以立即在调用者的线程中运行提交的任务。 class DirectExecutor implements Executor { public void execute(Runnable r) { r.run(); } } ExecutorService public interface ExecutorService extends Executor 一个Executor，提供管理终止的方法和可以生成Future以跟踪一个或多个异步任务进度的方法。 ScheduledExecutorService public interface ScheduledExecutorService extends ExecutorService 一个ExecutorService扩展, 可以延迟或者定期执行任务.调度功能。 schedule方法创建具有各种延迟的任务，并返回可用于取消或检查执行的任务对象。scheduleAtFixedRate和scheduleWithFixedDelay方法创建并执行定期运行的任务，直到被取消。 使用Executor.executor(Runnable) 和 ExecutorService.submit() 方法提交任务，请求的延迟为0，允许零延迟或负延迟,并视为请求立即执行 。 Usage Example Here is a class with a method that sets up a ScheduledExecutorService to beep every ten seconds for an hour: import static java.util.concurrent.TimeUnit.*; class BeeperControl { private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1); public void beepForAnHour() { final Runnable beeper = new Runnable() { public void run() { System.out.println(\"beep\"); } }; final ScheduledFuture beeperHandle = scheduler.scheduleAtFixedRate(beeper, 10, 10, SECONDS); scheduler.schedule(new Runnable() { public void run() { beeperHandle.cancel(true); } }, 60 * 60, SECONDS); } } Executors 用于在此包中定义的Executor、ExecutorService、ScheduledExecutorService、ThreadFactory和Callable类的工厂和实用方法 Methods that create and return an ExecutorService set up with commonly useful configuration settings. Methods that create and return a ScheduledExecutorService set up with commonly useful configuration settings. Methods that create and return a \"wrapped\" ExecutorService, that disables reconfiguration by making implementation-specific methods inaccessible. Methods that create and return a ThreadFactory that sets newly created threads to a known state. Methods that create and return a Callable out of other closure-like forms, so they can be used in execution methods requiring Callable. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:10 "},"Concurrent/Queue.html":{"url":"Concurrent/Queue.html","title":"Queue 队列","keywords":"","body":"队列 BlockingQueue 一个队列，它还支持在检索元素时等待队列变为非空的操作，以及在存储元素时等待队列中的空间变为可用的操作。 它的方法有四种形式, 有不同的方式来处理不能立即返回但可能在以后某个时候返回: 一种抛出异常,第二种返回一个特殊值(null或false,取决于操作),第三种线程无限期阻塞当前线程，直到操作成功为止,第四种只有当超出了给定的最大时限内才会放弃 Throws exception Special value Blocks Times out Insert add(e) offer(e) put(e) offer(e, time, unit) Remove remove() poll() take() poll(time, unit) Examine element() peek() not applicable not applicable 默认的容量为 Integer.MAX_VALUE 队列比支持 null BlockingQueue实现是线程安全的 BlockingQueue本质上不支持任何“关闭”或“关闭”操作，以指示不再添加任何项。这些特性的需求和使用往往依赖于实现 ConcurrentLinkedQueue 基于链接节点的无界线程安全队列 FIFO(先进先出), 不允许使用空元素。 许多线程共享对公共集合的访问时，ConcurrentLinkedQueue是一个合适的选择. 迭代器是弱一致的,反映队列在迭代器创建时或创建后某个时点的状态的元素。它们不会抛出ConcurrentModificationException，并且可以与其他操作并发进行。自创建迭代器以来，队列中包含的元素将只返回一次。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:10 "},"Concurrent/Conllection.html":{"url":"Concurrent/Conllection.html","title":"数据结构","keywords":"","body":"多线程的数据结构 ConcurrentHashMap 一个支持异步检索和高预期并发更新的哈希表. 这个类和HashTable遵循相同的规范，并且包含了Hashtable每个方法相对应的版本。 每一个操作都是线程安全的，检索操作不需要锁定,而且锁定整张表组织其他的访问 检索操作通常不会阻塞, 因此可能与更新操作重叠。(同一个键的更新操作与获取操作具有happens-before关系) Iterators，Spliterators和Enumerations在迭代器/枚举的创建时或之后的某个时刻返回反映哈希表状态的元素。 它们不会抛出ConcurrentModificationException。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:10 "},"JVM/Memory_Consistency_Properties.html":{"url":"JVM/Memory_Consistency_Properties.html","title":"JVM","keywords":"","body":"Memory Consistency Properties Java语言规范第17章(Chapter 17 of the Java Language Specification)定义了内存操作上的happens-before关系，比如共享变量的读写 如果A动作发生在B动作之前，可标记为 hb(A,B) 一个线程中的写操作与另一个线程中的读操作在数据竞争中可能出现顺序错误。happens-before关系定义了什么时候发生数据竞争。 在变量r 读取V的值时观察到w在写V的值,根据happens-before原则: r 没有排在w之前，即它不是hp(r,w) w 还没有写入 v r读取的时候允许看到w写的结果 在happens-before一致的操作集中，每次读取都会看到一个允许它看到的写入happens-before ordering For the trace in Table 17.5, initially A == B == 0. The trace can observe r2 == 0 and r1 == 0 and still be happens-before consistent, since there are execution orders that allow each read to see the appropriate write. Table 17.5. Behavior allowed by happens-before consistency, but not sequential consistency. Thread 1 Thread 2 B = 1; A = 2; r2 = A; r1 = B; Since there is no synchronization, each read can see either the write of the initial value or the write by the other thread. An execution order that displays this behavior is: 1: B = 1; 3: A = 2; 2: r2 = A; // sees initial write of 0 4: r1 = B; // sees initial write of 0 Another execution order that is happens-before consistent is: 1: r2 = A; // sees write of A = 2 3: r1 = B; // sees write of B = 1 2: B = 1; 4: A = 2; In this execution, the reads see writes that occur later in the execution order. This may seem counterintuitive, but is allowed by happens-before consistency. Allowing reads to see later writes can sometimes produce unacceptable behaviors. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:10 "},"Guava/":{"url":"Guava/","title":"Guava","keywords":"","body":"Guava Guava是一种基于开源的Java库，其中包含谷歌正在由他们很多项目使用的很多核心库。这个库是为了方便编码，并减少编码错误。这个库提供用于集合，缓存，支持原语，并发性，常见注解，字符串处理，I/O和验证的实用方法 缓存工具 Guava Cache Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-23 09:41:32 "},"Guava/Cache.html":{"url":"Guava/Cache.html","title":"Cache","keywords":"","body":"Guava Cache Maven 依赖 com.google.guava guava 18.0 例子 延时缓存 指定缓存条目的有效期5分钟, 缓存数量最多不超过1000个, 如果超出,缓存清除那些不经常使用的条目. import com.google.common.cache.Cache; import com.google.common.cache.CacheBuilder; ... public static Cache cache = CacheBuilder .newBuilder() .expireAfterWrite(5,TimeUnit.MINUTES) .maximumSize(1000).build(); // 插入 cache.put(key, value); // 获取 cache.getIfPresent(key); // 移除 cache.invalidate(key); ... Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-23 10:25:37 "},"SpringBoot/spring.html":{"url":"SpringBoot/spring.html","title":"Spring","keywords":"","body":"Spring @DependsOn 注解明确Bean之间依赖关系 @DependsOn({\"authorizationCodeServices\",\"authenticationManager\",\"tokenServices\"}) @Resource 资源要比@Autowride 优先加载 在SpringBoot @Configuration中注入要用@Resource,不然就会出现问题,需要手动指定依赖关系 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-09 17:31:00 "},"SpringBoot/SpringBoot.html":{"url":"SpringBoot/SpringBoot.html","title":"Spring Boot","keywords":"","body":"Spring Boot Spring Boot 轻松创建一个独立的,工业级的Spring 应用, 可以\"直接运行\". 我们对Spring 平台,和第三方依赖库有着自己的见解,因此你可以减少开始的麻烦,大多数SpringBoot程序只需要很少的配置. @EnableAutoConfiguration 这个注解告诉SpringBoot 根据项目中添加的依赖,\"猜测\"你希望如何配置Spring, main 方法 public static void main(String[] args) { SpringApplication.run(Example.class, args); } main 方法是Java程序的入口, Spring Boot 主程序执行SpringApplication的run方法启动程序, 启动Spring 等等操作, Example.class 参数是为了告诉SpringApplication 哪个是Spring的主模块, args参数是为了处理命令行的参数。 运行SpringBoot 项目 mvn spring-boot:run 创建可执行jar文件（又称 “胖jar”） 我们需要在 pom.xml 文件中 dependencies 片段后面添加spring-boot-maven-plugin org.springframework.boot spring-boot-maven-plugin 运行mvn package命令，打成jar包。 如果你想查看jar的内部，使用 jar tvf target/myproject-0.0.1-SNAPSHOT.jar 命令。 使用 java -jar 命令运行jar包。 您还应该看到一个名为myproject-0.0.1- snap .jar的小得多的文件。原始文件在目标目录中。这是Maven在Spring Boot重新打包之前创建的原始jar文件 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"SpringBoot/Using.html":{"url":"SpringBoot/Using.html","title":"Spring Boot 使用","keywords":"","body":"Spring Boot 的使用 项目结构 定位程序主类 默认推荐将启动类放在根目录中，高于其他的类。 @SpringBootApplication 注解放在主类上面，它还隐式的定义基础的所要扫描的包。 如果你不想用@SpringBootApplication， 可以使用@EnableAutoConfiguration 和 @ComponentScan 注解来定义这些。 典型的布局结构 com +- example +- myapplication +- Application.java | +- customer | +- Customer.java | +- CustomerController.java | +- CustomerService.java | +- CustomerRepository.java | +- order +- Order.java +- OrderController.java +- OrderService.java +- OrderRepository.java 配置类 Spring Boot 支持 java类配置和xml同事配置， 在配置类使用一个@Configuration， 通常定义 main 方法的主类很适合使用@Configuration。 导入其他配置类 你不需要将所有的@Configuration放入一个类中， @Import 注解能够用来加入配置类，或者，您可以使用@ComponentScan自动获取所有包括 @Configuration 类的Spring组件 导入XML配置 如果你必须要使用xml配置，我们建议您仍然从@Configuration类开始，你可以使用一个@ImportResource 注解加载xml配置文件。 自动配置 禁用特定的自动配置类 您可以使用@EnableAutoConfiguration的exclude属性禁用它们，如下面的示例所示: import org.springframework.boot.autoconfigure.*; import org.springframework.boot.autoconfigure.jdbc.*; import org.springframework.context.annotation.*; @Configuration @EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class}) public class MyConfiguration { } Spring Bean 和 依赖注入 您可以自由地使用任何标准Spring框架技术来定义bean及其注入的依赖项。为了简单起见，我们经常发现使用@ComponentScan(查找bean)和使用@Autowired(执行构造函数注入)工作得很好。 如果按照上面的建议构造代码(将应用程序类定位在根包中)，可以添加@ComponentScan，而不需要任何参数。所有应用程序组件(@Component、@Service、@Repository、@Controller等)都自动注册为Spring bean。 注意使用构造注入的bean 使用final 防止被更改。 使用@SpringBootApplication注解 使用一个@SpringBootApplication注释来启用这三个特性，即: @EnableAutoConfiguration: enable Spring Boot’s auto-configuration mechanism • @ComponentScan: enable @Component scan on the package where the application is located (see the best practices) • @Configuration: allow to register extra beans in the context or import additional configuration classes @SpringBootApplication还提供别名来定制@EnableAutoConfiguration和@ComponentScan的属性 这些特性都不是强制性的，您可以选择用它支持的任何特性替换这个注释。例如，你可能不想在你的应用程序中使用组件扫描: package com.example.myapplication; import org.springframework.boot.SpringApplication; import org.springframework.context.annotation.ComponentScan import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Import; @Configuration @EnableAutoConfiguration @Import({ MyConfig.class, MyAnotherConfig.class }) public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 开发工具 添加开发依赖 org.springframework.boot spring-boot-devtools true 开发依赖将在打包时关闭，并且用java -jar 运行时认为是生产环境，会自动关闭。 若要手动关闭，请设置Dspring.devtools.restart.enabled=false 属性 自动重启 类路径上的文件发生更改，将会自动重启，静态资源或模板发生更改，不会重启， 触发自动重启的唯一方法是更新类路径， Eclipse 自动更新， ide需要build 排除一些资源变动，不重启 spring.devtools.restart.exclude=static/,public/ 远程开发 需要添加插件 org.springframework.boot spring-boot-maven-plugin false 然后需要设置spring.devtools.remote.secret属性，如下面的示例所示: spring.devtools.remote.secret=mysecret 存在安全风险，不建议用在生产服务器上。 远程开发工具由两部分提供支持，接受连接的服务器端端点和在IDE中运行的客户机应用程序。当设置spring.devtools.remote.secret属性时，服务器组件将自动启用。客户端组件必须手动启动。 jar包部署至远程服务器 在服务器上运行jar包，address=5005 是调试端口 java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 demo-0.0.1-SNAPSHOT.jar IDE 上开启远程调试 只需要输入主机地址和调试端口即可热更新和调试，实现本地开发，远程运行，降低对开发电脑的资源占用。 运行远程客户端程序 远程客户端程序被设计运行在IDE，您需要运行org.springframework.boot.devtools.RemoteSpringApplication，其类路径与您连接到的远程项目相同，应用程序唯一需要的参数是它连接到的远程URL。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 10:17:58 "},"SpringBoot/SpringApplication.html":{"url":"SpringBoot/SpringApplication.html","title":"SpringApplication","keywords":"","body":"Spring Boot 特征 SpringApplication 启动特征 当启动失败时， 注册的 FailureAnalyzers 提供专用的错误消息和修复问题的具体操作。 Spring Boot提供了许多FailureAnalyzer实现，您可以添加自己的实现。 运行jar包启动 debug属性 $ java -jar myproject-0.0.1-SNAPSHOT.jar --debug 自定义 Banner 默认加载classpath下的banner.txt(或.gif.jpg.png),指定banner位置： spring.banner.location 属性 禁用Bannner显示,注意off的“”： spring: main: banner-mode: \"off\" 定制SpringApplication 如果你不喜欢SpringApplication的默认属性，你可以创建一个本地实例定制它，下面的示例关闭banner public static void main(String[] args) { SpringApplication app = new SpringApplication(MySpringConfiguration.class); app.setBannerMode(Banner.Mode.OFF); app.run(args); } 传递给SpringApplication的构造函数参数是Spring bean的配置源。在大多数情况下，这些是对@Configuration类的引用，但也可以是对XML配置或应该扫描的包的引用 也可以通过使用应用程序来配置spring应用程序属性文件。 链式调用API 如果你需要构建一个ApplicationContext可以使用SpringApplicationBuilder，允许您将多个方法调用链接在一起。如下所示 new SpringApplicationBuilder() .sources(Parent.class) .child(Application.class) .bannerMode(Banner.Mode.OFF) .run(args) 事件监听器 Note 有些事件实际上是在创建ApplicationContext之前触发的，因此您不能将侦听器注册为@Bean,您可以使用springapplication . addlistener(…)方法或springapplicationbuilder .listener(…)方法注册它们.如果希望自动注册这些侦听器,不管应用程序是如何创建的,你可以再你的程序中添加META-INF/spring.factories 文件，通过使用org.springframework.context.ApplicationListener作为KEY。例如： org.springframework.context.ApplicationListener=com.example.project.MyListener 当应用程序运行时，应用程序事件按以下顺序执行： ApplicationStartingEvent 最先执行, 除了注册监听器执行之外。 ApplicationEnvironmentPreparedEvent是在上下文环境Environment被创建之前 ApplicationPreparedEvent 在启动之前，但在Bean加载之后。 ApplicationStartedEvent在上下文创建之后，但在执行任何程序之前。 在调用任何应用程序和命令行运行程序之后，都会发送一个ApplicationReadyEvent。它表明应用程序已经准备好为请求提供服务。 如果启动时出现异常，则发送ApplicationFailedEvent. Web 环境 SpringApplication 尝试创建正确的ApplicationContext,用于确定WebApplicationType的算法非常简单 如果 SpringMVC存在，则使用AnnotationConfigServletWebServerApplicationContext。 如果Spring MVC不存在，而Spring WebFlux存在，则使用AnnotationConfigReactiveWebServerApplicationContext 其他情况下使用 AnnotationConfigApplicationContext 这意味着，如果您在同一个应用程序中使用Spring MVC和Spring WebFlux中的新WebClient，默认情况下将使用Spring MVC。您可以通过调用setWebApplicationType(WebApplicationType)轻松地覆盖它。 还可以通过调用setApplicationContextClass()来完全控制ApplicationContext类型。 在JUnit测试中使用SpringApplication时，通常需要调用setWebApplicationType(WebApplicationType.NONE)。 访问程序的参数 如果你需要访问传递个SpringApplication.run(...) 的参数，可以通过注入org.springframework.boot.ApplicationArguments实现，ApplicationArguments接口提供了参数String[]，和包含非包含的选项，例如： import org.springframework.boot.*; import org.springframework.beans.factory.annotation.*; import org.springframework.stereotype.*; @Component public class MyBean { @Autowired public MyBean(ApplicationArguments args) { boolean debug = args.containsOption(\"debug\"); List files = args.getNonOptionArgs(); // if run with \"--debug logfile.txt\" debug=true, files=[\"logfile.txt\"] } } Spring Boot还向Spring环境注册了一个CommandLinePropertySource。这还允许您通过使用@Value注释注入单个应用程序参数 使用ApplicationRunner 或 CommandLineRunner 如果你希望在SpringBoot程序启动时运行一些特定的代码，你可以实现接口ApplicationRunner or CommandLineRunner，这两个接口之提供一个run方法，SpringApplication.run(...)方法执行前调用。 CommandLineRunner接口以简单的字符串数组的形式提供对应用程序参数的访问，而ApplicationRunner使用前面讨论的ApplicationArguments接口。 import org.springframework.boot.*; import org.springframework.stereotype.*; @Component public class MyBean implements CommandLineRunner { public void run(String... args) { // Do something... } } 退出程序 每个SpringApplication都会向JVM注册一个关闭钩子，以确保ApplicationContext在退出时正常关闭。可以使用所有标准的Spring生命周期回调（例如DisposableBean接口或@PreDestroy注释）。 管理员特性 通过指定spring.application.admin.enabled属性，可以为应用程序启用与管理相关的功能。这会在平台MBeanServer上公开SpringApplicationAdminMXBean。您可以使用此功能远程管理Spring Boot应用程序。 此功能对于任何服务包装器实现也很有用。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"SpringBoot/ExternalizedConfiguration.html":{"url":"SpringBoot/ExternalizedConfiguration.html","title":"外部配置","keywords":"","body":"Spring Boot 特征 外部化配置 您可以使用properties文件、YAML文件、环境变量和命令行参数来具体化配置,属性值可以通过使用@Value注释直接注入到bean中, Spring的 Environment 抽象，或者通过@ConfigurationProperties绑定到结构化对象. Spring Boot使用一种非常特殊的PropertySource顺序，其设计目的是允许合理地覆盖值。属性按以下顺序考虑: 主目录上的Devtools全局设置属性(~/.spring-bootdevtools)。激活devtools时的属性)。 @TestPropertySource注释 测试下的properties属性. 用在@SpringBootTest等测试注解 命令行参数 来自SPRING_APPLICATION_JSON(嵌入到环境变量或系统属性中的内联JSON)的属性 ServletConfig 初始化参数 ServletContext初始化参数 太多了,不想写了(略) 获取属性值,如下所示 import org.springframework.stereotype.*; import org.springframework.beans.factory.annotation.*; public class MyBean { @Value(\"${name}\") private String name; // ... } 在程序的类路径,创建application.properties 文件,定义name的值.在新环境中,可以在jar包之外覆盖name的值,做一次性测试,例如: 运行指定的命令 java -jar app.jar --name=\"Spring\" Tip 在环境变量上指定SPRING_APPLICATION_JSON 属性,例如在unix中使用: $ SPRING_APPLICATION_JSON='{\"acme\":{\"name\":\"test\"}}' java -jar myapp.jar 您还可以将JSON作为spring.application提供。系统属性中的json，如下例所示: $ java -Dspring.application.json='{\"name\":\"test\"}' -jar myapp.jar 您还可以使用命令行参数提供JSON，如下面的示例所示: $ java -jar myapp.jar --spring.application.json='{\"name\":\"test\"}' 您还可以提供JSON作为JNDI变量，如下所示: java:comp/env/ spring.application.json。 配置随机数 例: my.secret=${random.value} my.number=${random.int} my.bignumber=${random.long} my.uuid=${random.uuid} my.number.less.than.ten=${random.int(10)} my.number.in.range=${random.int[1024,65536]} 访问命令行属性 命令行参数使用 -- 开始, 例如 --server.port=9000, 命令行参数将作为一个属性添加到环境中,如前所述，命令行属性始终优先于其他属性源。 如果你不想使用命令行属性源,关闭方法如下: SpringApplication.setAddCommandLineProperties(false). 属性文件 SpringApplication 从application.properties文件加载属性添加它们到环境中. 从如下几个地方进行加载: /config目录下 当前目录中 类路径的 /config 包 类路径的根目录下 列表按优先级排序,在列表中较高位置定义的属性覆盖在较低位置定义的属性. 你可以使用 .yml作为.properties的替代 自定义要加载的配置文件的名称使用spring.config.name 属性: $ java -jar myproject.jar --spring.config.name=myprojec 指定配置文件的位置: $ java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/ override.properties 警告: spring.config.name 和 spring.config.location 属性用来指定配置文件的名称和位置,所以它们必须被定义为环境属性,定义成系统环境变量,作为一个系统属性或者命令行参数 特殊的配置属性 profile 使用以下命名约定:application-{profile}.properties, 环境中有一个默认的profile ([default]),在没有设置profile的时候使用,换句话说,如果不指定 profile,则使用 application-default.properties. 特定属性和application.properties的加载位置相同, 特定属性的配置文件总是覆盖非特定的属性文件,不管特定于概要文件的文件是在打包的jar内部还是外部。 占位符属性 示例: app.name=MyApp app.description=${app.name} is a Spring Boot application 加密属性 Spring Boot不提供任何内置的对属性值加密的支持，但是它提供了修改Spring环境中包含的值所必需的挂钩点。Environment postprocessor接口允许您在应用程序启动之前操作Environment. 如果您正在寻找一种安全的方式来存储凭证和密码，Spring Cloud Vault项目提供了在HashiCorp Vault中存储外部化配置的支持。 使用YAML代替属性 YAML是JSON的一个超集，因此是指定分层配置数据的一种方便的格式。当您的类路径上有SnakeYAML库时，SpringApplication类自动支持YAML作为属性的替代。 如果您使用“starter”，SnakeYAML将由spring-boot-starter自动提供 加载YAML YAML 属性文档: environments: dev: url: https://dev.example.com name: Developer Setup prod: url: https://another.example.com name: My Cool App 转为properties如下 environments.dev.url=https://dev.example.com environments.dev.name=Developer Setup environments.prod.url=https://another.example.com environments.prod.name=My Cool App YAML 的数组 my: servers: - dev.example.com - another.example.com 对应的properties: my.servers[0]=dev.example.com my.servers[1]=another.example.co 使用@ConfigurationProperties 注解绑定到对应的实体类上面,如: @ConfigurationProperties(prefix=\"my\") public class Config { private List servers = new ArrayList(); public List getServers() { return this.servers; } } 在Spring环境中将YAML属性公开 可以使用@Value注释和占位符语法访问YAML属性 YAML 文档的多文件 您可以使用spring在一个文件中指定多个特定于概要文件的YAML文档。配置文件键，指示文档何时应用，如下例所示 server: address: 192.168.1.100 -- spring: profiles: development server: address: 127.0.0.1 -- spring: profiles: production & eu-central server: address: 192.168.1.120 在上面的例子中,如果prifiles 是 development,服务器的地址则是127.0.0.1 如果 production 和 eu-central profiles 是活跃的,则服务器地址是192.168.1.120,如果不活跃,地址则是192.168.1.100. 我们为spring.security.user设置了一个值。只有在“默认”配置文件中可用的密码: server: port: 8000 -- spring: profiles: default security: user: password: weak 然而，在下面的例子中，密码总是被设置，因为它没有附加到任何配置文件中，而且它必须在所有其他配置文件中根据需要显式重置: server: port: 8000 spring: security: user: password: weak YAML 缺点 无法使用@PropertySource注释加载YAML文件。因此，在需要以这种方式加载值的情况下，需要使用属性文件。 在特定于概要文件的YAML文件中使用多YAML文档语法可能导致意外行为。例如，在一个名为application-dev.yml的文件中考虑以下配置。dev配置文件处于活动状态 server: port: 8000 -- spring: profiles: !test security: user: password: weak 在上面的示例中，概要文件否定和概要文件表达式的行为与预期不同。我们建议您不要组合特定于概要文件的YAML文件和多个YAML文档，坚持只使用其中一个. 类型安全的属性配置 对于复杂的pojo获取属性,@Value(\"${property}\") 过于笨重. @ConfigurationProperties(\"acme\") public class AcmeProperties { private boolean enabled; private InetAddress remoteAddress; private final Security security = new Security(); 最后，只考虑标准Java Bean属性，不支持绑定静态属性. 您还需要列出要在@EnableConfigurationProperties注释中注册的属性类，如下面的示例所示: @ConfigurationProperties 验证 当使用了@Validate注释的时候, 在自动注入的时候都会进行验证.例如: @ConfigurationProperties(prefix=\"acme\") @Validated public class AcmeProperties { @NotNull private InetAddress remoteAddress; // ... getters and setters } @ConfigurationProperties 对比 @Value Feature @ConfigurationProperties @Value Relaxed binding Yes No Meta-data support Yes No SpEL evaluation No Yes Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"SpringBoot/Profiles.html":{"url":"SpringBoot/Profiles.html","title":"Profiles","keywords":"","body":"Profiles Spring概要文件提供了一种方法来隔离应用程序配置的各个部分，并使其仅在某些环境中可用。任何@Component或@Configuration都可以用@Profile标记， @Configuration @Profile(\"production\") public class ProductionConfiguration { // ... } 你可以使用spring.profiles.active Environment属性来指定活动的profiles,类如在application.properties中指定: spring.profiles.active=dev,hsqldb 也可以在命令行指定: --spring.profiles.active=dev,hsqldb 添加 Profiles 有时候,我们指定Profiles并不是为了替换掉配置文件,而是需要添加新的配置进来,我们需要: -- my.property: fromyamlfile -- spring.profiles: prod spring.profiles.include: - proddb - prodmq 通过代码添加Profiles文件 SpringApplication.setAdditionalProfiles(…) Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"SpringBoot/Logging.html":{"url":"SpringBoot/Logging.html","title":"日志Logging","keywords":"","body":"日志 SpringBoot 使用Logback记录日志,同时也支持其他的日志实现,如Log4j2 控制台输出 默认为 ERROR,WARN,INFO级别信息输出日志,也可以使用 --debug 标记开启debug模式. java -jar myapp.jar --debug 输入到文件 默认情况,SpringBoot只会将日志输出到控制台. 如果要打印到文件中, 需要设置logging.file 或者 logging.path属性. 日志级别 level 有 TRACE, DEBUG, INFO, WARN, ERROR, FATAL, or OFF. 下面的示例显示application.properties中的潜在日志设置 logging.level.root=WARN logging.level.org.springframework.web=DEBUG logging.level.org.hibernate=ERROR Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"SpringBoot/Internationalization.html":{"url":"SpringBoot/Internationalization.html","title":"国际化","keywords":"","body":"国际化 Spring Boot支持本地化消息，因此您的应用程序可以满足不同语言首选项的用户。默认情况下，Spring Boot在类路径的根目录中查找消息资源包的存在。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"SpringBoot/DevelopingWebApplication.html":{"url":"SpringBoot/DevelopingWebApplication.html","title":"Web应用开发","keywords":"","body":"Web应用程序开发 SpringBoot 非常适合开发Web程序开发,大多数web应用程序都使用springboot-starter-web模块快速开发,你也可以选择使用spring-boot-starter-webflux 模块构建响应式Web应用. Spring Web MVC Framework Spring Web MVC 框架(简称 Spring MVC) 是一个富\"model view controller\" 的web框架, Spring MVC 让你创建特定的@Controller 或 @RestController 的beans 来处理Http请求,控制器中的方法通过使用@RequestMapping注释映射到HTTP. 下面是一个典型的提供JSON数据的@RestController @RestController @RequestMapping(value=\"/users\") public class MyRestController { @RequestMapping(value=\"/\\{user}\", method=RequestMethod.GET) public User getUser(@PathVariable Long user) { // ... } @RequestMapping(value=\"/\\{user}/customers\", method=RequestMethod.GET) List getUserCustomers(@PathVariable Long user) { // ... } @RequestMapping(value=\"/\\{user}\", method=RequestMethod.DELETE) public User deleteUser(@PathVariable Long user) { // ... } } Spring MVC 自动配置 Spring Boot为Spring MVC提供了自动配置，可以很好地与大多数应用程序配合使用。 自动配置在Spring的默认值之上添加了以下特性: 包含ContentNegotiatingViewResolver 和BeanNameViewResolver 支持提供静态资源访问, 支持WebJars 自动注册 Converter, GenericConverter和Formatter 支持HttpMessageConverters 自动注册MessageCodesResolver 支持静态页 index.html 支持自定义图标 自动使用ConfigurableWebBindingInitializer 如果你想保留MVC特点并且添加MVC配置(拦截器,格式化,视图解析器和其他功能),你可以使用自己的@Configuration类定义WebMvcConfigurer,但是不包括 @EnableWebMvc 如果您想完全控制Spring MVC，您可以添加自己的@Configuration，并使用@EnableWebMvc进行注释。 Http消息转换器 将对象转为JSON或XML,默认使用UTF-8编码. 自定义转换器: import org.springframework.boot.autoconfigure.http.HttpMessageConverters; import org.springframework.context.annotation.*; import org.springframework.http.converter.*; @Configuration public class MyConfiguration { @Bean public HttpMessageConverters customConverters() { HttpMessageConverter additional = ... HttpMessageConverter another = ... return new HttpMessageConverters(additional, another); } } 自定义JSON序列号和反序列化器 import java.io.*; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import org.springframework.boot.jackson.*; @JsonComponent public class Example { public static class Serializer extends JsonSerializer { // ... } public static class Deserializer extends JsonDeserializer { // ... } } 静态资源 默认情况下,SpringBoot静态资源目录为ervletContext的根路径下的/static(或 /public 或 /resources 或 /META-INF/resources). 设置静态资源访问url: spring.mvc.static-path-pattern=/resources/* 设置静态资源位置: spring.resources.staticlocations 欢迎页 它首先在配置的静态内容位置中查找index.html文件,如果没有找到，则查找index模板,它被自动用作应用程序的欢迎页面。 自定义网站图标 SpringBoot从已配置的静态资源目录和根目录查找favicon.ico,如果存在,自动使用作为程序图标. 路径匹配和内容协议 SpringMVC将HTTP请求映射到方法上, SpringBoot默认禁用后缀,意味着\"GET /projects/spring-boot.json\" 不会匹配到 @GetMapping(\"/projects/ spring-boot\" 模板引擎 除了REST web服务，您还可以使用Spring MVC来提供动态HTML内容. SpringBoot支持的模板引擎有JSP,以及 • FreeMarker • Groovy • Thymeleaf • Mustache TIP 如果可能,尽量避免使用JSP 如果使用模板引擎,自动从src/main/resources/templates位置加载模板,您可以配置模板前缀来搜索类路径上的每个模板目录，如下所示:classpath*:/templates/ 错误处理 SpringBoot默认提供/error映射处理错误,注册一个全局的错误页面,对于机器客户机，它生成一个JSON响应，其中包含错误的详细信息,HTTP状态和异常消息,对于浏览器客户机，有一个“whitelabel”错误视图，它以HTML格式呈现相同的数据(若要自定义，请添加一个可解析为/error的视图),如果要完全替换默认的错误处理机制,可以实现一个ErrorController并注册,或者添加ErrorAttributes以实现现有机制. BasicErrorController可以用作自定义ErrorController的基类。如果您想为新的内容类型添加一个处理程序(默认情况下是专门处理文本/html，并为其他所有内容提供一个回退)，那么这尤其有用。为此，扩展BasicErrorController，添加一个带有@RequestMapping的公共方法，该方法具有produces属性，并创建一个新类型的bean。 自定义错误页面 404 页面文件位置 src/ +- main/ +- java/ | + +- resources/ +- public/ +- error/ | +- 404.html +- 所有5xx页面,错误页面模板 src/ +- main/ +- java/ | + +- resources/ +- templates/ +- error/ | +- 5xx.ftl +- Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"SpringBoot/Security.html":{"url":"SpringBoot/Security.html","title":"安全","keywords":"","body":"Security 安全 如果将Spring Security依赖加入, web应用默认保护,Spring Boot依赖于Spring Security的内容协商策略来决定是使用httpBasic还是formLogin。要向web应用程序添加方法级安全性，还可以使用所需的设置添加@EnableGlobalMethodSecurity。 默认得UserDetailsService 只有一个用户, 用户名user,密码随机打印到INFO级别的日志中,显示如下: Using generated security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35 自定义用户和密码: spring.security.user.name 或 spring.security.user.password DefaultAuthenticationEventPublisher 用于发布默认验证事件. 你也可以提供一个自定义的AuthenticationEventPublisher MVC Security 默认的安全配置在SecurityAutoConfiguration和UserDetailsServiceAutoConfiguration中实现。SecurityAutoConfiguration导入用于web安全的SpringBootWebSecurityConfiguration, UserDetailsServiceAutoConfiguration配置身份验证.也与非web应用程序相关.完全关闭默认的web应用程序安全配置,您可以添加WebSecurityConfigurerAdapter类型的bean(这样做不会禁用UserDetailsService配置或执行器的安全性) 详见SpringSecurity OAuth2.0 客户端 略 OAuth2.0 资源服务器 略 OAuth2.0 授权服务器 目前，Spring Security不支持实现OAuth 2.0授权服务器。然而，Spring Security OAuth项目提供了此功能，最终将被Spring Security完全取代。在此之前，您可以使用spring-security-oauth2autoconfigure模块轻松设置OAuth 2.0授权服务器;有关说明，请参阅其文档。 Actuator Security 为了安全目的,除了/health 和 /info 其他制动器默认是关闭的,management.endpoints.web.exposure。include属性可用于启用执行器 CSRF防护(Cross Site Request Forgery ) 于Spring Boot依赖于Spring Security的默认值，所以CSRF保护在默认情况下是打开的。这意味着，当使用默认安全配置时，执行器端点需要POST (shutdown和loggers端点)、PUT或DELETE将得到403禁止错误! 我们建议，只有在创建非浏览器客户端使用的服务时，才完全禁用CSRF保护 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"SpringBoot/DataSource.html":{"url":"SpringBoot/DataSource.html","title":"SQL数据库配置","keywords":"","body":"SQL数据库配置 传统上,“数据源”使用URL和一些凭据来建立数据库连接。 嵌入式数据库 使用内存内嵌入式数据库开发应用程序通常很方便,内存数据库不提供持久性存储,您需要在应用程序启动时填充数据库，并准备在应用程序结束时丢弃数据,Spring Boot可以自动配置嵌入式H2、HSQL和Derby数据库。您不需要提供任何连接url。只需要包含对要使用的嵌入式数据库的构建依赖项。 典型的POM依赖如下 org.springframework.boot spring-boot-starter-data-jpa org.hsqldb hsqldb runtime 要自动配置嵌入式数据库，需要依赖spring-jdbc。在本例中，它通过spring-boot-starter-data-jpa被临时拉入。 无论出于什么原因，如果您确实为嵌入式数据库配置了连接URL，请确保禁用了数据库的自动关闭。如果使用H2，则应该使用DB_CLOSE_ON_EXIT=FALSE。如果使用HSQLDB，应该确保没有使用shutdown=true。禁用数据库的自动关闭允许Spring在数据库关闭时启动控制，从而确保不再需要访问数据库时启动控制。 连接至生产数据库 连接池选择算法: 我们更喜欢HikariCP的性能和并发性。如果有HikariCP，我们总是选择它 否则，如果Tomcat池数据源可用，我们就使用它。 如果HikariCP和Tomcat池数据源都不可用，如果Commons DBCP2可用，我们就使用它。 如果您使用spring-boot-starter-jdbc或spring-boot-starter-data-jpa“starter”，您将自动获得对HikariCP的依赖。 您可以完全绕过该算法，并通过设置spring.datasource.type 指定要使用的连接池,如果在Tomcat容器中运行应用程序，这一点尤其重要，因为默认情况下提供了Tomcat -jdbc。 TIP 额外的连接池始终可以手动配置。如果定义了自己的数据源bean，则不会发生自动配置。 数据源配置由spring.datasource.*中的外部配置属性控制。例如，您可以在application.properties中声明以下部分: spring.datasource.url=jdbc:mysql://localhost/test spring.datasource.username=dbuser spring.datasource.password=dbpass spring.datasource.driver-class-name=com.mysql.jdbc.Driver 您至少应该通过设置spring.datasource.url属性。否则，Spring Boot将尝试自动配置嵌入式数据库 通常不需要指定驱动程序类名，因为Spring Boot可以从url推断出大多数数据库的驱动程序类名。 数据源创建的时候,需要确定数据库驱动是可用的,换句话说,如果你设置了spring.datasource.driver-class-name=com.mysql.jdbc.Driver,就要确保这个类是存在的. DataSourceProperties 提供了连接池的更多配置属性, 除了通用的属性,还可以使用它们各自的前缀微调特定于实现的设置(spring.datasource.hikari., spring.datasource.tomcat., and spring.datasource.dbcp2.*). 例如使用了Tomcat连接池,你需要这样定义: # Number of ms to wait before throwing an exception if no connection is available. spring.datasource.tomcat.max-wait=10000 # Maximum number of active connections that can be allocated from this pool at the same time. spring.datasource.tomcat.max-active=50 # Validate the connection before borrowing it from the pool. spring.datasource.tomcat.test-on-borrow=true 使用JdbcTemplate JdbcTemplate 和 NamedParameterJdbcTemplate 类是自动配置的,你可以使用 @Autowire 自动导入到你的项目中 您可以使用spring.jdbc.template.*自定义模板的一些属性，如下面的例子所示 spring.jdbc.template.max-rows=500 JPA 和 Spring Data JPA Java Persistence API 是一个允许将对象“映射”到关系数据库的标准技术。spring-boot-starter-data-jpa POM提供快速开始,它提供了关键的依赖如下 Hibernate Spring Data JPA:使基于jpa的存储库易于实现。 Spring ORMs: 来自Spring框架的核心ORM支持。 具体请参考Spring Data 或 Spring Data JPA 实体类 SpringBoot会扫描package中的实体类(用@EnableAutoConfiguration或@SpringBootApplication注释的)考虑使用@Entity、@Embeddable或@MappedSuperclass注释的任何类: package com.example.myapp.domain; import java.io.Serializable; import javax.persistence.*; @Entity public class City implements Serializable { @Id @GeneratedValue private Long id; @Column(nullable = false) private String name; @Column(nullable = false) private String state; // ... additional members, often include @OneToMany mappings protected City() { // no-args constructor required by JPA spec // this one is protected since it shouldn't be used directly } public City(String name, String state) { this.name = name; this.state = state; } public String getName() { return this.name; } public String getState() { return this.state; } // ... etc } 您可以使用@EntityScan注释自定义实体扫描位置 Spring Data JPA 仓库 Spring Data JPA存储库是您可以定义来访问数据的接口,JPA查询是根据您的方法名自动创建的,例如，CityRepository接口可能会声明一个findAllByState(String state) 方法来找出给定状态下的所有城市. 对于更复杂的查询，可以使用Spring Data的@Query注释对方法进行注释. Spring数据存储库通常从存储库或CrudRepository接口扩展,如果使用自动配置，则从包含主配置类的包中搜索存储库. 下面的示例显示了一个典型的Spring数据存储库接口定义 package com.example.myapp.domain; import org.springframework.data.domain.*; import org.springframework.data.repository.*; public interface CityRepository extends Repository { Page findAll(Pageable pageable); City findByNameAndStateAllIgnoringCase(String name, String state); } Spring Data JPA存储库支持三种不同的引导模式: 默认(default)延时加载(deferred) 懒加载(lazy),如果启动了延时加载和懒加载,设置 spring.data.jpa.repositories.bootstrapmode 为 deferred或lazy 详情请查看Spring Data JPA 创建和删除JAP 数据库. 默认情况下，JPA数据库只有在使用嵌入式数据库时才会自动创建 (H2, HSQL, or Derby). 您可以使用spring.jpa.*属性显式地配置JPA设置,例如，要创建和删除表，可以在application.properties中添加以下行: spring.jpa.hibernate.ddl-auto=create-drop 如果您正在运行一个web应用程序，Spring Boot默认注册OpenEntityManagerInViewInterceptor来应用“Open EntityManager in View”模式,以允许在web视图中延迟加载.果不希望出现这种行为，应该将application.properties中的spring. jsp .openin-view设置为false Spring Data JDBC Spring数据包含对JDBC的存储库支持，并将为CrudRepository上的方法自动生成SQL。对于更高级的查询，将提供@Query注释。 它们可以通过spring-bootstarter-data-jdbc的一个依赖项添加到您的项目中. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"SpringBoot/LinuxService.html":{"url":"SpringBoot/LinuxService.html","title":"Linux服务","keywords":"","body":"Linux 服务化部署 官方文档: https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/html/deployment.html#deployment-install 配置Maven插件 org.springframework.boot spring-boot-maven-plugin true 安装为init.d服务 假设你的SpringBoot程序部署在/var/myapp路径，要将SpringBoot程序作为init.d服务，需要创建一个软链接，如下: $ sudo ln -s /var/myapp/myapp.jar /etc/init.d/myapp 安装后，就可以按系统服务的方式启动和停止。例如，在基于debian的系统上，可以使用以下命令启动它: $ service myapp start 日志在/var/log/\\.log中可以查看. FQ spring boot 在Linux下服务启动报错Unable to find Java 将java 连接到/sbin 文件夹下 ln -s /usr/local/jdk/bin/java /sbin/java Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-01-14 10:20:11 "},"SpringSecurity/Security.html":{"url":"SpringSecurity/Security.html","title":"Spring Security","keywords":"","body":"Spring Security 基础概念 认证 会话 授权 授权的数据模型 主体 资源 权限 角色 角色和权限关系 主体和角色关系 通常企业开发中将资源和权限表合并为一张表. 数据模型如下: 用户 - 用户角色关系 -> 角色 - 角色权限关系 -> 权限 RBAC 业界的授权方案 基于角色的访问控制 Role-Base Access Control 基于资源的访问控制 Resource-Based Access Control 基于Session的认证方式 Spring Security WebSecurityConfig 用户信息 密码编码器 安全拦截机制 结构总览 解决用户的 安全访问控制, Spring Security 对web资源的保护是靠Filter实现的. SpringSecurityFilterChain 是一个 Servlet 过滤器 实现了 javax.servlet.Filter. 过滤外部请求. FilterChainProxy代理了多个Filter, 形成Filter链表. AuthenticationManager 负责授权, AccessDecisionManager 负责认证, 自定义UserDetailService @Service public class SpringDataUserDetailService implements UserDetailsService PasswordEncoder 使用BCryptPasswordEncoder加密 @Bean public PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } BCrypt 加密,每次加密结果都不一样,但是校验可以通过,增加了安全性 // 加密原始密码 String hashpw = BCrypt.hashpw(\"123\", BCrypt.gensalt()); System.out.println(hashpw); //校验密码一致性 boolean checkpw = BCrypt.checkpw(\"123\", \"$2a$10$e/Vgw1zKQDdyxd/DvyNSMeeT0TQhaDB9KbUoN8jC2f8MV9lGUobcy\"); System.out.println(checkpw); boolean checkpw1 = BCrypt.checkpw(\"123\", \"$2a$10$jIueZHE5S7WJjnZrD//HDugBxKsdLdYfuarmXC.R8S6rJqCv3ifEu\"); System.out.println(checkpw1); 安全拦截 @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/r/r1\").hasAuthority(\"p1\") .antMatchers(\"/r/r2\").hasAuthority(\"p2\") .antMatchers(\"/r\").authenticated() .anyRequest().permitAll() .and() .formLogin(); } 自定义登录页面 增加登录页面 @GetMapping(\"/login-view\") public String login(){ return \"login\"; } 自定义登录页面 login.html 用户名: 密码: 配置http安全设置 @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() ... .formLogin() .loginPage(\"/login-view\") // 登录页面 .loginProcessingUrl(\"/login\") //登录路径 .successForwardUrl(\"/r\") //登录成功跳转路径 .permitAll() .and() .csrf().disable(); // 关闭csrf安全验证 连接数据库认证 添加数据库依赖 org.springframework.boot spring-boot-starter-data-jdbc mysql mysql-connector-java 5.1.48 配置数据库 spring: datasource: username: root password: root url: jdbc:mysql://localhost:3306/user_db driver-class-name: com.mysql.jdbc.Driver 实体DTO @Data @Table(\"t_user\") public class UserDto { @Id private String id; private String username; private String password; private String fullname; private String mobile; } Dao @Repository public interface UserDao extends CrudRepository { @Query(\"SELECT * FROM `t_user` where username=:username\") UserDto findByUsername(@Param(\"username\") String username); } UserDetailService @Autowired private UserDao userDao; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { UserDto userDto = userDao.findByUsername(username); if(userDto == null){ // 如果用户查不到, 返回null, 由provider抛出异常 return null; } UserDetails details = User.withUsername(userDto.getUsername()).password(userDto.getPassword()).authorities(\"p1\").build(); return details; } 会话管理 获取用户身份 //获取当前用户信息 private String getUsername(){ Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); Object principal = authentication.getPrincipal(); if(principal == null){ return \"匿名用户\"; } if (principal instanceof UserDetails){ UserDetails userDetails = (UserDetails) principal; return userDetails.getUsername(); }else { return principal.toString(); } } 会话控制 机制 描述 always 如果没有session存在就创建一个 ifRequired 如果需要就创建一个Session(默认)登录时 never SpringSecurity将不会创建Session,但是如果应用中其他地方创建了Session,那么SpringSecurity将使用它 stateless 绝对不会创建和使用 配置方式 @Override protected void configure(HttpSecurity http) throws Exception { http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED); 自定义退出 .logout() .logoutUrl(\"/logout\") //退出地址 .logoutSuccessUrl(\"/index\"); //退出页面 Web的授权 使用资源授权, 更灵活. http.authorizeRequests() .antMatchers(\"/r/r1\").hasAuthority(\"p1\") .antMatchers(\"/r/r2\").hasAuthority(\"p2\") .antMatchers(\"/r/r3\").hasAnyAuthority(\"p1\",\"p2\") .antMatchers(\"/r/r4\").access(\"hasAuthority('p1') and hasAuthority('p2')\") .antMatchers(\"/r/**\").authenticated() .anyRequest().permitAll() 方法授权 建议基于Controller进行拦截 开启方法拦截 @EnableGlobalMethodSecurity(prePostEnabled = true) //开启方法授权 public class WebSecurityConfig extends WebSecurityConfigurerAdapter{ @PreAuthorize 在方法上加注解 p1 权限才能访问 @RequestMapping(\"/r/r1\") @PreAuthorize(\"hasAuthority('p1')\") public String r1(ModelMap map){ map.put(\"name\", \"权限1页面\"); return \"index\"; } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-08 16:05:41 "},"OAuth/OAuth2.html":{"url":"OAuth/OAuth2.html","title":"OAuth2","keywords":"","body":"OAuth2 名次定义 Third-party application：第三方程序，即client Http Service：Http服务提供商 Resource Owner：资源所有者，即用户 user User Agent：用户代理，本文指浏览器 Authorization Server：认证服务器，即服务提供商专门处理认证的服务器。 Resource Server：资源服务器，即服务提供商存放用户资源的服务器，它与认证服务器可以是同一台服务器，也可是不同服务器。 知道上面的名次，\b就不难理解 OAuth 的作用就是让客户端安全的获取用户的授权。 OAuth 的思路 OAuth在客户端与提供商之间设置了一个授权层，客户端不能直接登陆服务提供商，只能登陆授权层（Authorization layer），\"客户端\"登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。 \"客户端\"登录授权层以后，\"服务提供商\"根据令牌的权限范围和有效期，向\"客户端\"开放用户储存的资料。 运行流程 （A）用户打开客户端以后，客户端要求用户给予授权。 （B）用户同意给予客户端授权。 （C）客户端使用上一步获得的授权，向认证服务器申请令牌。 （D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。 （E）客户端使用令牌，向资源服务器申请获取资源。 （F）资源服务器确认令牌无误，同意向客户端开放资源。 授权模式 授权码模式 Authorization code 简化模式 implicit 密码模式 resource owner password credentials 客户端模式 授权码模式 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"SpringData/SpringDataJdbc.html":{"url":"SpringData/SpringDataJdbc.html","title":"Spring Data","keywords":"","body":"Spring Data Jdbc 添加依赖 org.springframework.boot spring-boot-starter-data-jdbc 创建实体 @Data @Table(\"t_user\") public class UserDto { @Id private String id; private String username; private String password; private String fullname; private String mobile; } 创建Dao @Repository public interface UserDao extends CrudRepository { @Query(\"SELECT * FROM `t_user` where username=:username\") UserDto findByUsername(@Param(\"username\") String username); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-09 14:27:36 "},"SpringData/SpringDataJPA.html":{"url":"SpringData/SpringDataJPA.html","title":"Spring-Data-JPA","keywords":"","body":"Spring Data JPA Repostory @Repository public interface AppUserRepostory extends JpaRepository { } Example 使用 public AppUser loadUserByUsername(String username) throws UsernameNotFoundException { AppUser user = new AppUser(); user.setUsername(username); ExampleMatcher matcher = ExampleMatcher.matching().withIgnoreNullValues() .withMatcher(\"username\", match -> match.contains() ); Example example =Example.of(user,matcher); Optional optional = userRepostory.findOne(example); AppUser appUser = userRepostory.queryByUsername(username); if (!optional.isPresent()) { throw new UsernameNotFoundException(\"用户名不存在\"); } return optional.get(); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"SpringCloud/SpringCloudContext.html":{"url":"SpringCloud/SpringCloudContext.html","title":"Spring Cloud","keywords":"","body":"Spring Cloud 上下文 Spring Boot 有一套自己的方式构建一个Spring 应用程序，例如有常规的公共配置文件位置，以及用于程序管理和监视任务的端点。Spring Cloud 在 Spring Boot 的基础上增加了一些通用的功能。 引导上下文 Spring Cloud 通过创建“引导”的上下文来运行，它是主程序的父上下文,它负责从外部加载配置属性，并解密本地外部配置文件中的属性。这两个上下文共享一个Environment(环境),该环境是Spring应用程序的外部属性来源。默认情况下，引导属性的优先级高，因此它不能被本地配置覆盖。 引导上下文和主程序的上下文使用不同的外部配置，可以使用 bootstrap.yml 代替application.yml 使引导上下文和主程序上下文保持完全的分离。 例如: bootstrap.yml spring: application: name: foo cloud: config: uri: ${SPRING_CONFIG_URI:http://localhost:8888} 如果你需要来自服务器任何特定的配置，需要设置spring.application.name, 该属性作为应用程序的ID。 也能够通过spring.cloud.bootstrap.enabled=false属性关闭引导的加载。 程序的上下文层次结构 引导上下文是作为父上下文添加到程序的上下文中，子上下文从父上下文中继承属性 由于属性源的排序规则，引导项优先。但是，请注意，这些文件不包含来自引导程序的任何数据。它的优先级非常低，但是可以用来设置默认值。 常规Spring应用程序上下文行为规则适用于属性解析:来自子上下文的属性通过名称和属性源名称覆盖父上下文中的属性 ...... 修改引导文件的位置 bootstrap.yml(或 .properties)位置可由spring.cloud.bootstrap.name(默认: bootstrap) 或者 spring.cloud.bootstrap.location(默认:空)指定。 重写远程属性的值 通过引导上下文添加到应用程序中的属性通常是远程的。(例: Spring Cloud Config Server),默认情况下,不能再本地重写他们，如果你想让程序自己的系统属性或配置文件覆盖远程属性,远程属性源必须通过设置授予它权限spring.cloud.config.allowOverride=true(在本地设置是无效的)一旦设置该标志后，两个更细粒度的设置将控制远程属性相对于系统属性和应用程序本地配置的位置 spring.cloud.config.overrideNone=true 允许任何本地属性源进行覆盖。 spring.cloud.config.overrideSystemProperties=false 只有系统属性，命令行参数和环境变量(而不是本地配置文件)才能够覆盖远程设置。 自定义引导配置 引导上下文可以通过在名为org.springframework.cloud.bootstrap.BootstrapConfiguration 的键下向 /META-INF/spring.factories 添加条目来设置您喜欢的任何操作。它包含一个以逗号分隔的Spring @Configuration类列表，用于创建上下文，您可以在此处创建您希望可用于主应用程序上下文以进行自动装配的任何Bean。 自定义引导属性源 引导过程添加的外部配置的默认属性源是 Spring Cloud Config Server,但是您可以通过向引导上下文(通过spring.factories)添加PropertySourceLocator类型的bean来添加额外的源,例如，你可以从数据库添加扩展属性。 如： @Configuration public class CustomPropertySourceLocator implements PropertySourceLocator { @Override public PropertySource locate(Environment environment) { return new MapPropertySource(\"customProperty\", Collections.singletonMap(\"property.from.sample.custom.source\", \"worked as intended\")); } } 传入的 Environment 是即将创建ApplicationContext的环境，换句话说，我们为它提供额外的属性源，它已经有了Spring Boot 提供的属性源，因此，您可以使用它们来查找特定与此环境的属性源。 如果你创建了一个包含此类的jar，然后添加到 META-INF/spring.factories org.springframework.cloud.bootstrap.BootstrapConfiguration=sample.custom.CustomPropertySourceLocator 日志配置 如果您打算使用SpringBoot 来配置日志，那么应该将配置放在bootstrap.yml 中， 环境变化 当配置发生变化后，如何加载新的配置信息？ 程序侦听EnvironmentChangeEvent 的事件(观察者设计模式)，有一个已更改的键值列表，应用程序将会： 重新绑定任何@ConfigurationPropertiesBean的上下文。 设置logging.level.*日志级别的任何属性。 注意，默认情况下客户端不会轮询环境变量发生变化，通常，我们不建议使用这种方法来检测更改(尽管你可以使用@Scheduled定时注解) 如果你有一个扩展的客户机程序，最好的办法是发送EnvironmentChangeEvent广播给所有的实例，而不是让轮询更改，(例如：使用 Spring Cloud Bus Spring Cloud 云总线) 刷新范围 当配置发送改变时，一个标记为@RefreshScope的Srping @Bean 将会被特殊处理，这个功能解决了有状态Bean的问题，只有在初始化时才会注入其配置。例如，如果一个数据库连接池打开了一个连接时，环境变量中的Url发生了改变。您可能希望这些连接的持有者能够继续完成他们想做的事情。下一次从连接池获取的连接时新的Url。 有时，甚至会强制在一些只能初始化一次的Beans上面使用@RefreshScope 如果这个bean是'不能被修改的'，你必须要使用@RefreshScope 注释Bean，或者在属性键 spring.cloud.refresh.extra-refreshable 指定类名。 个人猜测：如果Bean加了@RefreshScope，修改属性时，使用新的属性重新创建了一个Bean，而不是修改原有Bean的属性。 加密和解密技术 Spring Cloud有一个Environment预处理器，用于在本地解密属性值, 它遵循与配置服务器相同的规则，并具有相同的外部配置encrypt.*因此,你可以使用{cipher}* 的加密值,并且只要有一个有效的密钥，它们就会在主应用程序上下文获取环境设置的之前进行解密。在应用程序中使用加密功能，你需要将Spring Security RSA 加入到项目的classpath, (Maven坐标：org.springframework.security:spring-security-rsa)您还需要JVM中的全强度JCE扩展。 如果由于“非法密钥大小”而出现异常，并且使用Sun's JDK，您需要安装Java Cryptography Extension (JCE) Unlimited Strength governance Policy文件。 端点 对于 Spring Boot Actuator 的应用程序，有一些额外可用的管理端，你可以使用： POST到 /actuator/env 更新 Environment 重新绑定 @ConfigurationProperties 和日志级别。 /actuator/refresh to re-load the boot strap context and refresh the @RefreshScope beans /actuator/restart to close the ApplicationContext and restart it (disabled by default). /actuator/pause and /actuator/resume for calling the Lifecycle methods (stop() and start() on the ApplicationContext). Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"SpringCloud/study.html":{"url":"SpringCloud/study.html","title":"学习资料","keywords":"","body":"学习资料 千峰播客: https://www.funtl.com/ Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-13 14:02:32 "},"SpringCloud/SpringCloudAlibaba.html":{"url":"SpringCloud/SpringCloudAlibaba.html","title":"Spring Cloud Alibaba","keywords":"","body":"Spring Cloud Alibaba Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-13 13:52:51 "}}