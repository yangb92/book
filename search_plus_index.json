{"./":{"url":"./","title":"介绍","keywords":"","body":" 代码笔记 希望你该坚持主见的时候，坚持主见，该沉默的时候，学会沉默，宁愿卑微如灰尘,不可扭曲成蛆虫。 杨斌 local: Hangzhou,China email: 523084685@qq.com homepage: https://yangb92.gitee.io github: https://github.com/yangb92 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-11-17 10:56:30 "},"Shell/":{"url":"Shell/","title":"Shell","keywords":"","body":"Shell 命令收集 定时任务crontab 命令行分屏screen tldr命令手册 root权限用户 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-02-23 14:02:13 "},"Shell/screen.html":{"url":"Shell/screen.html","title":"screen分屏命令","keywords":"","body":"screen 安装 screen，使用命令 apt-get install screen 即可完成。 screen 常用快捷键如下： Ctrl+a 再按shift + s 水平分割当前窗口 Ctrl+a | 垂直分割当前窗口 Ctrl+a c 创建一个新的运行 shell 的窗口并切换到该窗口 Ctrl+a X 关闭当前窗口 Ctrl+a x 锁定当前窗口 Ctrl+a k 杀死当前窗口 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-02-06 23:48:32 "},"Shell/crontab.html":{"url":"Shell/crontab.html","title":"crontab定时任务","keywords":"","body":"crontab 定时任务 1. 列出定时任务 crontal -l 可以使用这种方法在$HOME目录中对crontab文件做一备份: $ crontab -l > $HOME/mycron 2. 编辑crontab文件 crontab -e 3. 删除 crontab -r 使用实例 实例1：每1分钟执行一次myCommand * * * * * myCommand 实例2：每小时的第3和第15分钟执行 3,15 * * * * myCommand 实例3：在上午8点到11点的第3和第15分钟执行 3,15 8-11 * * * myCommand 实例4：每隔两天的上午8点到11点的第3和第15分钟执行 3,15 8-11 */2 * * myCommand 实例5：每周一上午8点到11点的第3和第15分钟执行 3,15 8-11 * * 1 myCommand 实例6：每晚的21:30重启smb 30 21 * * * /etc/init.d/smb restart 实例7：每月1、10、22日的4 : 45重启smb 45 4 1,10,22 * * /etc/init.d/smb restart 实例8：每周六、周日的1 : 10重启smb 10 1 * * 6,0 /etc/init.d/smb restart 实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb 0,30 18-23 * * * /etc/init.d/smb restart 实例10：每星期六的晚上11 : 00 pm重启smb 0 23 * * 6 /etc/init.d/smb restart 实例11：每一小时重启smb * */1 * * * /etc/init.d/smb restart 实例12：晚上11点到早上7点之间，每隔一小时重启smb 0 23-7 * * * /etc/init.d/smb restart Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-02-06 23:38:03 "},"Shell/tldr.html":{"url":"Shell/tldr.html","title":"tldr命令手册","keywords":"","body":"tldr 命令手册 https://tldr.sh/ 安装请参考此文档。 TLDR是社区努力通过实际示例来简化的命令手册页 例：tar命令的用法 $ tldr tar tar Archiving utility. Often combined with a compression method, such as gzip or bzip. More information: . - Create an archive from files: tar cf target.tar file1 file2 file3 - Create a gzipped archive: tar czf target.tar.gz file1 file2 file3 - Extract a (compressed) archive into the current directory: tar xf source.tar[.gz|.bz2|.xz] - Extract an archive into a target directory: tar xf source.tar -C directory - Create a compressed archive, using archive suffix to determine the compression program: tar caf target.tar.xz file1 file2 file3 - List the contents of a tar file: tar tvf source.tar - Extract files matching a pattern: tar xf source.tar --wildcards \"*.html\" Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-02-06 23:48:21 "},"Shell/root.html":{"url":"Shell/root.html","title":"root权限用户","keywords":"","body":"创建root权限用户 # 创建用户 adduser tomcat # 设置密码 passwd tomcat # 赋予root权限 vim /etc/sudoers # 文件下面添加如下内容 ----------- # User privilege specification root ALL=(ALL:ALL) ALL tomcat ALL=(ALL:ALL) ALL Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-02-23 14:05:13 "},"security/security.html":{"url":"security/security.html","title":"网络安全","keywords":"","body":"Security 网络安全 Kali 网络配置 实用Kali虚拟机需要开启桥接模式。 修改/etc/network/interfaces文件 dhcp 自动获取ip地址 auto eth0 iface eth0 dhcp 重启网络服务 /etc/init.d/networking restart Nmap 常用指令 快速扫描主机的详细信息 nmap -sT -sV -Pn -v xxx.xxx.xxx.xxx 扫描所有的端口开放情况 nmap -sS -p 1-65535 -v 192.168.1.254 扫描网段主机(ping扫描) nmap -sn 192.168.16.100-150 深度扫描网络主机信息 nmap -A -T4 192.168.10.1 半开扫描(TCP SYN扫描) - 隐秘且速度快，比较常用 nmap -sS host Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 11:17:39 "},"security/demo.html":{"url":"security/demo.html","title":"漏洞利用","keywords":"","body":"漏洞利用 CVE-2020-1938 文件包含漏洞 漏洞说明 该漏洞是由于Tomcat AJP协议存在缺陷而导致，攻击者利用该漏洞可通过构造特定参数，读取服务器webapp下的任意文件。若目标服务器同时存在文件上传功能，攻击者可进一步实现远程代码执行。目前，厂商已发布新版本完成漏洞修复。 受影响版本 Apache Tomcat 6 Apache Tomcat 7 Apache Tomcat 8 Apache Tomcat 9 不受影响版本 Apache Tomcat = 7.0.100 Apache Tomcat = 8.5.51 Apache Tomcat = 9.0.31 PoC github: https://github.com/yangb92/AJPy Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 11:17:52 "},"Tool/":{"url":"Tool/","title":"插件工具","keywords":"","body":"工具插件 Chrome 插件 Infinity 标签页管理 安装方式 1. 谷歌市场搜索下载 2. 谷歌访问助手 免费访问: 谷歌搜索，Gmail邮箱，Chrome商店... 更好用的谷歌访问助手工具 pp访问助手 www.ppgoogle.net 沙拉查词 多个来源的网页翻译工具 Darkreader 网页暗色模式: https://darkreader.org/ Jetbrains系列产品 Jetbrains系列产品2019.2.3最新激活方法[持续更新] https://zhile.io/2018/08/25/jetbrains-license-server-crack.html?tdsourcetag=s_pctim_aiomsg 漂亮的 Markdown 编辑器 Typora https://www.typora.io/ Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-01-22 13:14:06 "},"Tool/PowerShell.html":{"url":"Tool/PowerShell.html","title":"PowerShell 美化主题","keywords":"","body":"PowerShell 美化 PowerShell 美化效果: 配置windows允许执行没有签名（远程）的Powershell脚本 在设置中面板中搜索PowerShell 找到开发人员设置,打勾这一项 下载Windows包管理工具 Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) 输入 choco -v验证是否安装成功 GIT choco install git 字体库 只需要安装字体库中 DejaVuSansMono 的字体就可以了. 字体下载好右键安装即可. powershell的git集成方案 posh-git Install-Module posh-git 基于posh-git的美化主题oh-my-posh Install-Module oh-my-posh 硬货在这里 刚刚前面做的全都是事前准备而已，这里才是真正影响Powershell主题的主要关键。直接复制到Powershell跑一下吧。 Install-Module -Name PSReadLine -Force -SkipPublisherCheck if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } @\" #requires -Version 2 -Modules posh-git function Write-Theme { param( [bool] `$lastCommandFailed, [string] `$with ) `$lastColor = `$sl.Colors.PromptBackgroundColor `$prompt = Write-Prompt -Object `$sl.PromptSymbols.StartSymbol -ForegroundColor `$sl.Colors.PromptForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor #check the last command state and indicate if failed If (`$lastCommandFailed) { `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.FailedCommandSymbol) \" -ForegroundColor `$sl.Colors.CommandFailedIconForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor } #check for elevated prompt If (Test-Administrator) { `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.ElevatedSymbol) \" -ForegroundColor `$sl.Colors.AdminIconForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor } `$user = [System.Environment]::UserName `$computer = [System.Environment]::MachineName `$path = Get-FullPath -dir `$pwd if (Test-NotDefaultUser(`$user)) { `$prompt += Write-Prompt -Object \"`$user@`$computer \" -ForegroundColor `$sl.Colors.SessionInfoForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor } if (Test-VirtualEnv) { `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.SegmentForwardSymbol) \" -ForegroundColor `$sl.Colors.SessionInfoBackgroundColor -BackgroundColor `$sl.Colors.VirtualEnvBackgroundColor `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.VirtualEnvSymbol) `$(Get-VirtualEnvName) \" -ForegroundColor `$sl.Colors.VirtualEnvForegroundColor -BackgroundColor `$sl.Colors.VirtualEnvBackgroundColor `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.SegmentForwardSymbol) \" -ForegroundColor `$sl.Colors.VirtualEnvBackgroundColor -BackgroundColor `$sl.Colors.PromptBackgroundColor } else { `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.SegmentForwardSymbol) \" -ForegroundColor `$sl.Colors.SessionInfoBackgroundColor -BackgroundColor `$sl.Colors.PromptBackgroundColor } # Writes the drive portion `$prompt += Write-Prompt -Object \"`$path \" -ForegroundColor `$sl.Colors.PromptForegroundColor -BackgroundColor `$sl.Colors.PromptBackgroundColor `$status = Get-VCSStatus if (`$status) { `$themeInfo = Get-VcsInfo -status (`$status) `$lastColor = `$themeInfo.BackgroundColor `$prompt += Write-Prompt -Object `$(`$sl.PromptSymbols.SegmentForwardSymbol) -ForegroundColor `$sl.Colors.PromptBackgroundColor -BackgroundColor `$lastColor `$prompt += Write-Prompt -Object \" `$(`$themeInfo.VcInfo) \" -BackgroundColor `$lastColor -ForegroundColor `$sl.Colors.GitForegroundColor } # Writes the postfix to the prompt `$prompt += Write-Prompt -Object `$sl.PromptSymbols.SegmentForwardSymbol -ForegroundColor `$lastColor `$timeStamp = Get-Date -UFormat %r `$timestamp = \"[`$timeStamp]\" `$prompt += Set-CursorForRightBlockWrite -textLength (`$timestamp.Length + 1) `$prompt += Write-Prompt `$timeStamp -ForegroundColor `$sl.Colors.PromptForegroundColor `$prompt += Set-Newline if (`$with) { `$prompt += Write-Prompt -Object \"`$(`$with.ToUpper()) \" -BackgroundColor `$sl.Colors.WithBackgroundColor -ForegroundColor `$sl.Colors.WithForegroundColor } `$prompt += Write-Prompt -Object (`$sl.PromptSymbols.PromptIndicator) -ForegroundColor `$sl.Colors.PromptBackgroundColor `$prompt += ' ' `$prompt } `$sl = `$global:ThemeSettings #local settings `$sl.PromptSymbols.StartSymbol = '' `$sl.PromptSymbols.PromptIndicator = [char]::ConvertFromUtf32(0x276F) `$sl.PromptSymbols.SegmentForwardSymbol = [char]::ConvertFromUtf32(0xE0B0) `$sl.Colors.PromptForegroundColor = [ConsoleColor]::White `$sl.Colors.PromptSymbolColor = [ConsoleColor]::White `$sl.Colors.PromptHighlightColor = [ConsoleColor]::DarkBlue `$sl.Colors.GitForegroundColor = [ConsoleColor]::Black `$sl.Colors.WithForegroundColor = [ConsoleColor]::DarkRed `$sl.Colors.WithBackgroundColor = [ConsoleColor]::Magenta `$sl.Colors.VirtualEnvBackgroundColor = [System.ConsoleColor]::Red `$sl.Colors.VirtualEnvForegroundColor = [System.ConsoleColor]::White \"@>$env:userprofile\"\\Documents\\WindowsPowerShell\\Modules\\oh-my-posh\\2.0.230\\Themes\\Paradox.psm1\" @\" chcp 65001 Set-PSReadlineOption -EditMode Emacs function which(`$name) { Get-Command `$name | Select-Object Definition } function rmrf(`$item) { Remove-Item `$item -Recurse -Force } function mkfile(`$file) { \"\" | Out-File `$file -Encoding ASCII } Import-Module posh-git Import-Module oh-my-posh Set-Theme Paradox \"@ > $PROFILE chcp 65001 Set-PSReadlineOption -EditMode Emacs Import-Module posh-git Import-Module oh-my-posh Set-Theme Paradox 设置powershell字体,选择安装的powerline字体. 其他主题参考 主题页面 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-11-01 22:07:54 "},"Tool/hexo.html":{"url":"Tool/hexo.html","title":"Hexo 博客框架","keywords":"","body":"Hexo 博客搭建 博客的基础搭建请参考: 官方文档 推荐主题 主题: https://github.com/jerryc127/hexo-theme-butterfly 主题预览: https://jerryc.me/ 主题安装文档:https://jerryc.me/posts/21cfbf15 博客扩展设置: https://jerryc.me/posts/31391d01 为博客添加宠物 详细资料: https://github.com/EYHN/hexo-helper-live2d 宠物包: https://github.com/xiazeyu/live2d-widget-models npm install --save hexo-helper-live2d 在站點配置文件或者主題配置文件添加以下内容 live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-wanko # 宠物的模型 display: position: right width: 150 height: 300 mobile: show: true 安裝需要的寵物文件: npm install {packagename} Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-11-17 10:56:30 "},"Tool/chromeExp.html":{"url":"Tool/chromeExp.html","title":"Chrome 插件开发","keywords":"","body":"Chrome 插件开发 mainfest.json { \"name\": \"WSBS\", \"description\": \"网上办事大厅扩展功能\", \"version\": \"1.0\", \"manifest_version\": 2, \"browser_action\": { \"default_popup\": \"main.html\", \"default_icon\": \"main.png\" }, \"permissions\": [ \"tabs\" ] } main.html body { width: 250px; text-align: center; } #build { width: 100%; background-color: brown; color: lightyellow; border: none; height: 30px; } 甘肃人力资源网上办事大厅 说明: 生成当前页面的授权地址, 实现信任传递. 生成授权地址 main.js document.getElementById('build').onclick = function(e){ chrome.tabs.getSelected(null,function(tab) { var pre_url = 'http://www.gszwfw.gov.cn/api/sso/loginTrust?backUrl=http://www.rst.gansu.gov.cn:8080/auth/sso/trust/common/' url = tab.url.match(/(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/).pop() document.getElementById('result').textContent = pre_url + window.btoa(url); }); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-01-22 13:14:06 "},"git/gitbook.html":{"url":"git/gitbook.html","title":"git","keywords":"","body":"Git 覆盖分支 把本地的devlop分支强制(-f)推送到远程mastergit push origin devlop:master -f 用devlop覆盖当前分支git reset –hard develop git push origin master –f 将GitBook文档托管到Github 将打包的文档发布至公共 gitpage 在 github|gitee 创建一个仓库 创建gitbook文档, 使用 gitbook build打包 安装推送插件cnpm install -g gh-pages 将文档发布到github|gitee gh-pages -d _book 开启仓库的gitpage, 选择gh-pages分支. 本文档使用插件 { \"title\":\"学习笔记\", \"author\":\"杨斌\", \"language\" : \"zh-hans\", \"plugins\": [ \"-search\", \"back-to-top-button\", \"chapter-fold\", \"sharing\", \"donate\", \"search-pro\", \"insert-logo\", \"theme-default\", \"theme-comscore\", \"code\", \"splitter\", \"tbfed-pagefooter\" ], \"styles\": { \"website\": \"styles/website.css\" }, \"pluginsConfig\": { \"donate\": { \"wechat\": \"https://gitee.com/yangb92/book/raw/gh-pages/git/wxpay.png\", \"alipay\": \"https://gitee.com/yangb92/book/raw/gh-pages/git/alipay.png\", \"title\": \"\", \"button\": \"赏\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\" }, \"insert-logo\": { \"url\": \"https://gitee.com/yangb92/book/raw/gh-pages/favorite.png\", \"style\": \"background: none; max-height: 80px; min-height: 10px\" }, \"theme-default\": { \"showLevel\": true }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy yangb \", \"modify_label\": \"该文章修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" } } } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-02-29 09:34:34 "},"git/gituse.html":{"url":"git/gituse.html","title":"在项目开发中使用git","keywords":"","body":"项目开发中使用Git 项目开发中如何使用git? 开发人员只需要在dev分支进行代码更新和提交就能满足日常工作需要. 拉取项目 复制项目的地址 2.创建一个文件夹,右键菜单中打开Git Bash命令行,如果没有安装Git,先安装Git工具. git clone git@192.168.10.45:zjapl/gov-gsrs.git 3.进入项目目录 gov-gsrs 进行开发 切换到开发分支 git checkout dev 更新代码 git pull origin dev 提交代码 git push origin dev Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-11-01 22:07:54 "},"Python/Python.html":{"url":"Python/Python.html","title":"Python","keywords":"","body":"Python 依赖管理requirement 生成当前项目的requirement.txt pip freeze > requirements.txt 安装requirements.txt依赖 pip install -r requirements.txt 虚拟环境 虚拟环境相当于一个容器，在这个容器中安装的任何软件包都不会影响整个环境 Python3 虚拟环境 环境安装: sudo apt-get install python3-venv 创建虚拟环境 python3 -m venv myvenv（名称随意） 激活虚拟环境 ./myvenv venv/bin/activate 退出虚拟环境 deactivate Python2 虚拟环境 安装 pip install virtualenv 创建虚拟环境 virtualenv [虚拟环境的名字] 创建环境的时候指定Python解释器 virtualenv -p C:\\Python36\\python.exe [virutalenv name] 进入环境 Linux 虚拟环境 source /path/bin/activate 退出 deactivate Python 国内镜像源使用 让PIP源使用国内镜像，提升下载速度和安装成功率。 对于Python开发用户来讲，PIP安装软件包是家常便饭。但国外的源下载速度实在太慢，浪费时间。而且经常出现下载后安装出错问题。所以把PIP安装源替换成国内镜像，可以大幅提升下载速度，还可以提高安装成功率。 国内源： 新版ubuntu要求使用https源，要注意。 清华：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学：http://pypi.hustunique.com/ 山东理工大学：http://pypi.sdutlinux.org/ 豆瓣：http://pypi.douban.com/simple/ 临时使用： 可以在使用pip的时候加参数-i https://pypi.tuna.tsinghua.edu.cn/simple 例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider，这样就会从清华这边的镜像去安装pyspider库。 永久修改，一劳永逸： Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹) 内容如下： [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host=mirrors.aliyun.com windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini。内容同上。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-01-22 13:14:06 "},"Nginx/Nginx.html":{"url":"Nginx/Nginx.html","title":"Nginx","keywords":"","body":"Nginx Nginx 的主从热备 场景: Nginx代理主服务器对外提供服务, 主服务器失去连接后 Nginx 代理转向从服务器为外界提供服务. 当主服务器恢复时, 自动切换至主服务器继续为外界提供服务. Nginx 配置: http { upstream backend { server localhost:9090; server localhost:9999 backup; } server { listen 80; location / { proxy_pass http://backend; } } } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-01-22 13:14:06 "},"DesignPatterns/":{"url":"DesignPatterns/","title":"设计模式","keywords":"","body":"设计模式 学习资料 https://design-patterns.readthedocs.io/ 示例代码 https://github.com/yangb92/DesignPattern4J Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-22 20:08:35 "},"React/React.html":{"url":"React/React.html","title":"React","keywords":"","body":"React 核心概念 虚拟DOM (Virtual Document Object Model) 本质: 在框架的概念中,程序员使用js对象模拟浏览器上的DOM和DOM嵌套关系, 目的: 为了实现页面中DOM元素的高效更新 Diff 算法 (Different 差异算法) Tree Diff : 新旧两颗DOM树逐层对比. Domponent Diff: 在进行tree diff中,每一层中的组件对比, 如果类型不同进行更新 Element Diff: 在组件进行对比的时候,如果组件组件类型相同,则需要进行元素对比 总结 虚拟DOM用JS模拟页面的DOM, Diff算法负责向页面更新JS模拟的DOM 项目实践 环境安装 webpack 开发环境安装 参考资料 安装React组件 cnpm i react react-dom -S -S 代表该模块生产需要使用, -D代表开发使用 Hello React index.js 只需要三步 //1. 这两个包导入格式固定 import React from 'react' //创建组件, 虚拟DOM元素,生命周期 import ReactDOM from 'react-dom' // 把创建好的组件 和 虚拟DOM 放到页面展示 //2. 创建虚拟DOM /* 参数1: 创建元素的类型 [字符串] 元素的名称 参数2: 是一个对象或null, 表示这个DOM元素的属性. 参数3: 子节点 (包括其他虚拟DOM) 参数n: 其他子节点 例: Hello World! */ const myh1 = React.createElement('h1', {id:'myh1',title:'这是h1'},\"Helo World!\") //3. 使用ReactDOM 把虚拟DOM渲染到页面上 /* 参数1: 要渲染的那个虚拟DOM元素 参数2: 指定页面上的一个容器 DOM对象 */ ReactDOM.render(myh1,document.getElementById(\"app\")) index.html 中要存在一个id为app的容器 两个元素的嵌套 const myh1 = React.createElement('h1', {id:'myh1',title:'这是h1'},\"Helo World!\") // mydiv 嵌套 myh1 const mydiv = React.createElement('div',null,'这是一个div',myh1) 启用JSX语法 通过React.createElement方式创建虚拟DOM的方式过于麻烦, JSX是可以直接再JS中写HTML的语法 可以使用babel来将JSX语法转换成React.create Element的形式来执行. babel 插件安装 安装babel插件 cnpm i babel-core babel-loader babel-plugin-transform-runtime -D cnpm i babel-preset-env babel-preset-stage-0 -D 安装能够识别转换jsx语法的包 cnpm i babel-preset-react -D 添加至webpack的module webpack.config.js module: { //所有第三方模块的配置 rules: [ //匹配规则 {test: /\\.js|jsx$/, use: 'babel-loader', exclude: /node_modules/} ] } 在根目录添加.babelrc配置文件 { \"presets\": [\"env\",\"stage-0\",\"react\"], \"plugins\": [\"transform-runtime\"] } 语法注意事项 jsx 中注释使用{/*这是注释*/} 元素的class属性用className代替 label 的for 属性用 hemlFor 代替 数组的map迭代 {names.map(item => {item})} key放在迭代元素上面 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-06 19:00:54 "},"React/components.html":{"url":"React/components.html","title":"组件","keywords":"","body":"React 组件 创建组件: 方式一 import React from 'react' //创建组件, 虚拟DOM元素,生命周期 import ReactDOM from 'react-dom' // 把创建好的组件 和 虚拟DOM 放到页面展示 /*************定义一个组件******************/ function Hello(props){ // props为组件接收的参数, 为只读属性 return 姓名: {props.name} 年龄: {props.age} 性别: {props.gender} } /********************************************/ ReactDOM.render( {/* 使用组件,传递props数据 */} , document.getElementById(\"app\")) TIP: 组件函数的首字母必须大写 展开运算符 ... 将对象属性展开传递给组件 const user = { name:'Yangb', age:27, gender:'Nan' } 将组件抽出到单独的文件 创建Hello.jsx src/ |--components/ |--Hello.jsx |--index.js |--index.html Hello.jsx import React from 'react' //定义一个组件 props为组件接收的参数, 为只读属性 export default function Hello(props){ return 姓名: {props.name} 年龄: {props.age} 性别: {props.gender} } 在index.js中导入使用Hello组件 import Hello from './components/Hello.jsx' //后缀名jsx不能省略 ... 配置省略 jsx 后缀名 如果看到导入import Hello from '@/components/Hello' ,定义了@为绝对路径 webpack.config.json 中配置 resolve: { extensions: ['.js','.jsx','.json'], //表示这几个后缀名可省略不写 alias: { '@': path.join(__dirname,'./src') //@ 表示src这个路径 } } 创建组件: 方式二 ES6 的 class 定义 // 定义一个动物类 // 注意1: 在class 内部只能写构造器,静态方法,静态属性 // 注意2: class关键字内部,还是用原来的配方,我们把class称为语法糖 class Animal{ // 构造器 constructor(name,age){ this.name = name this.age = age } // 在class内部通过static修饰的属性是静态属性 static info = 'xxx' //实例方法 -> 存在原型中 say(){ console.log(\"我是实例方法\") } //静态方法 -> 存在构造中 static show(){ console.log(\"我是静态方法\") } } 继承: this 只能在super()后面使用 class Person extends Animal{ constructor(name, age, hair){ super(name,age) this.hair = hair } } 使用Class创建一个组件 class Hello extends React.Component{ // 在render方法中返回虚拟jsx的dom, 传入参数可通过this.props获取 render(){ return 姓名: {this.props.name} } } 两种方式的对比 class Hello extends React.Component{ constructor(){ super() this.state = { //这里面的数据可自由修改 msg:'我是一个组件' } } render(){ this.state.msg += '!' //修改值 return 姓名: {this.state.msg} } } class 创建的组件有自己的私有数据和生命周期函数 用构造函数创建出的组件,叫做\"无状态组件\" class 关键字创建出来的组件叫做\"有状态组件\" 1.有状态组件和无状态组件的本质却别就是:有无state属性 2.无状态组件的运行效率更高 例子1: 用组件展示一个简单的评论列表 文件结构 |src ​ |components ​ |CmtItem.jsx ​ |CmtList.jsx ​ |index.js ​ |index.html CmtItem.jsx import React from 'react' // 一个无状态组件,接收参数返回一个评论的条目 export default function(props){ return 姓名: {props.user} 评论: {props.content} } CmtList.jsx import React from 'react' import CmtItem from '@/components/CmtItem' // 评论列表组件 初始化数据,传递给条目 export default class CmtList extends React.Component{ constructor(){ super() this.state = { CommentList:[ {id:1,user:'张三',content:'nice'}, {id:2,user:'李四',content:'good'}, {id:3,user:'王五',content:'excting'} ] } } render(){ return this.state.CommentList.map(Item => ) } } index.js //1. 这两个包导入格式固定 import React from 'react' //创建组件, 虚拟DOM元素,生命周期 import ReactDOM from 'react-dom' // 把创建好的组件 和 虚拟DOM 放到页面展示 import CmtList from '@/components/CmtList' ReactDOM.render( , document.getElementById(\"app\")) 样式 行内样式定义如下, 样式属性类型要按照json规范书写 定义样式的三种方法 方法一和方法二: /* 第一种封装方法 */ const itemStyle = {border:'1px dashed #ccc',margin:'10px',padding:'10px',boxShadow:'0 0 10px #ccc'} const userStyle = {fontSize:\"14px\"} const contentStyle = {fontSize:\"12px\"} /** 第二种封装方法 */ const styles = { itemStyle : {border:'1px dashed #ccc',margin:'10px',padding:'10px',boxShadow:'0 0 10px #ccc'}, userStyle : {fontSize:\"14px\"}, contentStyle : {fontSize:\"12px\"} } {/*使用第一种封装*/} 评论人: {props.user} {/*使用第二种封装*/} 评论内容: {props.content} 方法三: 导入css样式文件 安装插件npm i style-loader css-loader -D webpack.config.js 中配置插件, 为了避免css全局化互相影响,启用css-loader模块化 ... module: { //所有第三方模块的配置 rules: [ //匹配规则 ... //css 样式插件, css-loader的modules参数代表css样式模块化, 只在当前引入的模块起作用, 不添加此参数,样式会在全局中起作用 {test: /\\.css$/, use: ['style-loader', 'css-loader?modules']} ] } ... 编写css文件 .title { text-align:center; color:red; font-size:28px; font-weight:300; } 导入css文件 import cssobj from '@/components/cmt.css' //启用css模块化 评论列表 //如果没启用模块化,直接用css定义的class名称即可 评论列表 设置模块化后的类名称 css-loader添加参数 'css-loader?modules&localIdentName=[path][name]-[local]-[hash:5]' 设置类名是否被模块化 :global不会被模块化 :local 会被模块化, 默认 :global(.test){ italic } 在项目中启用模块化并同时使用bootstrap 把自己的样式表定义为.scss文件 第三方样式表以.css样式结尾 我们只需要为自己的.scss文件启用模块化即可. 操作步骤 安装插件 cnpm i sass-loader node-sass -D 配置插件,处理.scss文件,不处理.css文件 {test: /\\.scss$/,use:['style-loader','css-loader?modules&localIdentName=[path][name]-[local]-[hash:5]','sass-loader']} {test: /\\.css$/, use:['style-loader','css-loader']} 安装bootstrap npm i bootstrap@3.3.7 -S 导入 import 'bootstrap/dist/css/bootstrap.css' > > 如果出现.svg .ttf .woff .eot 字体无法处理, 添加一下插件 cnpm i url-loader file-loader -D 配置插件处理字体文件 {test: /\\.ttf|woff|woff2|eot|svg$/, use: ['url-loader']} React 的生命周期 生命周期函数 (或者钩子函数) React组件的生命周期分为三部分 一个定时器的例子 import React from 'react' export default class Lifecycle extends React.Component{ constructor(){ super() this.state = {date: new Date()} } /** * 组件挂载的时候初始化一个定时器 调用tick方法 */ componentDidMount(){ this.timerID = setInterval( () => this.tick(), 1000 ); } /** * 组件卸载的时候清除定时器 */ componentWillUnmount(){ clearInterval(this.timerID); } /** * 定时器中更新状态 */ tick(){ this.setState({ date: new Date() }) } render(){ return ( 北京时间: {this.state.date.toLocaleTimeString()} ) } } 条件渲染 function Greeting(props){ if(props.loginState){ return } return } function LoginButton(props){ if(props.loginState){ return 退出 } return 登陆 } FORM表单 import React from 'react' export default class Form extends React.Component{ constructor(){ super() this.state = {value: ''} } render(){ return( 名字: ) } handleSubmit = (event)=>{ alert('提交的名字:' + this.state.value) // 阻止事件的执行 event.preventDefault() } handleChange = (event) => { this.setState({value:event.target.value}) } } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-08 19:40:24 "},"React/webpack.html":{"url":"React/webpack.html","title":"webpack","keywords":"","body":"Webpack 简单使用 基本的webpack项目 npm init -y 快速初始化项目目录 创建目录 dist/ src/ |--index.html |--index.js 执行cnpm i webpack webpack-cli -D 安装webpack工具. 在webpack.config.js中配置webpack module.exports = { mode:'development', // development, production 设置打包的格式,压缩格式和非压缩格式 } webpack 4.x 默认约定了 打包的入口是 src/index.js 打包的输出是 dist/main.js 运行 webpack 命令 在 index.html中引入打包好的../dist/main.js即可使用 webpack-dev-server 的基本使用 安装 cnpm i webpack-dev-server -D 提供默认的webpack.config.js 配置, 运行webpack-dev-server 日志中出现 i ｢wds｣: Project is running at http://localhost:8080/ i ｢wds｣: webpack output is served from / 代表 webpack 打包的文件输入托管路径在当前的/根路径下,访问http://localhost:8080/main.js 可以访问到打包好的main.js 但是由于webpack打包好的文件存在内存,在真实目录中并不能看得到. 但我们可以在文件中引用它. /main.js 即可 支持其他的命令 --open 自动打开浏览器 --port 3000 端口 --hot --progress --compress 传输压缩 --host 127.0.0.1 例如 \"scripts\": { \"dev\": \"webpack-dev-server --open --port 3000 --host 127.0.0.1 --progress --hot\" }, 现在有个问题,我们的首页在src中,需要能够从根目录访问.. html-webpack-plug的使用 在内存中自动生成index.html页面的插件 安装 cnpm i html-webpack-plugin -D 插件 插件的使用 在 webpack.config.js中加入插件 const path = require('path') const HtmlWebPackPlugin = require('html-webpack-plugin') //导入插件 const htmlPlugin = new HtmlWebPackPlugin({ template: path.join(__dirname,'./src/index.html'), //源文件 filename: 'index.html' //生成在内存中的名称 }) // 向外暴露打包的配置信息, webpack支持所有node api和语法 module.exports = { mode:'development', // development production plugins: [ htmlPlugin ] } 并且在 index.html中会自动引入main.js, 所以我们不需要再手动引入main.js了. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-06 19:00:54 "},"React/event.html":{"url":"React/event.html","title":"事件","keywords":"","body":"React 事件 在React有一套自己的事件绑定机制, 事件名是驼峰规则. 示例: 箭头函数的好处是this 环境指的是当前class的环境.可以使用this获取当前class中的属性. 修改state的数据 在React中,想要为state中的数据重新赋值,不要使用 this.state.* = 值 应该调用 React提供的 this.setState({msg:123}) 在setState中,只会更新对应的值,而不会覆盖其他的值. this.setState的方法执行是异步的,在调用完setState之后要立即获取设置完的值,需要使用this.setState({},callable) 示例代码 import React from 'react' import 'bootstrap/dist/css/bootstrap.css' export default class BindEvent extends React.Component{ constructor(){ super() this.state = { msg: \"你好\" } } render(){ return {/* 在React有一套自己的事件绑定机制, 事件名是驼峰规则. */} this.show('哈哈')}> 按钮 {this.state.msg} } // 箭头函数的好处是this 环境指的是当前class的环境.可以使用this获取当前class中的属性. show = (args) => { // 在React中,想要为state中的数据重新赋值,不要使用 this.state.*** = 值 // 应该调用 React提供的 this.setState({msg:123}) // 在setState中,只会更新对应的值,而不会覆盖其他的值. // this.setState的方法执行是异步的,在调用完setState之后要立即获取设置完的值,需要使用this.setState({},callable) this.setState({ msg:\"你说: \"+args },() => { console.log(this.state.msg) }) } } 同步文本框的值 React 不支持双向绑定, 只支持将state传输到页面, 无法从页面自动绑定数据到state中, 不支持数据的逆向传输. 将属性绑定到文本框 value={this.state.xxx} 将文本框的值同步到属性: 第一步,手动监听文本框的onChange事件 第二部: 获取文本框的值 第三步: 调用setState方法同步最新的值 render(){ return {/* 在React有一套自己的事件绑定机制, 事件名是驼峰规则. */} this.show('哈哈')}> 按钮 {this.state.msg} {/* 第一步,手动监听文本框的onChange事件 */} this.changeTxt(e)} ref='txt' /> } changeTxt = (e) => { // 第二部: 获取文本框的值 //方式一: 通过参数 e 获取 console.log(e.target.value) //方式二: 通过refs属性获取 console.log(this.refs.txt.value) //第三步: 调用setState方法同步最新的值 this.setState({ msg: this.refs.txt.value }) } 绑定this并传参的几种方式 使用箭头函数 bing函数this.xx.bind(this) 传递当前this. 和call/apply的区别bind 只会修改指向不会调用, bind中的参数传递, 第一个参数是this this.method.bind(this,args1,...) 可以在构造函数中执行该方法或在事件中绑定 第三种: 使用箭头函数this的调用即可 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-06 19:00:54 "},"OAuth/OAuth2.html":{"url":"OAuth/OAuth2.html","title":"OAuth2","keywords":"","body":"OAuth2 名次定义 Third-party application：第三方程序，即client Http Service：Http服务提供商 Resource Owner：资源所有者，即用户 user User Agent：用户代理，本文指浏览器 Authorization Server：认证服务器，即服务提供商专门处理认证的服务器。 Resource Server：资源服务器，即服务提供商存放用户资源的服务器，它与认证服务器可以是同一台服务器，也可是不同服务器。 知道上面的名次，\b就不难理解 OAuth 的作用就是让客户端安全的获取用户的授权。 OAuth 的思路 OAuth在客户端与提供商之间设置了一个授权层，客户端不能直接登陆服务提供商，只能登陆授权层（Authorization layer），\"客户端\"登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。 \"客户端\"登录授权层以后，\"服务提供商\"根据令牌的权限范围和有效期，向\"客户端\"开放用户储存的资料。 运行流程 （A）用户打开客户端以后，客户端要求用户给予授权。 （B）用户同意给予客户端授权。 （C）客户端使用上一步获得的授权，向认证服务器申请令牌。 （D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。 （E）客户端使用令牌，向资源服务器申请获取资源。 （F）资源服务器确认令牌无误，同意向客户端开放资源。 授权模式 授权码模式 Authorization code 简化模式 implicit 密码模式 resource owner password credentials 客户端模式 授权码模式 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"Concurrent/Overview.html":{"url":"Concurrent/Overview.html","title":"Java","keywords":"","body":"java.util.concurrent 概述 官方英文文档 Description 实体类经常用于并发编程，这个包中包含了一些小型标准化可扩展框架，以及一些实用的实现类,否则就单调乏味且难以实现。以下是主要组件的描述。 Executors Interfaces. Executor 是一个简单的标准化接口, 用于自定义线程，线程池，异步I/O 和 轻量级任务框架, 这些功能取决于使用Executor哪个实现类。任务可以在一个新的线程执行，现有任务的执行线程或线程调用执行,并且可以顺序执行或者并发执行。ExecutorService 提供了一个更完整的异步任务执行框架,它管理了任务的排队的和调度,并允许控制关闭，ScheduledExecutorService子接口和相关接口添加了对延迟和周期性任务执行的支持。ExecutorServices提供了安排异步执行任何表示为Callable的函数的方法，Runnable 作为结果的承载。Future返回函数的结果，确定执行是否已完成,并提供取消执行的方法,RunnableFuture是一个拥有run方法的Future，在执行时设置其结果。 Implementations. 类ThreadPoolExecutor和ScheduledThreadPoolExecutor提供可调节的灵活的线程池，Executors类为Executor的最常见种类和配置提供工厂方法,以及一些使用它们的实用方法。其他基于Executor的实用程序包括具体的类FutureTask，它提供了future的公共可扩展实现,以及ExecutorCompletionService，它帮助协调异步任务组的处理。 ForkJoinPool类提供了一个Executor，主要用于处理ForkJoinTask及其子类的实例,这些类采用了一种工作窃取调度程序，可以获得符合计算密集型并行处理中常常存在的限制的任务的高吞吐量。 Queues ConcurrentLinkedQueue类提供了一个高效的可伸缩的线程安全非阻塞FIFO(先进先出)队列,ConcurrentLinkedDeque类与之类似，但还支持Deque(双向队列)接口。 该报中提供了五个BlockingQueue 接口实现类,它定义了put和take的阻塞版本,LinkedBlockingQueue，ArrayBlockingQueue，SynchronousQueue，PriorityBlockingQueue和DelayQueue。 不同的类涵盖了生产者 - 消费者，消息传递，并行任务和相关并发设计的最常见使用上下文。 扩展接口TransferQueue和实现LinkedTransferQueue引入了同步传输方法(以及相关特性)，其中生产者可以选择性地阻塞等待其消费者。 BlockingDeque接口扩展了BlockingQueue，支持FIFO和LIFO(基于堆栈)操作。类LinkedBlockingDeque提供了一个实现 Synchronizers 提供了5个工具类用户常见的同步操作。 Semaphore /seməfɔː/是一种经典的并发工具。 CountDownLatch是一个非常简单但非常常见的实用程序，用于阻塞，直到给定数量的信号，事件或条件成立。 CyclicBarrier是一种可重置的多路同步点，在某些并行编程风格中很有用。 Phaser提供了更灵活的屏障形式，可用于控制多个线程之间的分阶段计算。 Exchanger允许两个线程在集合点交换对象，并且在多个管道设计中很有用。 Concurrent Collections 此软件包提供了专为在多线程上下文中使用而设计的Collection实现,ConcurrentHashMap, ConcurrentSkipListMap, ConcurrentSkipListSet, CopyOnWriteArrayList, and CopyOnWriteArraySet 当预期多个线程访问给定集合的时候，ConcurrenthashMap 通常比一个同步的HashMap(Hash表数据结构) 可取.并且ConcurrentSkipListMap通常优于同步的TreeMap(红黑树数据结构),当预期的读取和遍历次数远远超过列表的更新次数时，CopyOnWriteArrayList优于同步的ArrayList。 包中 Concurrent 前缀 表示与类似的 synchronized 类几个不同之处. For example java.util.Hashtable and Collections.synchronizedMap(new HashMap()) are synchronized. Concurrent collection 是线程安全的, 但不用单一的排斥锁管理. 在ConcurrentHashMap特定情况下,它可以安全地允许任意数量的并发读取以及可调数量的并发写入,当您需要阻止通过一个锁对集合的所有访问时,\"Synchronized\" 非常有用. 以可扩展性较差为代价,在多线程访问公共集合的情况下, 通常优选\"Concurrent\"版本,如果集合不共享,最好使用非同步集合, 大多数异步集合包括队列 java.uti l Iterator 和 Spliterators 提供了弱实现而快速遍历 他们可以与其他业务同时进行 他们永远不会抛出ConcurrentModificationException 它们可以保证在构造时只存在一次元素，并且可以（但不保证）反映构造后的任何修改。 Memory Consistency Properties Chapter 17 of the Java Language Specification defines the happens-before relation on memory operations such as reads and writes of shared variables Java语言规范第17章定义了内存操作上的happens-before关系，比如共享变量的读写 只有当写的操作发生在读的操作之前,一个线程写的结果才可能被另一个线程的读操作看到. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"Concurrent/Executor.html":{"url":"Concurrent/Executor.html","title":"Executor 线程池","keywords":"","body":"多线程 Executor public interface Executor 该接口提供了一个方法, 执行Runnable对象的任务。 提供了一种可以将任务本身和任务的运行机制(包括线程使用, 调度等细节)分离开来的方法 通常使用执行器而不是显试的创建线程。 例如：你不是为每一个任务去创建线程 new Thread(new(RunnableTask())).start()你可以使用 Executor executor = anExecutor; executor.execute(new RunnableTask1()); executor.execute(new RunnableTask2()); ... 然而，Executor 接口并不严格要求执行是异步的，最简单的情况如下，执行程序可以立即在调用者的线程中运行提交的任务。 class DirectExecutor implements Executor { public void execute(Runnable r) { r.run(); } } ExecutorService public interface ExecutorService extends Executor 一个Executor，提供管理终止的方法和可以生成Future以跟踪一个或多个异步任务进度的方法。 ScheduledExecutorService public interface ScheduledExecutorService extends ExecutorService 一个ExecutorService扩展, 可以延迟或者定期执行任务.调度功能。 schedule方法创建具有各种延迟的任务，并返回可用于取消或检查执行的任务对象。scheduleAtFixedRate和scheduleWithFixedDelay方法创建并执行定期运行的任务，直到被取消。 使用Executor.executor(Runnable) 和 ExecutorService.submit() 方法提交任务，请求的延迟为0，允许零延迟或负延迟,并视为请求立即执行 。 Usage Example Here is a class with a method that sets up a ScheduledExecutorService to beep every ten seconds for an hour: import static java.util.concurrent.TimeUnit.*; class BeeperControl { private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1); public void beepForAnHour() { final Runnable beeper = new Runnable() { public void run() { System.out.println(\"beep\"); } }; final ScheduledFuture beeperHandle = scheduler.scheduleAtFixedRate(beeper, 10, 10, SECONDS); scheduler.schedule(new Runnable() { public void run() { beeperHandle.cancel(true); } }, 60 * 60, SECONDS); } } Executors 用于在此包中定义的Executor、ExecutorService、ScheduledExecutorService、ThreadFactory和Callable类的工厂和实用方法 Methods that create and return an ExecutorService set up with commonly useful configuration settings. Methods that create and return a ScheduledExecutorService set up with commonly useful configuration settings. Methods that create and return a \"wrapped\" ExecutorService, that disables reconfiguration by making implementation-specific methods inaccessible. Methods that create and return a ThreadFactory that sets newly created threads to a known state. Methods that create and return a Callable out of other closure-like forms, so they can be used in execution methods requiring Callable. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"Concurrent/Queue.html":{"url":"Concurrent/Queue.html","title":"Queue 队列","keywords":"","body":"队列 BlockingQueue 一个队列，它还支持在检索元素时等待队列变为非空的操作，以及在存储元素时等待队列中的空间变为可用的操作。 它的方法有四种形式, 有不同的方式来处理不能立即返回但可能在以后某个时候返回: 一种抛出异常,第二种返回一个特殊值(null或false,取决于操作),第三种线程无限期阻塞当前线程，直到操作成功为止,第四种只有当超出了给定的最大时限内才会放弃 Throws exception Special value Blocks Times out Insert add(e) offer(e) put(e) offer(e, time, unit) Remove remove() poll() take() poll(time, unit) Examine element() peek() not applicable not applicable 默认的容量为 Integer.MAX_VALUE 队列比支持 null BlockingQueue实现是线程安全的 BlockingQueue本质上不支持任何“关闭”或“关闭”操作，以指示不再添加任何项。这些特性的需求和使用往往依赖于实现 ConcurrentLinkedQueue 基于链接节点的无界线程安全队列 FIFO(先进先出), 不允许使用空元素。 许多线程共享对公共集合的访问时，ConcurrentLinkedQueue是一个合适的选择. 迭代器是弱一致的,反映队列在迭代器创建时或创建后某个时点的状态的元素。它们不会抛出ConcurrentModificationException，并且可以与其他操作并发进行。自创建迭代器以来，队列中包含的元素将只返回一次。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"Concurrent/Conllection.html":{"url":"Concurrent/Conllection.html","title":"数据结构","keywords":"","body":"多线程的数据结构 ConcurrentHashMap 一个支持异步检索和高预期并发更新的哈希表. 这个类和HashTable遵循相同的规范，并且包含了Hashtable每个方法相对应的版本。 每一个操作都是线程安全的，检索操作不需要锁定,而且锁定整张表组织其他的访问 检索操作通常不会阻塞, 因此可能与更新操作重叠。(同一个键的更新操作与获取操作具有happens-before关系) Iterators，Spliterators和Enumerations在迭代器/枚举的创建时或之后的某个时刻返回反映哈希表状态的元素。 它们不会抛出ConcurrentModificationException。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"JVM/Memory_Consistency_Properties.html":{"url":"JVM/Memory_Consistency_Properties.html","title":"JVM","keywords":"","body":"Memory Consistency Properties Java语言规范第17章(Chapter 17 of the Java Language Specification)定义了内存操作上的happens-before关系，比如共享变量的读写 如果A动作发生在B动作之前，可标记为 hb(A,B) 一个线程中的写操作与另一个线程中的读操作在数据竞争中可能出现顺序错误。happens-before关系定义了什么时候发生数据竞争。 在变量r 读取V的值时观察到w在写V的值,根据happens-before原则: r 没有排在w之前，即它不是hp(r,w) w 还没有写入 v r读取的时候允许看到w写的结果 在happens-before一致的操作集中，每次读取都会看到一个允许它看到的写入happens-before ordering For the trace in Table 17.5, initially A == B == 0. The trace can observe r2 == 0 and r1 == 0 and still be happens-before consistent, since there are execution orders that allow each read to see the appropriate write. Table 17.5. Behavior allowed by happens-before consistency, but not sequential consistency. Thread 1 Thread 2 B = 1; A = 2; r2 = A; r1 = B; Since there is no synchronization, each read can see either the write of the initial value or the write by the other thread. An execution order that displays this behavior is: 1: B = 1; 3: A = 2; 2: r2 = A; // sees initial write of 0 4: r1 = B; // sees initial write of 0 Another execution order that is happens-before consistent is: 1: r2 = A; // sees write of A = 2 3: r1 = B; // sees write of B = 1 2: B = 1; 4: A = 2; In this execution, the reads see writes that occur later in the execution order. This may seem counterintuitive, but is allowed by happens-before consistency. Allowing reads to see later writes can sometimes produce unacceptable behaviors. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"Guava/":{"url":"Guava/","title":"Guava","keywords":"","body":"Guava Guava是一种基于开源的Java库，其中包含谷歌正在由他们很多项目使用的很多核心库。这个库是为了方便编码，并减少编码错误。这个库提供用于集合，缓存，支持原语，并发性，常见注解，字符串处理，I/O和验证的实用方法 缓存工具 Guava Cache Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-25 23:22:07 "},"Guava/Cache.html":{"url":"Guava/Cache.html","title":"Cache","keywords":"","body":"Guava Cache Maven 依赖 com.google.guava guava 18.0 例子 延时缓存 指定缓存条目的有效期5分钟, 缓存数量最多不超过1000个, 如果超出,缓存清除那些不经常使用的条目. import com.google.common.cache.Cache; import com.google.common.cache.CacheBuilder; ... public static Cache cache = CacheBuilder .newBuilder() .expireAfterWrite(5,TimeUnit.MINUTES) .maximumSize(1000).build(); // 插入 cache.put(key, value); // 获取 cache.getIfPresent(key); // 移除 cache.invalidate(key); ... Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-25 23:22:07 "},"SpringBoot/SpringBoot.html":{"url":"SpringBoot/SpringBoot.html","title":"Spring Boot","keywords":"","body":"Spring Boot Spring Boot 轻松创建一个独立的,工业级的Spring 应用, 可以\"直接运行\". 我们对Spring 平台,和第三方依赖库有着自己的见解,因此你可以减少开始的麻烦,大多数SpringBoot程序只需要很少的配置. @EnableAutoConfiguration 这个注解告诉SpringBoot 根据项目中添加的依赖,\"猜测\"你希望如何配置Spring, main 方法 public static void main(String[] args) { SpringApplication.run(Example.class, args); } main 方法是Java程序的入口, Spring Boot 主程序执行SpringApplication的run方法启动程序, 启动Spring 等等操作, Example.class 参数是为了告诉SpringApplication 哪个是Spring的主模块, args参数是为了处理命令行的参数。 运行SpringBoot 项目 mvn spring-boot:run 创建可执行jar文件（又称 “胖jar”） 我们需要在 pom.xml 文件中 dependencies 片段后面添加spring-boot-maven-plugin org.springframework.boot spring-boot-maven-plugin 运行mvn package命令，打成jar包。 如果你想查看jar的内部，使用 jar tvf target/myproject-0.0.1-SNAPSHOT.jar 命令。 使用 java -jar 命令运行jar包。 您还应该看到一个名为myproject-0.0.1- snap .jar的小得多的文件。原始文件在目标目录中。这是Maven在Spring Boot重新打包之前创建的原始jar文件 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"SpringBoot/Using.html":{"url":"SpringBoot/Using.html","title":"Spring Boot 使用","keywords":"","body":"Spring Boot 的使用 项目结构 使用“default” Package 如果一个类不声明package， 它就被认为在 default package 中。 定位程序主类 默认推荐将启动类放在根目录中，高于其他的类。 @SpringBootApplication 注解放在主类上面，它还隐式的定义基础的所要扫描的包。 如果你不想用@SpringBootApplication， 可以使用@EnableAutoConfiguration 和 @ComponentScan 注解来定义这些。 典型的布局结构 com +- example +- myapplication +- Application.java | +- customer | +- Customer.java | +- CustomerController.java | +- CustomerService.java | +- CustomerRepository.java | +- order +- Order.java +- OrderController.java +- OrderService.java +- OrderRepository.java 配置类 Spring Boot 支持 java类配置和xml同事配置， 在配置类使用一个@Configuration， 通常定义 main 方法的主类很适合使用@Configuration。 导入其他配置类 你不需要将所有的@Configuration放入一个类中， @Import 注解能够用来加入配置类，或者，您可以使用@ComponentScan自动获取所有包括 @Configuration 类的Spring组件 导入XML配置 如果你必须要使用xml配置，我们建议您仍然从@Configuration类开始，你可以使用一个@ImportResource 注解加载xml配置文件。 自动配置 禁用特定的自动配置类 您可以使用@EnableAutoConfiguration的exclude属性禁用它们，如下面的示例所示: import org.springframework.boot.autoconfigure.*; import org.springframework.boot.autoconfigure.jdbc.*; import org.springframework.context.annotation.*; @Configuration @EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class}) public class MyConfiguration { } Spring Bean 和 依赖注入 您可以自由地使用任何标准Spring框架技术来定义bean及其注入的依赖项。为了简单起见，我们经常发现使用@ComponentScan(查找bean)和使用@Autowired(执行构造函数注入)工作得很好。 如果按照上面的建议构造代码(将应用程序类定位在根包中)，可以添加@ComponentScan，而不需要任何参数。所有应用程序组件(@Component、@Service、@Repository、@Controller等)都自动注册为Spring bean。 注意使用构造注入的bean 使用final 防止被更改。 使用@SpringBootApplication注解 使用一个@SpringBootApplication注释来启用这三个特性，即: @EnableAutoConfiguration: enable Spring Boot’s auto-configuration mechanism • @ComponentScan: enable @Component scan on the package where the application is located (see the best practices) • @Configuration: allow to register extra beans in the context or import additional configuration classes @SpringBootApplication还提供别名来定制@EnableAutoConfiguration和@ComponentScan的属性 这些特性都不是强制性的，您可以选择用它支持的任何特性替换这个注释。例如，你可能不想在你的应用程序中使用组件扫描: package com.example.myapplication; import org.springframework.boot.SpringApplication; import org.springframework.context.annotation.ComponentScan import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Import; @Configuration @EnableAutoConfiguration @Import({ MyConfig.class, MyAnotherConfig.class }) public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 开发工具 添加开发依赖 org.springframework.boot spring-boot-devtools true 开发依赖将在打包时关闭，并且用java -jar 运行时认为是生产环境，会自动关闭。 若要手动关闭，请设置Dspring.devtools.restart.enabled=false 属性 自动重启 类路径上的文件发生更改，将会自动重启，静态资源或模板发生更改，不会重启， 触发自动重启的唯一方法是更新类路径， Eclipse 自动更新， ide需要build 排除一些资源变动，不重启 spring.devtools.restart.exclude=static/,public/ 远程开发 需要添加插件 org.springframework.boot spring-boot-maven-plugin false 然后需要设置spring.devtools.remote.secret属性，如下面的示例所示: spring.devtools.remote.secret=mysecret 存在安全风险，不建议用在生产服务器上。 远程开发工具由两部分提供支持，接受连接的服务器端端点和在IDE中运行的客户机应用程序。当设置spring.devtools.remote.secret属性时，服务器组件将自动启用。客户端组件必须手动启动。 jar包部署至远程服务器 在服务器上运行jar包，address=5005 是调试端口 java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 demo-0.0.1-SNAPSHOT.jar IDE 上开启远程调试 只需要输入主机地址和调试端口即可热更新和调试，实现本地开发，远程运行，降低对开发电脑的资源占用。 运行远程客户端程序 远程客户端程序被设计运行在IDE，您需要运行org.springframework.boot.devtools.RemoteSpringApplication，其类路径与您连接到的远程项目相同，应用程序唯一需要的参数是它连接到的远程URL。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"SpringBoot/SpringApplication.html":{"url":"SpringBoot/SpringApplication.html","title":"SpringApplication","keywords":"","body":"Spring Boot 特征 SpringApplication 启动特征 当启动失败时， 注册的 FailureAnalyzers 提供专用的错误消息和修复问题的具体操作。 Spring Boot提供了许多FailureAnalyzer实现，您可以添加自己的实现。 运行jar包启动 debug属性 $ java -jar myproject-0.0.1-SNAPSHOT.jar --debug 自定义 Banner 默认加载classpath下的banner.txt(或.gif.jpg.png),指定banner位置： spring.banner.location 属性 禁用Bannner显示,注意off的“”： spring: main: banner-mode: \"off\" 定制SpringApplication 如果你不喜欢SpringApplication的默认属性，你可以创建一个本地实例定制它，下面的示例关闭banner public static void main(String[] args) { SpringApplication app = new SpringApplication(MySpringConfiguration.class); app.setBannerMode(Banner.Mode.OFF); app.run(args); } 传递给SpringApplication的构造函数参数是Spring bean的配置源。在大多数情况下，这些是对@Configuration类的引用，但也可以是对XML配置或应该扫描的包的引用 也可以通过使用应用程序来配置spring应用程序属性文件。 链式调用API 如果你需要构建一个ApplicationContext可以使用SpringApplicationBuilder，允许您将多个方法调用链接在一起。如下所示 new SpringApplicationBuilder() .sources(Parent.class) .child(Application.class) .bannerMode(Banner.Mode.OFF) .run(args) 事件监听器 Note 有些事件实际上是在创建ApplicationContext之前触发的，因此您不能将侦听器注册为@Bean,您可以使用springapplication . addlistener(…)方法或springapplicationbuilder .listener(…)方法注册它们.如果希望自动注册这些侦听器,不管应用程序是如何创建的,你可以再你的程序中添加META-INF/spring.factories 文件，通过使用org.springframework.context.ApplicationListener作为KEY。例如： org.springframework.context.ApplicationListener=com.example.project.MyListener 当应用程序运行时，应用程序事件按以下顺序执行： ApplicationStartingEvent 最先执行, 除了注册监听器执行之外。 ApplicationEnvironmentPreparedEvent是在上下文环境Environment被创建之前 ApplicationPreparedEvent 在启动之前，但在Bean加载之后。 ApplicationStartedEvent在上下文创建之后，但在执行任何程序之前。 在调用任何应用程序和命令行运行程序之后，都会发送一个ApplicationReadyEvent。它表明应用程序已经准备好为请求提供服务。 如果启动时出现异常，则发送ApplicationFailedEvent. Web 环境 SpringApplication 尝试创建正确的ApplicationContext,用于确定WebApplicationType的算法非常简单 如果 SpringMVC存在，则使用AnnotationConfigServletWebServerApplicationContext。 如果Spring MVC不存在，而Spring WebFlux存在，则使用AnnotationConfigReactiveWebServerApplicationContext 其他情况下使用 AnnotationConfigApplicationContext 这意味着，如果您在同一个应用程序中使用Spring MVC和Spring WebFlux中的新WebClient，默认情况下将使用Spring MVC。您可以通过调用setWebApplicationType(WebApplicationType)轻松地覆盖它。 还可以通过调用setApplicationContextClass()来完全控制ApplicationContext类型。 在JUnit测试中使用SpringApplication时，通常需要调用setWebApplicationType(WebApplicationType.NONE)。 访问程序的参数 如果你需要访问传递个SpringApplication.run(...) 的参数，可以通过注入org.springframework.boot.ApplicationArguments实现，ApplicationArguments接口提供了参数String[]，和包含非包含的选项，例如： import org.springframework.boot.*; import org.springframework.beans.factory.annotation.*; import org.springframework.stereotype.*; @Component public class MyBean { @Autowired public MyBean(ApplicationArguments args) { boolean debug = args.containsOption(\"debug\"); List files = args.getNonOptionArgs(); // if run with \"--debug logfile.txt\" debug=true, files=[\"logfile.txt\"] } } Spring Boot还向Spring环境注册了一个CommandLinePropertySource。这还允许您通过使用@Value注释注入单个应用程序参数 使用ApplicationRunner 或 CommandLineRunner 如果你希望在SpringBoot程序启动时运行一些特定的代码，你可以实现接口ApplicationRunner or CommandLineRunner，这两个接口之提供一个run方法，SpringApplication.run(...)方法执行前调用。 CommandLineRunner接口以简单的字符串数组的形式提供对应用程序参数的访问，而ApplicationRunner使用前面讨论的ApplicationArguments接口。 import org.springframework.boot.*; import org.springframework.stereotype.*; @Component public class MyBean implements CommandLineRunner { public void run(String... args) { // Do something... } } 退出程序 每个SpringApplication都会向JVM注册一个关闭钩子，以确保ApplicationContext在退出时正常关闭。可以使用所有标准的Spring生命周期回调（例如DisposableBean接口或@PreDestroy注释）。 管理员特性 通过指定spring.application.admin.enabled属性，可以为应用程序启用与管理相关的功能。这会在平台MBeanServer上公开SpringApplicationAdminMXBean。您可以使用此功能远程管理Spring Boot应用程序。 此功能对于任何服务包装器实现也很有用。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"SpringBoot/ExternalizedConfiguration.html":{"url":"SpringBoot/ExternalizedConfiguration.html","title":"外部配置","keywords":"","body":"Spring Boot 特征 外部化配置 您可以使用properties文件、YAML文件、环境变量和命令行参数来具体化配置,属性值可以通过使用@Value注释直接注入到bean中, Spring的 Environment 抽象，或者通过@ConfigurationProperties绑定到结构化对象. Spring Boot使用一种非常特殊的PropertySource顺序，其设计目的是允许合理地覆盖值。属性按以下顺序考虑: 主目录上的Devtools全局设置属性(~/.spring-bootdevtools)。激活devtools时的属性)。 @TestPropertySource注释 测试下的properties属性. 用在@SpringBootTest等测试注解 命令行参数 来自SPRING_APPLICATION_JSON(嵌入到环境变量或系统属性中的内联JSON)的属性 ServletConfig 初始化参数 ServletContext初始化参数 太多了,不想写了(略) 获取属性值,如下所示 import org.springframework.stereotype.*; import org.springframework.beans.factory.annotation.*; public class MyBean { @Value(\"${name}\") private String name; // ... } 在程序的类路径,创建application.properties 文件,定义name的值.在新环境中,可以在jar包之外覆盖name的值,做一次性测试,例如: 运行指定的命令 java -jar app.jar --name=\"Spring\" Tip 在环境变量上指定SPRING_APPLICATION_JSON 属性,例如在unix中使用: $ SPRING_APPLICATION_JSON='{\"acme\":{\"name\":\"test\"}}' java -jar myapp.jar 您还可以将JSON作为spring.application提供。系统属性中的json，如下例所示: $ java -Dspring.application.json='{\"name\":\"test\"}' -jar myapp.jar 您还可以使用命令行参数提供JSON，如下面的示例所示: $ java -jar myapp.jar --spring.application.json='{\"name\":\"test\"}' 您还可以提供JSON作为JNDI变量，如下所示: java:comp/env/ spring.application.json。 配置随机数 例: my.secret=${random.value} my.number=${random.int} my.bignumber=${random.long} my.uuid=${random.uuid} my.number.less.than.ten=${random.int(10)} my.number.in.range=${random.int[1024,65536]} 访问命令行属性 命令行参数使用 -- 开始, 例如 --server.port=9000, 命令行参数将作为一个属性添加到环境中,如前所述，命令行属性始终优先于其他属性源。 如果你不想使用命令行属性源,关闭方法如下: SpringApplication.setAddCommandLineProperties(false). 属性文件 SpringApplication 从application.properties文件加载属性添加它们到环境中. 从如下几个地方进行加载: /config目录下 当前目录中 类路径的 /config 包 类路径的根目录下 列表按优先级排序,在列表中较高位置定义的属性覆盖在较低位置定义的属性. 你可以使用 .yml作为.properties的替代 自定义要加载的配置文件的名称使用spring.config.name 属性: $ java -jar myproject.jar --spring.config.name=myprojec 指定配置文件的位置: $ java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/ override.properties 警告: spring.config.name 和 spring.config.location 属性用来指定配置文件的名称和位置,所以它们必须被定义为环境属性,定义成系统环境变量,作为一个系统属性或者命令行参数 特殊的配置属性 profile 使用以下命名约定:application-{profile}.properties, 环境中有一个默认的profile ([default]),在没有设置profile的时候使用,换句话说,如果不指定 profile,则使用 application-default.properties. 特定属性和application.properties的加载位置相同, 特定属性的配置文件总是覆盖非特定的属性文件,不管特定于概要文件的文件是在打包的jar内部还是外部。 占位符属性 示例: app.name=MyApp app.description=${app.name} is a Spring Boot application 加密属性 Spring Boot不提供任何内置的对属性值加密的支持，但是它提供了修改Spring环境中包含的值所必需的挂钩点。Environment postprocessor接口允许您在应用程序启动之前操作Environment. 如果您正在寻找一种安全的方式来存储凭证和密码，Spring Cloud Vault项目提供了在HashiCorp Vault中存储外部化配置的支持。 使用YAML代替属性 YAML是JSON的一个超集，因此是指定分层配置数据的一种方便的格式。当您的类路径上有SnakeYAML库时，SpringApplication类自动支持YAML作为属性的替代。 如果您使用“starter”，SnakeYAML将由spring-boot-starter自动提供 加载YAML YAML 属性文档: environments: dev: url: https://dev.example.com name: Developer Setup prod: url: https://another.example.com name: My Cool App 转为properties如下 environments.dev.url=https://dev.example.com environments.dev.name=Developer Setup environments.prod.url=https://another.example.com environments.prod.name=My Cool App YAML 的数组 my: servers: - dev.example.com - another.example.com 对应的properties: my.servers[0]=dev.example.com my.servers[1]=another.example.co 使用@ConfigurationProperties 注解绑定到对应的实体类上面,如: @ConfigurationProperties(prefix=\"my\") public class Config { private List servers = new ArrayList(); public List getServers() { return this.servers; } } 在Spring环境中将YAML属性公开 可以使用@Value注释和占位符语法访问YAML属性 YAML 文档的多文件 您可以使用spring在一个文件中指定多个特定于概要文件的YAML文档。配置文件键，指示文档何时应用，如下例所示 server: address: 192.168.1.100 -- spring: profiles: development server: address: 127.0.0.1 -- spring: profiles: production & eu-central server: address: 192.168.1.120 在上面的例子中,如果prifiles 是 development,服务器的地址则是127.0.0.1 如果 production 和 eu-central profiles 是活跃的,则服务器地址是192.168.1.120,如果不活跃,地址则是192.168.1.100. 我们为spring.security.user设置了一个值。只有在“默认”配置文件中可用的密码: server: port: 8000 -- spring: profiles: default security: user: password: weak 然而，在下面的例子中，密码总是被设置，因为它没有附加到任何配置文件中，而且它必须在所有其他配置文件中根据需要显式重置: server: port: 8000 spring: security: user: password: weak YAML 缺点 无法使用@PropertySource注释加载YAML文件。因此，在需要以这种方式加载值的情况下，需要使用属性文件。 在特定于概要文件的YAML文件中使用多YAML文档语法可能导致意外行为。例如，在一个名为application-dev.yml的文件中考虑以下配置。dev配置文件处于活动状态 server: port: 8000 -- spring: profiles: !test security: user: password: weak 在上面的示例中，概要文件否定和概要文件表达式的行为与预期不同。我们建议您不要组合特定于概要文件的YAML文件和多个YAML文档，坚持只使用其中一个. 类型安全的属性配置 对于复杂的pojo获取属性,@Value(\"${property}\") 过于笨重. @ConfigurationProperties(\"acme\") public class AcmeProperties { private boolean enabled; private InetAddress remoteAddress; private final Security security = new Security(); 最后，只考虑标准Java Bean属性，不支持绑定静态属性. 您还需要列出要在@EnableConfigurationProperties注释中注册的属性类，如下面的示例所示: @ConfigurationProperties 验证 当使用了@Validate注释的时候, 在自动注入的时候都会进行验证.例如: @ConfigurationProperties(prefix=\"acme\") @Validated public class AcmeProperties { @NotNull private InetAddress remoteAddress; // ... getters and setters } @ConfigurationProperties 对比 @Value Feature @ConfigurationProperties @Value Relaxed binding Yes No Meta-data support Yes No SpEL evaluation No Yes Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"SpringBoot/Profiles.html":{"url":"SpringBoot/Profiles.html","title":"Profiles","keywords":"","body":"Profiles Spring概要文件提供了一种方法来隔离应用程序配置的各个部分，并使其仅在某些环境中可用。任何@Component或@Configuration都可以用@Profile标记， @Configuration @Profile(\"production\") public class ProductionConfiguration { // ... } 你可以使用spring.profiles.active Environment属性来指定活动的profiles,类如在application.properties中指定: spring.profiles.active=dev,hsqldb 也可以在命令行指定: --spring.profiles.active=dev,hsqldb 添加 Profiles 有时候,我们指定Profiles并不是为了替换掉配置文件,而是需要添加新的配置进来,我们需要: -- my.property: fromyamlfile -- spring.profiles: prod spring.profiles.include: - proddb - prodmq 通过代码添加Profiles文件 SpringApplication.setAdditionalProfiles(…) Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"SpringBoot/Logging.html":{"url":"SpringBoot/Logging.html","title":"日志Logging","keywords":"","body":"日志 SpringBoot 使用Logback记录日志,同时也支持其他的日志实现,如Log4j2 控制台输出 默认为 ERROR,WARN,INFO级别信息输出日志,也可以使用 --debug 标记开启debug模式. java -jar myapp.jar --debug 输入到文件 默认情况,SpringBoot只会将日志输出到控制台. 如果要打印到文件中, 需要设置logging.file 或者 logging.path属性. 日志级别 level 有 TRACE, DEBUG, INFO, WARN, ERROR, FATAL, or OFF. 下面的示例显示application.properties中的潜在日志设置 logging.level.root=WARN logging.level.org.springframework.web=DEBUG logging.level.org.hibernate=ERROR Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"SpringBoot/Internationalization.html":{"url":"SpringBoot/Internationalization.html","title":"国际化","keywords":"","body":"国际化 Spring Boot支持本地化消息，因此您的应用程序可以满足不同语言首选项的用户。默认情况下，Spring Boot在类路径的根目录中查找消息资源包的存在。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"SpringBoot/DevelopingWebApplication.html":{"url":"SpringBoot/DevelopingWebApplication.html","title":"Web应用开发","keywords":"","body":"Web应用程序开发 SpringBoot 非常适合开发Web程序开发,大多数web应用程序都使用springboot-starter-web模块快速开发,你也可以选择使用spring-boot-starter-webflux 模块构建响应式Web应用. Spring Web MVC Framework Spring Web MVC 框架(简称 Spring MVC) 是一个富\"model view controller\" 的web框架, Spring MVC 让你创建特定的@Controller 或 @RestController 的beans 来处理Http请求,控制器中的方法通过使用@RequestMapping注释映射到HTTP. 下面是一个典型的提供JSON数据的@RestController @RestController @RequestMapping(value=\"/users\") public class MyRestController { @RequestMapping(value=\"/\\{user}\", method=RequestMethod.GET) public User getUser(@PathVariable Long user) { // ... } @RequestMapping(value=\"/\\{user}/customers\", method=RequestMethod.GET) List getUserCustomers(@PathVariable Long user) { // ... } @RequestMapping(value=\"/\\{user}\", method=RequestMethod.DELETE) public User deleteUser(@PathVariable Long user) { // ... } } Spring MVC 自动配置 Spring Boot为Spring MVC提供了自动配置，可以很好地与大多数应用程序配合使用。 自动配置在Spring的默认值之上添加了以下特性: 包含ContentNegotiatingViewResolver 和BeanNameViewResolver 支持提供静态资源访问, 支持WebJars 自动注册 Converter, GenericConverter和Formatter 支持HttpMessageConverters 自动注册MessageCodesResolver 支持静态页 index.html 支持自定义图标 自动使用ConfigurableWebBindingInitializer 如果你想保留MVC特点并且添加MVC配置(拦截器,格式化,视图解析器和其他功能),你可以使用自己的@Configuration类定义WebMvcConfigurer,但是不包括 @EnableWebMvc 如果您想完全控制Spring MVC，您可以添加自己的@Configuration，并使用@EnableWebMvc进行注释。 Http消息转换器 将对象转为JSON或XML,默认使用UTF-8编码. 自定义转换器: import org.springframework.boot.autoconfigure.http.HttpMessageConverters; import org.springframework.context.annotation.*; import org.springframework.http.converter.*; @Configuration public class MyConfiguration { @Bean public HttpMessageConverters customConverters() { HttpMessageConverter additional = ... HttpMessageConverter another = ... return new HttpMessageConverters(additional, another); } } 自定义JSON序列号和反序列化器 import java.io.*; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import org.springframework.boot.jackson.*; @JsonComponent public class Example { public static class Serializer extends JsonSerializer { // ... } public static class Deserializer extends JsonDeserializer { // ... } } 静态资源 默认情况下,SpringBoot静态资源目录为ervletContext的根路径下的/static(或 /public 或 /resources 或 /META-INF/resources). 设置静态资源访问url: spring.mvc.static-path-pattern=/resources/* 设置静态资源位置: spring.resources.staticlocations 欢迎页 它首先在配置的静态内容位置中查找index.html文件,如果没有找到，则查找index模板,它被自动用作应用程序的欢迎页面。 自定义网站图标 SpringBoot从已配置的静态资源目录和根目录查找favicon.ico,如果存在,自动使用作为程序图标. 路径匹配和内容协议 SpringMVC将HTTP请求映射到方法上, SpringBoot默认禁用后缀,意味着\"GET /projects/spring-boot.json\" 不会匹配到 @GetMapping(\"/projects/ spring-boot\" 模板引擎 除了REST web服务，您还可以使用Spring MVC来提供动态HTML内容. SpringBoot支持的模板引擎有JSP,以及 • FreeMarker • Groovy • Thymeleaf • Mustache TIP 如果可能,尽量避免使用JSP 如果使用模板引擎,自动从src/main/resources/templates位置加载模板,您可以配置模板前缀来搜索类路径上的每个模板目录，如下所示:classpath*:/templates/ 错误处理 SpringBoot默认提供/error映射处理错误,注册一个全局的错误页面,对于机器客户机，它生成一个JSON响应，其中包含错误的详细信息,HTTP状态和异常消息,对于浏览器客户机，有一个“whitelabel”错误视图，它以HTML格式呈现相同的数据(若要自定义，请添加一个可解析为/error的视图),如果要完全替换默认的错误处理机制,可以实现一个ErrorController并注册,或者添加ErrorAttributes以实现现有机制. BasicErrorController可以用作自定义ErrorController的基类。如果您想为新的内容类型添加一个处理程序(默认情况下是专门处理文本/html，并为其他所有内容提供一个回退)，那么这尤其有用。为此，扩展BasicErrorController，添加一个带有@RequestMapping的公共方法，该方法具有produces属性，并创建一个新类型的bean。 自定义错误页面 404 页面文件位置 src/ +- main/ +- java/ | + +- resources/ +- public/ +- error/ | +- 404.html +- 所有5xx页面,错误页面模板 src/ +- main/ +- java/ | + +- resources/ +- templates/ +- error/ | +- 5xx.ftl +- Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"SpringBoot/Security.html":{"url":"SpringBoot/Security.html","title":"安全","keywords":"","body":"Security 安全 如果将Spring Security依赖加入, web应用默认保护,Spring Boot依赖于Spring Security的内容协商策略来决定是使用httpBasic还是formLogin。要向web应用程序添加方法级安全性，还可以使用所需的设置添加@EnableGlobalMethodSecurity。 默认得UserDetailsService 只有一个用户, 用户名user,密码随机打印到INFO级别的日志中,显示如下: Using generated security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35 自定义用户和密码: spring.security.user.name 或 spring.security.user.password DefaultAuthenticationEventPublisher 用于发布默认验证事件. 你也可以提供一个自定义的AuthenticationEventPublisher MVC Security 默认的安全配置在SecurityAutoConfiguration和UserDetailsServiceAutoConfiguration中实现。SecurityAutoConfiguration导入用于web安全的SpringBootWebSecurityConfiguration, UserDetailsServiceAutoConfiguration配置身份验证.也与非web应用程序相关.完全关闭默认的web应用程序安全配置,您可以添加WebSecurityConfigurerAdapter类型的bean(这样做不会禁用UserDetailsService配置或执行器的安全性) 详见SpringSecurity OAuth2.0 客户端 略 OAuth2.0 资源服务器 略 OAuth2.0 授权服务器 目前，Spring Security不支持实现OAuth 2.0授权服务器。然而，Spring Security OAuth项目提供了此功能，最终将被Spring Security完全取代。在此之前，您可以使用spring-security-oauth2autoconfigure模块轻松设置OAuth 2.0授权服务器;有关说明，请参阅其文档。 Actuator Security 为了安全目的,除了/health 和 /info 其他制动器默认是关闭的,management.endpoints.web.exposure。include属性可用于启用执行器 CSRF防护(Cross Site Request Forgery ) 于Spring Boot依赖于Spring Security的默认值，所以CSRF保护在默认情况下是打开的。这意味着，当使用默认安全配置时，执行器端点需要POST (shutdown和loggers端点)、PUT或DELETE将得到403禁止错误! 我们建议，只有在创建非浏览器客户端使用的服务时，才完全禁用CSRF保护 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"SpringBoot/DataSource.html":{"url":"SpringBoot/DataSource.html","title":"SQL数据库配置","keywords":"","body":"SQL数据库配置 传统上,“数据源”使用URL和一些凭据来建立数据库连接。 嵌入式数据库 使用内存内嵌入式数据库开发应用程序通常很方便,内存数据库不提供持久性存储,您需要在应用程序启动时填充数据库，并准备在应用程序结束时丢弃数据,Spring Boot可以自动配置嵌入式H2、HSQL和Derby数据库。您不需要提供任何连接url。只需要包含对要使用的嵌入式数据库的构建依赖项。 典型的POM依赖如下 org.springframework.boot spring-boot-starter-data-jpa org.hsqldb hsqldb runtime 要自动配置嵌入式数据库，需要依赖spring-jdbc。在本例中，它通过spring-boot-starter-data-jpa被临时拉入。 无论出于什么原因，如果您确实为嵌入式数据库配置了连接URL，请确保禁用了数据库的自动关闭。如果使用H2，则应该使用DB_CLOSE_ON_EXIT=FALSE。如果使用HSQLDB，应该确保没有使用shutdown=true。禁用数据库的自动关闭允许Spring在数据库关闭时启动控制，从而确保不再需要访问数据库时启动控制。 连接至生产数据库 连接池选择算法: 我们更喜欢HikariCP的性能和并发性。如果有HikariCP，我们总是选择它 否则，如果Tomcat池数据源可用，我们就使用它。 如果HikariCP和Tomcat池数据源都不可用，如果Commons DBCP2可用，我们就使用它。 如果您使用spring-boot-starter-jdbc或spring-boot-starter-data-jpa“starter”，您将自动获得对HikariCP的依赖。 您可以完全绕过该算法，并通过设置spring.datasource.type 指定要使用的连接池,如果在Tomcat容器中运行应用程序，这一点尤其重要，因为默认情况下提供了Tomcat -jdbc。 TIP 额外的连接池始终可以手动配置。如果定义了自己的数据源bean，则不会发生自动配置。 数据源配置由spring.datasource.*中的外部配置属性控制。例如，您可以在application.properties中声明以下部分: spring.datasource.url=jdbc:mysql://localhost/test spring.datasource.username=dbuser spring.datasource.password=dbpass spring.datasource.driver-class-name=com.mysql.jdbc.Driver 您至少应该通过设置spring.datasource.url属性。否则，Spring Boot将尝试自动配置嵌入式数据库 通常不需要指定驱动程序类名，因为Spring Boot可以从url推断出大多数数据库的驱动程序类名。 数据源创建的时候,需要确定数据库驱动是可用的,换句话说,如果你设置了spring.datasource.driver-class-name=com.mysql.jdbc.Driver,就要确保这个类是存在的. DataSourceProperties 提供了连接池的更多配置属性, 除了通用的属性,还可以使用它们各自的前缀微调特定于实现的设置(spring.datasource.hikari., spring.datasource.tomcat., and spring.datasource.dbcp2.*). 例如使用了Tomcat连接池,你需要这样定义: # Number of ms to wait before throwing an exception if no connection is available. spring.datasource.tomcat.max-wait=10000 # Maximum number of active connections that can be allocated from this pool at the same time. spring.datasource.tomcat.max-active=50 # Validate the connection before borrowing it from the pool. spring.datasource.tomcat.test-on-borrow=true 使用JdbcTemplate JdbcTemplate 和 NamedParameterJdbcTemplate 类是自动配置的,你可以使用 @Autowire 自动导入到你的项目中 您可以使用spring.jdbc.template.*自定义模板的一些属性，如下面的例子所示 spring.jdbc.template.max-rows=500 JPA 和 Spring Data JPA Java Persistence API 是一个允许将对象“映射”到关系数据库的标准技术。spring-boot-starter-data-jpa POM提供快速开始,它提供了关键的依赖如下 Hibernate Spring Data JPA:使基于jpa的存储库易于实现。 Spring ORMs: 来自Spring框架的核心ORM支持。 具体请参考Spring Data 或 Spring Data JPA 实体类 SpringBoot会扫描package中的实体类(用@EnableAutoConfiguration或@SpringBootApplication注释的)考虑使用@Entity、@Embeddable或@MappedSuperclass注释的任何类: package com.example.myapp.domain; import java.io.Serializable; import javax.persistence.*; @Entity public class City implements Serializable { @Id @GeneratedValue private Long id; @Column(nullable = false) private String name; @Column(nullable = false) private String state; // ... additional members, often include @OneToMany mappings protected City() { // no-args constructor required by JPA spec // this one is protected since it shouldn't be used directly } public City(String name, String state) { this.name = name; this.state = state; } public String getName() { return this.name; } public String getState() { return this.state; } // ... etc } 您可以使用@EntityScan注释自定义实体扫描位置 Spring Data JPA 仓库 Spring Data JPA存储库是您可以定义来访问数据的接口,JPA查询是根据您的方法名自动创建的,例如，CityRepository接口可能会声明一个findAllByState(String state) 方法来找出给定状态下的所有城市. 对于更复杂的查询，可以使用Spring Data的@Query注释对方法进行注释. Spring数据存储库通常从存储库或CrudRepository接口扩展,如果使用自动配置，则从包含主配置类的包中搜索存储库. 下面的示例显示了一个典型的Spring数据存储库接口定义 package com.example.myapp.domain; import org.springframework.data.domain.*; import org.springframework.data.repository.*; public interface CityRepository extends Repository { Page findAll(Pageable pageable); City findByNameAndStateAllIgnoringCase(String name, String state); } Spring Data JPA存储库支持三种不同的引导模式: 默认(default)延时加载(deferred) 懒加载(lazy),如果启动了延时加载和懒加载,设置 spring.data.jpa.repositories.bootstrapmode 为 deferred或lazy 详情请查看Spring Data JPA 创建和删除JAP 数据库. 默认情况下，JPA数据库只有在使用嵌入式数据库时才会自动创建 (H2, HSQL, or Derby). 您可以使用spring.jpa.*属性显式地配置JPA设置,例如，要创建和删除表，可以在application.properties中添加以下行: spring.jpa.hibernate.ddl-auto=create-drop 如果您正在运行一个web应用程序，Spring Boot默认注册OpenEntityManagerInViewInterceptor来应用“Open EntityManager in View”模式,以允许在web视图中延迟加载.果不希望出现这种行为，应该将application.properties中的spring. jsp .openin-view设置为false Spring Data JDBC Spring数据包含对JDBC的存储库支持，并将为CrudRepository上的方法自动生成SQL。对于更高级的查询，将提供@Query注释。 它们可以通过spring-bootstarter-data-jdbc的一个依赖项添加到您的项目中. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"SpringBoot/LinuxService.html":{"url":"SpringBoot/LinuxService.html","title":"Linux服务","keywords":"","body":"Linux 服务化部署 官方文档: https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/html/deployment.html#deployment-install 配置Maven插件 org.springframework.boot spring-boot-maven-plugin true 安装为init.d服务 假设你的SpringBoot程序部署在/var/myapp路径，要将SpringBoot程序作为init.d服务，需要创建一个软链接，如下: $ sudo ln -s /var/myapp/myapp.jar /etc/init.d/myapp 安装后，就可以按系统服务的方式启动和停止。例如，在基于debian的系统上，可以使用以下命令启动它: $ service myapp start 日志在/var/log/\\.log中可以查看. FQ spring boot 在Linux下服务启动报错Unable to find Java 将java 连接到/sbin 文件夹下 ln -s /usr/local/jdk/bin/java /sbin/java Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-01-22 13:14:06 "},"SpringSecurity/Security.html":{"url":"SpringSecurity/Security.html","title":"Spring Security","keywords":"","body":"Spring Security Security Java配置-Hello World 该配置创建一个Servlet过滤器，称为springSecurityFilterChain，负责所有安全性(保护应用程序url、验证提交的用户名和密码、重定向到登录表单等),下面是Spring Security Java配置的最基本示例: import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.*; import org.springframework.security.config.annotation.authentication.builders.*; import org.springframework.security.config.annotation.web.configuration.*; @EnableWebSecurity public class WebSecurityConfig implements WebMvcConfigurer { @Bean public UserDetailsService userDetailsService() throws Exception { InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager(); manager.createUser(User.withDefaultPasswordEncoder().username(\"user\").password(\"password\").roles(\"USER\").build()); return manager; } } 这个案例的功能摘要: 应用的每个URL都需要授权. 生成一个登陆表单 允许具有用户名和密码的用户使用基于表单的身份验证进行身份验证 允许用户注销登陆 CSRF 攻击防御 会话重放攻击防御 安全头集成 集成ServletAPI方法 HttpServletRequest#getRemoteUser()) HttpServletRequest.html#getUserPrincipal()) HttpServletRequest.html#isUserInRole(java.lang.String)) HttpServletRequest.html#login(java.lang.String, java.lang.String)) HttpServletRequest.html#logout()) HttpSecurity SpringSecurity 如何知道我们需要对所有用户进行身份验证? SpringSecurity 如何知道我们想要支持基于表单的身份验证?原因是WebSecurityConfigurerAdapter在configure(HttpSecurity http)方法中提供了一个默认配置，如下所示: protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .and() .httpBasic(); } 以上默认配置: 任何请求都需要对用户进行身份验证 允许用户使用基于表单的登录进行身份验证 允许用户使用HTTP基本身份验证进行身份验证 您会注意到，这个配置与XML名称空间配置非常相似: Java配置和表单登陆 提供自定义的登陆页 protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .loginPage(\"/login\") .permitAll(); } 更新后的配置指定登录页面的位置。 我们必须授予所有用户访问登陆页面的权限,formLogin().permitall()方法允许为与基于表单的登录相关联的所有url授予所有用户访问权限。 授权请求 定制授权需求: protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(\"/resources/**\", \"/signup\", \"/about\").permitAll() .antMatchers(\"/admin/**\").hasRole(\"ADMIN\") .antMatchers(\"/db/**\").access(\"hasRole('ADMIN') and hasRole('DBA')\") .anyRequest().authenticated() .and() // ... .formLogin(); } authorizerequests()方法有多个子方法，按照声明它们的顺序考虑每个匹配器。 我们定义了多个URL地址,任何用户都可以访问,很明确,任何人都能访问 /resources/开头的url. 等于 /singup 或者/about 任何以“/admin/”开头的URL都将仅限于具有“ROLEADMIN”角色的用户,您将注意到，由于我们调用hasRole方法，所以不需要指定“ROLE”前缀。 任何以“/db/”开头的URL都要求用户同时具有“ROLEADMIN”和“ROLE_DBA”。您将注意到，由于我们使用hasRole表达式，所以不需要指定“ROLE”前缀。 任何尚未匹配的URL都只需要对用户进行身份验证 注销处理 默认情况下，访问URL /登出将通过以下方式将用户登出: 使HTTP会话无效 清理任何已配置的memorberme身份验证 清理SecurityContextHolder 重定向到 /login?logout 不过，与配置登入功能类似，你也有不同的选择，以进一步自订你的登出要求: protected void configure(HttpSecurity http) throws Exception { http .logout() .logoutUrl(\"/my/logout\") .logoutSuccessUrl(\"/my/index\") .logoutSuccessHandler(logoutSuccessHandler) .invalidateHttpSession(true) .addLogoutHandler(logoutHandler) .deleteCookies(cookieNamesToClear) .and() ... } 提供注销的支持。这在使用WebSecurityConfigurerAdapter时自动应用。 触发登出的URL(默认为/登出)。如果启用了CSRF保护(默认)，那么请求也必须是POST 注销后要重定向到的URL。默认值是/login?logout 让我们指定一个自定义LogoutSuccessHandler。如果指定了这一点，logoutSuccessUrl()将被忽略 指定是否在注销时使HttpSession无效。默认情况下这是正确的。在幕后配置SecurityContextLogoutHandler。 添加一个LogoutHandler。默认情况下，SecurityContextLogoutHandler被添加为最后一个LogoutHandler。 许指定要在注销成功时删除的cookie的名称。这是显式添加CookieClearingLogoutHandler的快捷方式。 授权 到目前为止，我们只看了最基本的身份验证配置。让我们看一下配置身份验证的一些稍微高级一些的选项。 其他认证方式 UserDetailsService 您可以通过将自定义UserDetailsService公开为bean来定义自定义身份验证。例如，假设SpringDataUserDetailsService实现了UserDetailsService，下面将定制身份验证: @Bean public SpringDataUserDetailsService springDataUserDetailsService() { return new SpringDataUserDetailsService(); } 您还可以通过将PasswordEncoder作为bean公开来定制密码的编码方式。例如，如果您使用bcrypt，您可以添加一个bean定义，如下所示: @Bean public BCryptPasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } XML 配置 SpringSecurity Web.xml过滤器配置 springSecurityFilterChain org.springframework.web.filter.DelegatingFilterProxy springSecurityFilterChain /* Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"SpringSecurity/OAuth2.html":{"url":"SpringSecurity/OAuth2.html","title":"OAuth2-Security","keywords":"","body":"OAuth2-SpringSecurity spring-security-oauth2-client.jar: Spring Security 支持OAuth2 认证框架 和 OpenID Connect Core 1.0 OAuth2.0 登陆或客户端支持.上级包是org.springframework.security.oauth2.client。 OAuth 2.0 JOSE - spring-security-oauth2-jose.jar JOSE 框架:Javascript Object Signing and Encryption, JOSE框架旨在提供一种方法来安全的在各方之间转移凭证. 它由一组规范构成. • JSON Web Token (JWT) • JSON Web Signature (JWS) • JSON Web Encryption (JWE) • JSON Web Key (JWK) 它包含顶级包: org.springframework.security.oauth2.jwt org.springframework.security.oauth2.jose ACL - spring-security-acl.jar Specialized domain object ACL implementation. Used to apply security to specific domain object instances within your application. The top-level package is org.springframework.security.acls. CAS - spring-security-cas.jar Spring Security’s CAS client integration. If you want to use Spring Security web authentication with a CAS single sign-on server. The top-level package is org.springframework.security.cas. 单点登陆客户端。 OpenID - spring-security-openid.jar OpenID web身份验证支持。用于根据外部OpenID服务器对用户进行身份验证。org.springframework.security.openid。需要OpenID4Java Test - spring-security-test.jar Support for testing with Spring Security. OAuth2.0 客户端 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"SpringData/SpringDataJdbc.html":{"url":"SpringData/SpringDataJdbc.html","title":"Spring Data","keywords":"","body":"Spring Data Jdbc Spring Data 核心存储库的对象是Respository, 它使用 domain以及ID的类型作为domain类的参数来管理.这个接口主要作为一个标记接口来捕获要使用的类型，并帮助您发现扩展这个接口的接口, CrudRepository为正在管理的实体类提供了复杂的CRUD功能 CrudRepository 接口: public interface CrudRepository extends Repository { S save(S entity); Optional findById(ID primaryKey); Iterable findAll(); long count(); void delete(T entity); boolean existsById(ID primaryKey); // … more functionality omitted. } 我们还提供了特定于持久性技术的抽象，比如JpaRepository或MongoRepository。这些接口扩展了CrudRepository，并公开了底层持久性技术的功能，以及与持久性技术无关的通用接口(如CrudRepository)。 在CrudRepository的上面还有一个PagingAndSortingRepository抽象，它添加了额外的方法来简化对实体的分页访问: PagingAndSortingRepository interface public interface PagingAndSortingRepository extends CrudRepository { Iterable findAll(Sort sort); Page findAll(Pageable pageable); } 要按页面大小20访问用户的第二个页面，可以执行以下操作: PagingAndSortingRepository repository = // … get access to a bean Page users = repository.findAll(PageRequest.of(1, 20)); 除了查询方法之外，还提供了count和delete查询的查询派生。下面的列表显示了派生count查询的接口定义: Example 5. Derived Count Query interface UserRepository extends CrudRepository { long countByLastname(String lastname); } Example 6. Derived Delete Query interface UserRepository extends CrudRepository { long deleteByLastname(String lastname); List removeByLastname(String lastname); } 扩展Respository功能 例子: @NoRepositoryBean interface MyBaseRepository extends Repository { Optional findById(ID id); S save(S entity); } interface UserRepository extends MyBaseRepository { User findByEmailAddress(EmailAddress emailAddress); } 多数据源持久层 略, 详见官方文档 定义查询方法 repository代理有两种方法从方法名派生特定于仓库的查询: 通过直接从方法名派生查询。 通过使用手动定义的查询。 查询策略 构建在Spring Data存储库基础设施中的查询生成器机制对于在存储库实体上构建约束查询非常有用。该机制剥离前缀find ... By，read ... By，query ... By，count ... By，and get ...来自该方法并开始解析其余部分,引入子句可以包含进一步的表达式，比如使用Distinct在要创建的查询上设置不同的标志,但是，第一个By用作分隔符以指示实际条件的开始。您可以在实体属性上定义条件，并用and和Or连接它们. 以下示例显示了如何创建大量查询 interface PersonRepository extends Repository { List findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname); // Enables the distinct flag for the query List findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname); List findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname); // Enabling ignoring case for an individual property List findByLastnameIgnoreCase(String lastname); // Enabling ignoring case for all suitable properties List findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname); // Enabling static ORDER BY for a query List findByLastnameOrderByFirstnameAsc(String lastname); List findByLastnameOrderByFirstnameDesc(String lastname); } 但是，有一些一般要注意的事项： 表达式通常是属性遍历与可连接的操作符组合而成。可以使用AND和OR组合属性表达式,您还可以获得对属性表达式的Between、LessThan、GreaterThan和Like等操作符的支持,受支持的操作符可能因数据存储而异，因此请参考参考文档的适当部分 方法解析器支持为单个属性设置IgnoreCase标志,例如findByLastnameIgnoreCase(…)忽略大小写的类型的所有属性(通常是字符串实例，例如 findByLastnameAndFirstnameAllIgnoreCase(…))是否支持忽略案例可能因存储而异 您可以通过将OrderBy子句附加到引用属性的查询方法并提供排序方向(Asc或Desc)来应用静态排序。 属性表达式 属性表达式只能引用托管实体的直接属性，如上例所示。在查询创建时，您已经确保已解析的属性是托管域类的属性。不过，您也可以通过遍历嵌套属性来定义约束。考虑下面的方法: List findByAddressZipCode(ZipCode zipCode); 假设一个人有一个带邮政编码的地址,该方法创建属性遍历x.address.zipCode。解析算法首先将整个部分(AddressZipCode)解释为属性，然后检查域类是否包含该名称的属性(未大写)。如果算法成功，它将使用该属性,它使用这个属性。如果没有，该算法将驼峰情况部分的源从右侧分割为头和尾，并尝试在我们的示例中找到相应的属性,如果没有，该算法将驼峰情况部分的源代码从右侧分割为头部和尾部，并尝试在我们的示例中找到相应的属性AddressZip和Code,它需要尾巴并继续从那里建造分支，按照刚刚描述的方式将尾巴分开。 如果第一个分割不匹配，算法会将分割点移动到左侧（Address，ZipCode）并继续。 虽然这应该适用于大多数情况，但是算法可能选择了错误的属性。假设Person类也有一个addressZip属性。该算法将在第一轮分割中匹配，选择错误的属性，并失败(因为addressZip类型可能没有code属性)。 要解决这种模糊性，可以在方法名称中使用手动定义遍历点。我们的方法名如下 List findByAddress_ZipCode(ZipCode zipCode); 特殊参数处理 分页和排序 需要传入特殊的参数: Pageable and Sort, 如下所示: Page findByLastname(String lastname, Pageable pageable); Slice findByLastname(String lastname, Pageable pageable); List findByLastname(String lastname, Sort sort); List findByLastname(String lastname, Pageable pageable); 第一个方法允许您传递org.springframework.data.domain。查询方法的可分页实例，以便动态地将分页添加到静态定义的查询中。一个页面知道可用元素和页面的总数。它通过基础设施触发count查询来计算总数。由于这可能很昂贵(取决于所使用的商店)，您可以返回一个切片。一个切片只知道下一个切片是否可用，这在遍历较大的结果集时可能就足够了。 排序选项也通过Pageable实例处理。 如果只需要排序，请在方法中添加org.springframework.data.domain.Sort参数。 如您所见，也可以返回List。 在这种情况下，不会创建构建实际页面实例所需的其他元数据（反过来，这意味着不会发出必要的附加计数查询）。 相反，它限制查询仅查找给定范围的实体。 分段查询结构 查询方法的结果可以通过使用first或top关键字来限制,可以互换使用。可以将可选数值追加到top或first，以指定要返回的最大结果大小。如果省略该数字，则假设结果大小为1。下面的示例显示如何限制查询大小 User findFirstByOrderByLastnameAsc(); User findTopByOrderByAgeDesc(); Page queryFirst10ByLastname(String lastname, Pageable pageable); Slice findTop3ByLastname(String lastname, Pageable pageable); List findFirst10ByLastname(String lastname, Sort sort); List findTop10ByLastname(String lastname, Pageable pageable); 限制表达式也支持Distinct关键字。 此外，对于将结果集限制为一个实例的查询，支持使用Optional关键字将结果包装 返回集合或迭代的存储库方法 略 空值处理 从Spring Data 2.0开始，返回单个聚合实例的repository CRUD方法使用Java 8 s可选方法来表示可能没有值。除此之外，Spring Data支持在查询方法上返回以下包装器类型 com.google.common.base.Optional scala.Option io.vavr.control.Option 也可以通过null值判断返回结果,返回集合、集合替代方案、包装器和流的存储库方法保证永远不会返回null，而是相应的空表示。有关详细信息，请参阅存储库查询返回类型 空值注释 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"SpringData/SpringDataJPA.html":{"url":"SpringData/SpringDataJPA.html","title":"Spring-Data-JPA","keywords":"","body":"Spring Data JPA Repostory @Repository public interface AppUserRepostory extends JpaRepository { } Example 使用 public AppUser loadUserByUsername(String username) throws UsernameNotFoundException { AppUser user = new AppUser(); user.setUsername(username); ExampleMatcher matcher = ExampleMatcher.matching().withIgnoreNullValues() .withMatcher(\"username\", match -> match.contains() ); Example example =Example.of(user,matcher); Optional optional = userRepostory.findOne(example); AppUser appUser = userRepostory.queryByUsername(username); if (!optional.isPresent()) { throw new UsernameNotFoundException(\"用户名不存在\"); } return optional.get(); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"SpringCloud/SpringCloudContext.html":{"url":"SpringCloud/SpringCloudContext.html","title":"Spring Cloud","keywords":"","body":"Spring Cloud 上下文 Spring Boot 有一套自己的方式构建一个Spring 应用程序，例如有常规的公共配置文件位置，以及用于程序管理和监视任务的端点。Spring Cloud 在 Spring Boot 的基础上增加了一些通用的功能。 引导上下文 Spring Cloud 通过创建“引导”的上下文来运行，它是主程序的父上下文,它负责从外部加载配置属性，并解密本地外部配置文件中的属性。这两个上下文共享一个Environment(环境),该环境是Spring应用程序的外部属性来源。默认情况下，引导属性的优先级高，因此它不能被本地配置覆盖。 引导上下文和主程序的上下文使用不同的外部配置，可以使用 bootstrap.yml 代替application.yml 使引导上下文和主程序上下文保持完全的分离。 例如: bootstrap.yml spring: application: name: foo cloud: config: uri: ${SPRING_CONFIG_URI:http://localhost:8888} 如果你需要来自服务器任何特定的配置，需要设置spring.application.name, 该属性作为应用程序的ID。 也能够通过spring.cloud.bootstrap.enabled=false属性关闭引导的加载。 程序的上下文层次结构 引导上下文是作为父上下文添加到程序的上下文中，子上下文从父上下文中继承属性 由于属性源的排序规则，引导项优先。但是，请注意，这些文件不包含来自引导程序的任何数据。它的优先级非常低，但是可以用来设置默认值。 常规Spring应用程序上下文行为规则适用于属性解析:来自子上下文的属性通过名称和属性源名称覆盖父上下文中的属性 ...... 修改引导文件的位置 bootstrap.yml(或 .properties)位置可由spring.cloud.bootstrap.name(默认: bootstrap) 或者 spring.cloud.bootstrap.location(默认:空)指定。 重写远程属性的值 通过引导上下文添加到应用程序中的属性通常是远程的。(例: Spring Cloud Config Server),默认情况下,不能再本地重写他们，如果你想让程序自己的系统属性或配置文件覆盖远程属性,远程属性源必须通过设置授予它权限spring.cloud.config.allowOverride=true(在本地设置是无效的)一旦设置该标志后，两个更细粒度的设置将控制远程属性相对于系统属性和应用程序本地配置的位置 spring.cloud.config.overrideNone=true 允许任何本地属性源进行覆盖。 spring.cloud.config.overrideSystemProperties=false 只有系统属性，命令行参数和环境变量(而不是本地配置文件)才能够覆盖远程设置。 自定义引导配置 引导上下文可以通过在名为org.springframework.cloud.bootstrap.BootstrapConfiguration 的键下向 /META-INF/spring.factories 添加条目来设置您喜欢的任何操作。它包含一个以逗号分隔的Spring @Configuration类列表，用于创建上下文，您可以在此处创建您希望可用于主应用程序上下文以进行自动装配的任何Bean。 自定义引导属性源 引导过程添加的外部配置的默认属性源是 Spring Cloud Config Server,但是您可以通过向引导上下文(通过spring.factories)添加PropertySourceLocator类型的bean来添加额外的源,例如，你可以从数据库添加扩展属性。 如： @Configuration public class CustomPropertySourceLocator implements PropertySourceLocator { @Override public PropertySource locate(Environment environment) { return new MapPropertySource(\"customProperty\", Collections.singletonMap(\"property.from.sample.custom.source\", \"worked as intended\")); } } 传入的 Environment 是即将创建ApplicationContext的环境，换句话说，我们为它提供额外的属性源，它已经有了Spring Boot 提供的属性源，因此，您可以使用它们来查找特定与此环境的属性源。 如果你创建了一个包含此类的jar，然后添加到 META-INF/spring.factories org.springframework.cloud.bootstrap.BootstrapConfiguration=sample.custom.CustomPropertySourceLocator 日志配置 如果您打算使用SpringBoot 来配置日志，那么应该将配置放在bootstrap.yml 中， 环境变化 当配置发生变化后，如何加载新的配置信息？ 程序侦听EnvironmentChangeEvent 的事件(观察者设计模式)，有一个已更改的键值列表，应用程序将会： 重新绑定任何@ConfigurationPropertiesBean的上下文。 设置logging.level.*日志级别的任何属性。 注意，默认情况下客户端不会轮询环境变量发生变化，通常，我们不建议使用这种方法来检测更改(尽管你可以使用@Scheduled定时注解) 如果你有一个扩展的客户机程序，最好的办法是发送EnvironmentChangeEvent广播给所有的实例，而不是让轮询更改，(例如：使用 Spring Cloud Bus Spring Cloud 云总线) 刷新范围 当配置发送改变时，一个标记为@RefreshScope的Srping @Bean 将会被特殊处理，这个功能解决了有状态Bean的问题，只有在初始化时才会注入其配置。例如，如果一个数据库连接池打开了一个连接时，环境变量中的Url发生了改变。您可能希望这些连接的持有者能够继续完成他们想做的事情。下一次从连接池获取的连接时新的Url。 有时，甚至会强制在一些只能初始化一次的Beans上面使用@RefreshScope 如果这个bean是'不能被修改的'，你必须要使用@RefreshScope 注释Bean，或者在属性键 spring.cloud.refresh.extra-refreshable 指定类名。 个人猜测：如果Bean加了@RefreshScope，修改属性时，使用新的属性重新创建了一个Bean，而不是修改原有Bean的属性。 加密和解密技术 Spring Cloud有一个Environment预处理器，用于在本地解密属性值, 它遵循与配置服务器相同的规则，并具有相同的外部配置encrypt.*因此,你可以使用{cipher}* 的加密值,并且只要有一个有效的密钥，它们就会在主应用程序上下文获取环境设置的之前进行解密。在应用程序中使用加密功能，你需要将Spring Security RSA 加入到项目的classpath, (Maven坐标：org.springframework.security:spring-security-rsa)您还需要JVM中的全强度JCE扩展。 如果由于“非法密钥大小”而出现异常，并且使用Sun's JDK，您需要安装Java Cryptography Extension (JCE) Unlimited Strength governance Policy文件。 端点 对于 Spring Boot Actuator 的应用程序，有一些额外可用的管理端，你可以使用： POST到 /actuator/env 更新 Environment 重新绑定 @ConfigurationProperties 和日志级别。 /actuator/refresh to re-load the boot strap context and refresh the @RefreshScope beans /actuator/restart to close the ApplicationContext and restart it (disabled by default). /actuator/pause and /actuator/resume for calling the Lifecycle methods (stop() and start() on the ApplicationContext). Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"SpringCloud/CommonAbstractions.html":{"url":"SpringCloud/CommonAbstractions.html","title":"Spring Cloud Common Abstractions 概念","keywords":"","body":"Spring Cloud Common Abstractions 概念 如服务发现，负载均衡，断路器等模式提供了一个公共抽象层，所有的Spring 客户端都可以使用这个抽象层，进行独立的实现(例如：服务发现可以用 Eureka 或 Consul)。 1.1 @EnableDiscoveryClient 开启服务发现 Spring Cloud Commons 提供了@EnableDiscoveryClient注解，这将查找 META-INF/spring.factories 中DiscoveryClient接口的实现。服务发现的实现类添加到spring.factories的org.springframework.cloud.client.discovery.EnableDiscoveryClient的键下面。 例如DiscoveryClient的实现类有 Spring Cloud Netflix Eureka, Spring Cloud Consul Discovery, and Spring Cloud Zookeeper Discovery. 默认情况，DiscoverClient 实现将本地SpringBoot 自动注册到远程服务发现服务器, 可以通过在@EnableDiscoveryClient中设置autoRegister = false来禁用其行为。 @EnableDiscoveryClient 不再是必须的，你也可以在类路径上放置DiscoveryClient，使SpringBoot程序向服务发现服务器注册 1.2 健康指标 Health Indicator Commons 创建了一个Spring Boot 的 HealthIndicator，Discover实现可以通过DiscoverHealthIndicator来参与其中. 禁用混合的HealthIndicator,设置spring.cloud.discovery.client.composite-indicator.enabled=false 一个基于DiscoverClient 的HealthIndicator 是自动配置的(DiscoveryClientHealthIndicator) 如果要关闭，设置set spring.cloud.discovery.client.health-indicator.enabled=false,关闭属性的描述DiscoveryClientHealthIndicator 设置spring.cloud.discovery.client.health-indicator.include-description=false.否则，它可能会像卷起的HealthIndicator的描述一样冒出来。 1.3 订购DiscoveryClient实例 DiscoveryClient 接口继承了 Ordered , 这对于使用多个发现服务时非常有用, 它允许你定义返回服务发现的顺序，类似于您可以如何订购Spring应用程序加载的bean。默认所有的DiscoveryClient的顺序都是0，如果你想设置自定义的DiscoveryClient实现的顺序，仅仅只需要重写getOrder()方法，返回您要设置的值。 ... ... 2.1 服务注册 Commons 新提供了一个 ServiceRegistry 接口，接口中提供了像 register(Registration) 和 deregister 这样的方法,它允许你提供自定义注册服务，注册时一个标记接口。 下面是一个正在用的服务注册表： @Configuration @EnableDiscoveryClient(autoRegister=false) public class MyConfiguration { private ServiceRegistry registry; public MyConfiguration(ServiceRegistry registry) { this.registry = registry; } // called through some external process, such as an event or a custom actuator endpoint public void register() { Registration registration = constructRegistration(); this.registry.register(registration); } } 每个 ServiceRegistry 实现都有自己的Registry(注册表)实现。 ZookeeperRegistration used with ZookeeperServiceRegistry EurekaRegistration used with EurekaServiceRegistry ConsulRegistration used with ConsulServiceRegistry 如果你实现了ServiceRegistry接口，则需要实现ServiceRegistry 的注册表实现。 2.2 ServiceRegistry 的自动注册 。。。 2.2 服务注册的监控端点 Spring Cloud Common 提供了/service-registry 的监控端点， 2.3 Spring RestTemplate 做负载均衡 RestTemplate可以自动配置使用功能区，创建一个负载均衡的RestTemplate，创建一个RestTemplate @Bean 并且使用@LoadBalance 限定符，如下面的例子所示： @Configuration public class MyConfiguration { @LoadBalanced @Bean RestTemplate restTemplate() { return new RestTemplate(); } } public class MyClass { @Autowired private RestTemplate restTemplate; public String doOtherStuff() { String results = restTemplate.getForObject(\"http://stores/stores\", String.class); return results; } } 2.4 Spring WebClient as a Load Balancer Client ... 2.7 Ignore Network Interfaces 忽略网络端口 忽略某些指定的网络接口是有用的，这样它们就可以被排除在服务发现注册之外，可以设置正则表达式列表以忽略所需的网络接口，下面的配置忽略docker0接口和所有以veth开头的接口 application.yml. spring: cloud: inetutils: ignoredInterfaces: - docker0 - veth.* 还可以使用正则表达式列表强制只使用指定的网络地址，如下面的示例所示 bootstrap.yml. spring: cloud: inetutils: preferredNetworks: - 192.168 - 10.0 您还可以强制只使用站点本地地址，如下面的示例所示:.application.yml spring: cloud: inetutils: useOnlySiteLocalInterfaces: true 2.8 Http Client 工厂 Spring Cloud Commons 提供了两个Beans，Apache HTTP client(ApacheHttpClientFactory )和 OK HTTP client(OkHttpClientFactory)。OkHttpClientFactory 只有OK HTTP jar 在classpath上存在的时候才会创建。另外，Spring Cloud Common 提供了两个连接管理端：ApacheHttpClientConnectionManagerFactory - Apache Http 和 OkHttpClientConnectionPoolFactory - Ok Http 2.9 启用功能 Spring Cloud Commons 提供了一个 /features 监控端点， Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"SpringCloud/SpringCloudConfig.html":{"url":"SpringCloud/SpringCloudConfig.html","title":"Spring Cloud Config","keywords":"","body":"Spring Cloud Config Spring Cloud Config 为分布式系统中的外部化配置, 提供了服务端和客户端支持, 使用Config Server, 你有一个中心位置管理应用程序中的外部属性,客户端和服务端上的映射与Spring Environment和PropertySource抽象相同.因此他们非常适合Spring的应用程序,但也能够使用到其他任何程序和任何语言, 当应用程序从部署流程从开发到测试并进入生产时,你可以管理这些环境之间的配置并且确保应用程序在迁移时拥有所需要的一切.服务端后端存储默认实现用的是git,因此它可以很容易的支持配置环境的标签版本,以及可用于管理内容的各种工具,可以很容易的替代实现,并使用Spring配置插入. Spring Cloud Config Server 参考文件:https://cloud.spring.io/spring-cloud-static/Greenwich.SR2/multi/multi__spring_cloud_config_server.html Spring Coloud Config Server 为外部配置提供了基于Http 资源的API, 可嵌入到Spring Boot 项目中, 使用@EnableConfigServer 注解,因此,下面的程序是一个配置服务程序: @SpringBootApplication @EnableConfigServer public class ConfigServer { public static void main(String[] args) { SpringApplication.run(ConfigServer.class, args); } } 和所有的SpringBoot程序一样,它默认运行在8080端口,你可以通过各种方式切换到惯用的8888端口,它还设置了默认的配置库, 通过spring.config.name=configserver 启动它(配置服务的jar包中有一个configserver.yml文件),另一种方法使用自己的applicationg.properties文件,如下所示: application.properties server.port: 8888 spring.cloud.config.server.git.uri: file://${user.home}/config-repo ${user.home}/config-repo 是一个git存储库,包含了YAML和properties文件, 在windows,在绝对路径的URL前缀,需要额外的 \"/\" 例如file:///${user.home}/config-repo 创建Git存储卡的方法 $ cd $HOME $ mkdir config-repo $ cd config-repo $ git init . $ echo info.foo: bar > application.properties $ git add -A . $ git commit -m \"Add application.properties\" 在本地使用Git存储库仅用来测试,应该使用服务器在生产环境中配置存储库. 环境存储库 配置服务的配置数据应该存到哪里,管理此行为的策略是 EnvironmentRepository 服务 Environment对象,这个Environment是Spring 环境的对象的浅拷贝(包括PropertySource的主要特性),环境的资源有三个参数的变化. {application}, 映射到客户端 spring.application.name {profile},映射到客户端 spring.profiles.active (以逗号分隔的List). {label} 这是标记版本的服务端功能 下面是一个客户端程序的引导配置文件: bootstrap.yml spring: application: name: foo profiles: active: dev,mysql 和Spring boot 的程序一样,这些参数也能够通过环境变量或命令行参数设置 如果存储库是基于文件的, 配置服务将根据application.yml和foo.yml(foo.yml 优先)创建一个Environment(在所有客户端共享) GIT 后端 EnvironmentRepository 的实现默认是Git后端,这对于管理升级和物理环境以及审计更改非常方便. 修改仓库的位置,你可以在配置服务中设置 spring.cloud.config.server.git.uri 属性(例如在 application.yml),如果你设置的是 file: 前缀,将会在本地存储库中工作,这样您就可以在没有服务器的情况下快速轻松的开始工作.然而,在这种情况下, 服务直接在本地存储库上运行而不进行克隆. Config Server 永远不会对远程存储库进行更改. 存储库实现将HTTP资源的{label}参数映射到一个git标签(commit id, 分支名称,或标签)如果git的分支或标签名称包含斜杠/, 然后应该使用特殊字符串（）指定HTTP URL中的标签（以避免与其他URL路径不一致）例如 foo/bar 要转成foo(\\)bar,也可应用于 {application}的参数, 跳过SSL验证 关闭配置服务器校验GIT服务的SSL证书,设置git.skipSslValidation 属性为true, 默认为false spring: cloud: config: server: git: uri: https://example.com/my/repo skipSslValidation: true 设置HTTP连接超时时间 可以设置一个超时时间,单位是秒,使用git.timeout 属性 spring: cloud: config: server: git: uri: https://example.com/my/repo timeout: 4 Git URL 占位符 Spring Cloud Config Server 支持git存储库的URL占位符 {application} and {profile} (and {label} 如果你需要使用lable ,但是请记住,这个标签是作为git标签应用的),因此，您可以使用类似于以下的结构来支持“每个应用程序一个存储库”策略： spring: cloud: config: server: git: uri: https://github.com/myorg/{application} 你也可以使用,一个仓库一个配置文件方式,使用类似的模式,使用{profile} 模糊匹配和多个存储库 Spring Cloud Config 还支持对应用程序和配置文件的名称进行模糊匹配更复杂的需求.该模式格式是带有通配符的{application} / {profile}名称的逗号分隔列表,如下所示 spring: cloud: config: server: git: uri: https://github.com/spring-cloud-samples/config-repo repos: simple: https://github.com/simple/config-repo special: pattern: special*/dev*,*special*/dev* uri: https://github.com/special/config-repo local: pattern: local* uri: file:/home/configsvc/config-repo 如果都不匹配,则使用默认uri定义spring.cloud.config.server.git.uri, 上述的例子所示simple仓库匹配simple/*, 它只匹配应用程序名称以simple开头的应用程序,本地存储库匹配所有配置文件中以local开头的所有应用程序名称. 只有当要设置的唯一属性是URI时，才可以使用简单示例中使用的单行捷径。如果需要设置其他内容(凭证、模式等)，则需要使用完整的表单。 repo中的pattern属性实际上是一个数组，因此您可以使用属性文件中的YAML数组（或[0]，[1]等后缀）绑定到多个模式。如果要运行具有多个配置文件的应用程序，则可能需要执行此操作。例： spring: cloud: config: server: git: uri: https://github.com/spring-cloud-samples/config-repo repos: development: pattern: - */development - */staging uri: https://github.com/development/config-repo staging: pattern: - */qa - */production uri: https://github.com/staging/config-repo 文件系统后端 --略 请参考 https://cloud.spring.io/spring-cloud-static/Greenwich.SR2/multi/multi_spring-cloud.html Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"SpringCloud/Netflix.html":{"url":"SpringCloud/Netflix.html","title":"Spring Cloud Netflix","keywords":"","body":"Netflix 该项目为Spring Boot 程序提供Netflix OSS集成, 通过简单的注释,您可以在应用程序中快速启用经过实战考验的Netflix组建构建大型分布式系统.提供的模式包括服务发现(Eureka) 断路器(Hystrix) 智能路由(Zuul)和客户端负载均衡(Ribbon) 1. 服务发现-Eureka Client 服务发现是微服务架构的关键点, Eureka是Netflix服务发现的 服务端和客户端, 可以将服务配置和部署为高可用性,每个服务将注册服务的状态复制到其他服务器. 1.1 怎样引入Eureka Client 在项目中引入Eureka Client, 使用 starter, group Id org.springframework.cloud ,artifact ID spring-cloud-starter-netflix-eureka-client. 1.2 Eureka 注册 当一个Eureka客户端注册, 它提供关于自身的元数据,类如 主机,端口,健康端点URL, 主页和其他详细信息, Eureka 接收每个实例的心跳消息, 如果心跳超过配置的时间,该实例通常从注册表中删除. 下面的例子时一个最小的Eureka客户端程序. @SpringBootApplication @RestController public class Application { @RequestMapping(\"/\") public String home() { return \"Hello world\"; } public static void main(String[] args) { new SpringApplicationBuilder(Application.class).web(true).run(args); } } 注意,上面的程序时一个普通的Spring Boot程序, 当classpath 加入 spring-cloud-starter-netflix-eureka-client 时, 你的应用程序会自动注册到Eureka Server 需要配置来定位Eureka服务器, 如下所示: eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 在上面的例子中, defaultZone 是一个神奇的后备字符串,它为任何没有表示首选项的客户机提供服务URL.(换句话说,它是一个有用的默认值) 应用程序的默认名称(即 Service ID),虚拟主机和非安全端口(来自环境配置)的属性分别是${spring.application.name}, ${spring.application.name} and ${server.port}. 当应用的类路径有 spring-cloud-starter-netflix-eureka-client 使应用注册为一个实例(即注册它自己)和一个客户端(它可以查询注册到本地的其他Services). 实例的行为有 eureka.instance.* 的配置驱动, 但是在默认情况下,但是，如果您确保您的应用程序具有spring.application.name的值(这是Eureka服务ID或VIP的默认值)，那么默认值是没有问题的。 See EurekaInstanceConfigBean and EurekaClientConfigBean for more details on the configurable options. 关闭Eureka Discovery Client, 设置 eureka.client.enabled 为 false,也可以设置spring.cloud.discovery.enabled 为 false. Eureka Server 验证 如果其中一个 eureka.client.serviceUrl.defaultZone 的url嵌入凭证(curl 风格所示: http://user:password@localhost:8761/eureka), Http basic 认证自动添加到eureka 客户端,对于更复杂的需求,你可以创建一个@Bean 实例DiscoveryClientOptionalArgs 注入到 ClientFilter中,所有这些都应用于客户机到服务器的调用。 由于Eureka的限制，无法支持每服务器基本身份验证凭据，因此仅使用找到的第一个集合。 状态页面和健康指标监控 状态页和健康指标在Eureka 实例中分别是 /info 和 /health这是Spring Boot Actuator应用程序中有用端点的默认位置。如果使用非默认上下文路径或servlet路径(类如 server.servletPath=/custom，则需要更改这些，即使对于Actuator应用程序也是如此. 以下示例显示了两个设置的默认值： application.yml. eureka: instance: statusPageUrlPath: ${server.servletPath}/info healthCheckUrlPath: ${server.servletPath}/health Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"SpringCloud/SpringCloudSecurity.html":{"url":"SpringCloud/SpringCloudSecurity.html","title":"Spring Cloud Security","keywords":"","body":"Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"Netty/Netty.html":{"url":"Netty/Netty.html","title":"Netty","keywords":"","body":"Netty 问题 我们经常使用应用程序和库来相互通信，例如，浏览器和Web服务器之间的通信。但是通用协议有时不能很好的扩展，比如我们不用Http服务器传输大文件，电子邮件和近时时消息(比如股票信息和游戏数据) 解决方案 Netty 项目致力于提供一个异步事件驱动的网络应用框架，快速开发可维护的高性能，高可扩展性协议的服务器和客户端工具。 换句话说，Netty 是一个NIO 客户端服务器框架，可以快速轻松的开发服务器和客户端之间通信协议的网络应用程序。 “快速而简单” 并不意味着最终的应用程序会受到可维护性或性能问题的影响。Netty 经过精心设计，从实现FTP，SMTP，HTTP 等协议中学到了很多经验 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"Docker/Docker.html":{"url":"Docker/Docker.html","title":"Docker","keywords":"","body":"Docker 理解Docker: Docker是一个供开发人员和系统管理员使用容器开发、部署和运行应用程序的平台。 特点: 我们使用Docker是因为它具有这些特点: 灵活性: 即使是最复杂的应用也可以集装箱化。 轻量级: 容器共享主机内核。 可插拔: 您可以热更新或升级(比如我们常说的灰度发布,蓝绿和金丝雀发布) 便携性: 您可以在本地构建、部署到云，并在任何地方运行。 伸缩性: 您可以方便的扩展或收缩容器集群 可堆叠: 您可以垂直地、动态地堆叠服务。 理解 镜像(images)和容器(containers) 容器通过镜像启动, 镜像(images)是一个包含了应用程序的所有内容(程序的代码, 运行时,库,环境变量和配置文件)的可执行包. 容器(containers) 是 images 运行时的实例, 根据镜像启动一个或多个实例,这个实例称为容器(containers) 容器和虚拟机区别 容器在Linux上本机运行，并与其他容器共享主机的内核。它运行一个独立的进程，不占用任何其他可执行文件的内存，使其轻量级。 相比之下，虚拟机（VM）运行一个完整的“客户”操作系统，通过虚拟机管理程序对主机资源进行虚拟访问。 通常，VM提供的环境比大多数应用程序需要的资源更多。 安装Docker https://hub.docker.com/search/?type=edition&offering=community 选择你需要的版本. Windows 下安装: 版本要求: Win 10 64位专业版操作系统 硬件要求: 64位硬件, 4G 内存 ,BIOS设置中必须启用BIOS级硬件虚拟化支持。 选择windows版本docker版本下载, 按照提示安装即可. 后续再补 设置存储库: $ sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 $ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 安装: sudo yum install docker-ce docker-ce-cli containerd.io 使用 Docker 创建镜像(Images) 后续再补 运行容器Container 后续再补 服务 在分布式环境中, 生产中的容器一个服务只需要一个Images, 它规范了服务的端口, 副本的数量, 服务的容量等等,.使用Docker平台很容易定义、运行和扩展服务——只需编写一个docker-composition.yml文件。 docker-compose.yml 文件 version: \"3\" services: web: # replace username/repo:tag with your name and image details image: username/repo:tag deploy: replicas: 5 resources: limits: cpus: \"0.1\" memory: 50M restart_policy: condition: on-failure ports: - \"4000:80\" networks: - webnet networks: webnet: 集群 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-09-17 21:28:03 "},"MCU/MicroControllerUnit.html":{"url":"MCU/MicroControllerUnit.html","title":"单片机","keywords":"","body":"单片机 MCU(Micro Controller Unit) 型号解释 STC 89C52 35I-PDIP40 1749HRX921.. STC：公司名称 89：89系列 C：CMOS 52：stc还有51，54，58，516后面的值*4k表示内存空间的大小。52的内存空间为8k。 35：表示单品机的工作频率 I：表示工业级（-40 - 125摄氏度）， C表示商业级（温度范围0-80）军品级别 PDIP：封装型号，包括单片机的形状和大小。 1749：代表生产时间，17年4月9日 80C51引脚封装 总线型 非总线型 总线分为三种：数据总线DB(Data Bus),地址总线AB(Adress Bus),控制总线CB(Control Bus) 单片机组成 CPU RAM ROM I/O T/C ：两个定时/计数器，既可以工作在定时模式，也可工作在计数模式。 C51 知识 很多硬件的开发都使用C语言编程，例如各种单片机，DSP，ARM等。 C51 数据类型 C-51基础数据类型 (有符号和无符号字节数 signed,unsigned) int(16) short(16) long(32) float(32) double(64) char(8) C51 数据类型扩充定义 sfr: 特殊功能寄存器申明 sfr16: sfr的16位数据申明 sbit: 特殊功能位声明 bit：位变量声明 C51 包含的头文件 常用头文件有 reg51.h reg52.h,定义特殊功能寄存器和位寄存器 math.h 定义常用数学运算 C51运算符 与C语言基本相同。 算数运算符 + - * / 布尔运算符： > >= \\ 逻辑运算符： && || ! 位运算: >> \\ & | 按位与或 ～ ^ 按位异或 取反 C51 基本语句 与C基本相同 if while for switch/case do-while 中断服务程序 I/O口定义 单片机要点掌握 最小系统能够运行起来的必要条件，1 电源 2 晶振 3 复位电路 对单片机任意I/O口的随意操作 输出控制的电频高低 输入检测电频高低 定时器 中断：外部中断，定时器中断，串口中断 串口通信：单片机之间，单片机与计算机间 单片机工作的基本时序 振荡周期: 也称时钟周期,指为单片机提供时钟脉冲信号振荡源的周期, TX实验板为11.0592MHZ 状态周期: 每个状态周期为时钟周期的两倍,是振荡周期经二分频后得到的. 机器周期: 一个机器周期包含6个状态周期,也就是12个时钟周期,在一个机器周期内,CPU可以完成一个独立的操作, 指令周期: 它指CPU完成一条操作所需的全部时间,每条指令执行时间都是有一个或几个机器周期组成 MCS-51系统中,有单周期指令,双周期指令和四周期指令. 80C51引脚封装 80C51/89C51 最大4k程序. 管脚: RST/Vpd: 复位/备用电源的输入端, P3.0/RXD, P3.1/TXD,P3.2/INTO ... P3.7/RD: 串口,程序下载命令,中断,定时器,计数器,外部数据存储器. XTAL2 XTAL1: 外部晶振输入端. ALE 中断 中断的概念: CPU 在处理某一事件A, 发生了另一事件B请求CPU迅速去处理(中断发生) CPU暂时中断当前的工作,转去处理事件B(中断响应和中断服务) 待CPU将事件B处理完毕后,再回到原来事件A被中断的地方继续处理事件A(中断返回),这一过程称为中断 中断的嵌套 在中断服务中再次发生中断 中断的优先级 中断源的响应优先级及中端服务入口程序表 中断源 中断标志 中断服务程序入口 优先级顺序 外部中断 0 (INT0) IE0 0003H 高 定时/计数器 0 (T0) TF0 000BH ⬇ 外部中断 1 (INT1) IE1 0013H ⬇ 定时/计数器 1(T1) TF1 001BH ⬇ 串行口 RI或T1 0023H 低 中断响应条件 中断源有中断请求 此中断源的中断允许位为1 CPU开中断 即 EA=1 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-06 19:00:54 "},"maven/maven.html":{"url":"maven/maven.html","title":"maven","keywords":"","body":"Maven maven 本地仓库导入jar包 mvn install:install-file -Dfile=C:\\Users\\DELL\\Documents\\mybash\\uids-sm-1.0.jar -DgroupId=com.zdww -DartifactId=uids-sm -Dversion=1.0 -Dpackaging=jar 注意: 此脚本在powershell中执行会出现错误, 请使用git_bash或其他支持shell的终端执行 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-01-22 13:14:06 "},"Android/adb.html":{"url":"Android/adb.html","title":"Andorid","keywords":"","body":"ADB adb速查 https://www.wanandroid.com/blog/show/2310 最全ADB github: https://github.com/mzlogin/awesome-adb adb 常用命令 查看当前连接设备： adb devices 如果发现多个设备： adb -s 设备号 其他指令 查看日志： adb logcat 安装apk文件： adb install xxx.apk 此安装方式，如果已经存在，无法安装； 推荐使用覆盖安装： adb install -r xxx.apk 卸载App: adb uninstall com.zhy.app 1 如果想要保留数据，则： adb uninstall -k com.zhy.app 往手机SDCard传递文件： adb push 文件名 手机端SDCard路径 从手机端下载文件： adb pull /sdcard/xxx.txt 查看手机端安装的所有app包名: adb shell pm list packages 启动Activity: adb shell am start 包名/完整Activity路径 启动服务： adb shell am startservice \"com.zhy.aaa/com.zhy.aaa.MyService\" 屏幕截图： adb shell screencap /sdcard/screen.png 录制视频： adb shell screenrecord /sdcard/demo.mp4 清除APP数据： adb shell pm clear com.example.packagename 查看所有App的名称：该命令可以查看手机上的APP名称。可以在后面加上 -f ，这样还能显示该APP的路径。 即： adb shell pm list packages -f 使用adb shell input命令向屏幕输入一些信息， adb shell input text \"insert%stext%shere\" 注意：%s表示空格。 模拟屏幕点击事件 adb shell input tap 500 1450 1 表示在屏幕上（500，1450）的坐标点上进行一次点击。 模拟手势滑动事件，例如： adb shell input swipe 100 500 100 1450 100 用上面的命令还可以模拟”长按（long press）操作，也就是2个坐标点相同，耗时超过500ms. adb shell input swipe 100 500 100 500 500 模拟点按实体按钮的命令，例如： adb shell input keyevent 25 该命令表示调低音量。数字25是在AOSP源码中的KeyEvent类里定义的一个事件常量。该类定义了将近300个事件常量。 上面这个命令会启动浏览器打开谷歌网址页面。 adb shell am start -a \"android.intent.action.VIEW\" -d \"https://www.google.com\" am 也能发送广播和启动服务。比如启动一个广播，一般要添加一个-a： adb shell am broadcast -a \"our.specified.action\" 使用下面的命令可以直接让手机重启： adb shell am broadcast -a android.intent.action.BOOT_COMPILETED 启动一个服务也是类似，例如: adb shell am startservice \"com.example.crime/com.example.crime.MyService\" adb shell ps命令查看进程信息。可以在该命令后加包名，来查看某个应用程序的进程信息。 adb shell top 命令来查看系统CPU使用情况 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-06 19:00:54 "},"DB/db.html":{"url":"DB/db.html","title":"数据库","keywords":"","body":"数据库 Oracle 数据库表数据闪回 找回删除的数据或者表 闪回查询 查询过去某个时间段的数据库状态 select * from dept as of timestamp to_timestamp('2016-09-10 11:00:00','yyyy-mm-dd hh24:mi:ss'); 闪回表 启用表闪回首先要在表上支持行移动 闪回表操作 ```sql alter table dept enable row movement; flashback table dept to timestamp to_timestamp('2016-09-10 11:00:00','yyyy-mm-dd hh24:mi:ss'); ``` 闪回表可能会失败，有可能有以下几种情况： 违反了数据库约束，比如用户不小心删除了子表中的数据，现在想利用闪回表技术进行回退，恰好在这中间，父表中与该数据对应的那条记录也被删除了，在这种情况下，由于违反了外键约束，导致闪回表操作失败了； 撤销数据失效，比如用于支撑闪回操作的撤销数据被覆盖了，这种情况闪回表操作自然会失败； 闪回不能跨越DDL，即在闪回点和当前点之间，表结构有过变更，这种情况闪回操作也会失败。 如果表和数据库被删除了，也可以闪回，请参考 https://www.cnblogs.com/chengxiao/p/5860823.html Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-03-03 22:31:50 "},"股票/股票趋势技术分析.html":{"url":"股票/股票趋势技术分析.html","title":"股票","keywords":"","body":"股票趋势技术分析 股票分析的两种流派: 基本统计分析: 依靠各种统计数据, 检查审计报表,损益报告,资产负债表等指标数据对股票进行评估, 如果其当前售价低于其评定价值, 则认为可以购买 技术分析: 指对市场本身行为研究而非对市场交易商品的研究. 通过股票的走势推断出发展趋势. 道氏理论 技术分析派 查看详情 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-25 23:22:07 "},"股票/道氏理论.html":{"url":"股票/道氏理论.html","title":"道氏理论","keywords":"","body":"道氏理论 要点: 三种趋势 长期趋势: 中期趋势 短期趋势 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-25 23:22:07 "}}