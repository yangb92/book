{"./":{"url":"./","title":"介绍","keywords":"","body":" 代码笔记 希望你该坚持主见的时候，坚持主见，该沉默的时候，学会沉默，宁愿卑微如灰尘,不可扭曲成蛆虫。 杨斌 local: Hangzhou,China email: 523084685@qq.com blog: github: https://github.com/yangb92 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-07 16:34:47 "},"program/":{"url":"program/","title":"软件编程","keywords":"","body":"程序设计 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 10:03:25 "},"program/SpringBoot/":{"url":"program/SpringBoot/","title":"SpringBoot","keywords":"","body":"Spring Boot 项目结构 定位程序主类 默认推荐将启动类放在根目录中，高于其他的类。 @SpringBootApplication 注解放在主类上面，它还隐式的定义基础的所要扫描的包。 如果你不想用@SpringBootApplication， 可以使用@EnableAutoConfiguration 和 @ComponentScan 注解来定义这些。 典型的布局结构 com +- example +- myapplication +- Application.java | +- customer | +- Customer.java | +- CustomerController.java | +- CustomerService.java | +- CustomerRepository.java | +- order +- Order.java +- OrderController.java +- OrderService.java +- OrderRepository.java 配置类 Spring Boot 支持 java类配置和xml同事配置， 在配置类使用一个@Configuration， 通常定义 main 方法的主类很适合使用@Configuration。 导入其他配置类 你不需要将所有的@Configuration放入一个类中， @Import 注解能够用来加入配置类，或者，您可以使用@ComponentScan自动获取所有包括 @Configuration 类的Spring组件 导入XML配置 如果你必须要使用xml配置，我们建议您仍然从@Configuration类开始，你可以使用一个@ImportResource 注解加载xml配置文件。 自动配置 禁用特定的自动配置类 您可以使用@EnableAutoConfiguration的exclude属性禁用它们，如下面的示例所示: import org.springframework.boot.autoconfigure.*; import org.springframework.boot.autoconfigure.jdbc.*; import org.springframework.context.annotation.*; @Configuration @EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class}) public class MyConfiguration { } Spring Bean 和 依赖注入 您可以自由地使用任何标准Spring框架技术来定义bean及其注入的依赖项。为了简单起见，我们经常发现使用@ComponentScan(查找bean)和使用@Autowired(执行构造函数注入)工作得很好。 如果按照上面的建议构造代码(将应用程序类定位在根包中)，可以添加@ComponentScan，而不需要任何参数。所有应用程序组件(@Component、@Service、@Repository、@Controller等)都自动注册为Spring bean。 注意使用构造注入的bean 使用final 防止被更改。 使用@SpringBootApplication注解 使用一个@SpringBootApplication注释来启用这三个特性，即: @EnableAutoConfiguration: enable Spring Boot’s auto-configuration mechanism • @ComponentScan: enable @Component scan on the package where the application is located (see the best practices) • @Configuration: allow to register extra beans in the context or import additional configuration classes @SpringBootApplication还提供别名来定制@EnableAutoConfiguration和@ComponentScan的属性 这些特性都不是强制性的，您可以选择用它支持的任何特性替换这个注释。例如，你可能不想在你的应用程序中使用组件扫描: package com.example.myapplication; import org.springframework.boot.SpringApplication; import org.springframework.context.annotation.ComponentScan import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Import; @Configuration @EnableAutoConfiguration @Import({ MyConfig.class, MyAnotherConfig.class }) public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 开发工具 添加开发依赖 org.springframework.boot spring-boot-devtools true 开发依赖将在打包时关闭，并且用java -jar 运行时认为是生产环境，会自动关闭。 若要手动关闭，请设置Dspring.devtools.restart.enabled=false 属性 自动重启 类路径上的文件发生更改，将会自动重启，静态资源或模板发生更改，不会重启， 触发自动重启的唯一方法是更新类路径， Eclipse 自动更新， ide需要build 排除一些资源变动，不重启 spring.devtools.restart.exclude=static/,public/ 远程开发 需要添加插件 org.springframework.boot spring-boot-maven-plugin false 然后需要设置spring.devtools.remote.secret属性，如下面的示例所示: spring.devtools.remote.secret=mysecret 存在安全风险，不建议用在生产服务器上。 远程开发工具由两部分提供支持，接受连接的服务器端端点和在IDE中运行的客户机应用程序。当设置spring.devtools.remote.secret属性时，服务器组件将自动启用。客户端组件必须手动启动。 jar包部署至远程服务器 在服务器上运行jar包，address=5005 是调试端口 java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 demo-0.0.1-SNAPSHOT.jar IDE 上开启远程调试 只需要输入主机地址和调试端口即可热更新和调试，实现本地开发，远程运行，降低对开发电脑的资源占用。 运行远程客户端程序 远程客户端程序被设计运行在IDE，您需要运行org.springframework.boot.devtools.RemoteSpringApplication，其类路径与您连接到的远程项目相同，应用程序唯一需要的参数是它连接到的远程URL。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 10:17:40 "},"program/SpringBoot/SpringBootDruid.html":{"url":"program/SpringBoot/SpringBootDruid.html","title":"SpringBoot整合Druid","keywords":"","body":"SpringBoot 整合 Druid 引入依赖 在pom文件引入druid依赖 com.alibaba druid-spring-boot-starter 1.1.22 引入数据库连接依赖 mysql mysql-connector-java runtime 配置application.yml spring: datasource: druid: url: jdbc:mysql://ip:port/dbname?useUnicode=true&characterEncoding=utf-8&useSSL=false username: root password: 123456 initial-size: 1 min-idle: 1 max-active: 20 test-on-borrow: true # MySQL 8.x: com.mysql.cj.jdbc.Driver driver-class-name: com.mysql.jdbc.Driver Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-13 15:13:04 "},"program/SpringBoot/SpringBootTkMybaits.html":{"url":"program/SpringBoot/SpringBootTkMybaits.html","title":"SpringBoot整合tk.mybatis","keywords":"","body":"SpringBoot 整合 tk.mybatis 引入依赖 在pom.xml引入依赖,该依赖会自动引入MyBaits依赖 tk.mybatis mapper-spring-boot-starter 2.0.2 配置 application.yml 配置 MyBatis mybatis: type-aliases-package: 实体类的存放路径，如：com.funtl.hello.spring.boot.entity mapper-locations: classpath:mapper/*.xml 创建一个通用的父级接口 主要作用是让 DAO 层的接口继承该接口，以达到使用 tk.mybatis 的目的 package com.funtl.utils; import tk.mybatis.mapper.common.Mapper; import tk.mybatis.mapper.common.MySqlMapper; /** * 自己的 Mapper * 特别注意，该接口不能被扫描到，否则会出错 * Title: MyMapper * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/5/29 0:57 */ public interface MyMapper extends Mapper, MySqlMapper { } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-13 15:26:24 "},"program/SpringBoot/SpringBootPageHelper.html":{"url":"program/SpringBoot/SpringBootPageHelper.html","title":"SpringBoot整合PageHelper","keywords":"","body":"SpringBoot 整合 PageHelper 引入依赖 在pom.xml文件中引入pagehelper-spring-boot-starter com.github.pagehelper pagehelper-spring-boot-starter 1.2.5 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-13 15:29:07 "},"program/SpringBoot/generator.html":{"url":"program/SpringBoot/generator.html","title":"Mybatis Maven插件生成代码","keywords":"","body":"Mybatis Maven插件生成代码 配置插件 在pom.xml文件中增加mybatis-generator-maven-plugin插件 org.mybatis.generator mybatis-generator-maven-plugin 1.3.5 ${basedir}/src/main/resources/generator/generatorConfig.xml true true mysql mysql-connector-java ${mysql.version} tk.mybatis mapper 3.4.4 configurationFile：自动生成所需的配置文件路径 自动生成的配置 在 src/main/resources/generator/ 目录下创建 generatorConfig.xml 配置文件： 配置数据源 在 src/main/resources/generator 目录下创建 jdbc.properties 数据源配置： # MySQL 8.x: com.mysql.cj.jdbc.Driver jdbc.driverClass=com.mysql.jdbc.Driver jdbc.connectionURL=jdbc:mysql://ip:port/dbname?useUnicode=true&characterEncoding=utf-8&useSSL=false jdbc.username=root jdbc.password=123456 插件自动生成命令 mvn mybatis-generator:generate Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-15 09:08:07 "},"SpringBoot/thymeleaf.html":{"url":"SpringBoot/thymeleaf.html","title":"thymeleaf 模板引擎","keywords":"","body":"thymeleaf pom org.springframework.boot spring-boot-starter-thymeleaf 显示Controller传递的数据 显示配置文件中的数据 Oranges 0.99 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-08 10:29:15 "},"program/SpringBoot/SpringDataJPA.html":{"url":"program/SpringBoot/SpringDataJPA.html","title":"SpringDataJPA","keywords":"","body":"Spring Data JPA Repostory @Repository public interface AppUserRepostory extends JpaRepository { } Example 使用 public AppUser loadUserByUsername(String username) throws UsernameNotFoundException { AppUser user = new AppUser(); user.setUsername(username); ExampleMatcher matcher = ExampleMatcher.matching().withIgnoreNullValues() .withMatcher(\"username\", match -> match.contains() ); Example example =Example.of(user,matcher); Optional optional = userRepostory.findOne(example); AppUser appUser = userRepostory.queryByUsername(username); if (!optional.isPresent()) { throw new UsernameNotFoundException(\"用户名不存在\"); } return optional.get(); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 10:23:08 "},"program/SpringBoot/SpringDataJdbc.html":{"url":"program/SpringBoot/SpringDataJdbc.html","title":"SpringDataJDBC","keywords":"","body":"Spring Data Jdbc 添加依赖 org.springframework.boot spring-boot-starter-data-jdbc 创建实体 @Data @Table(\"t_user\") public class UserDto { @Id private String id; private String username; private String password; private String fullname; private String mobile; } 创建Dao @Repository public interface UserDao extends CrudRepository { @Query(\"SELECT * FROM `t_user` where username=:username\") UserDto findByUsername(@Param(\"username\") String username); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 10:23:08 "},"program/SpringBoot/LinuxService.html":{"url":"program/SpringBoot/LinuxService.html","title":"部署为linux服务","keywords":"","body":"Linux 服务化部署 官方文档: https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/html/deployment.html#deployment-install 配置Maven插件 org.springframework.boot spring-boot-maven-plugin true 安装为init.d服务 假设你的SpringBoot程序部署在/var/myapp路径，要将SpringBoot程序作为init.d服务，需要创建一个软链接，如下: $ sudo ln -s /var/myapp/myapp.jar /etc/init.d/myapp 安装后，就可以按系统服务的方式启动和停止。例如，在基于debian的系统上，可以使用以下命令启动它: $ service myapp start 日志在/var/log/\\.log中可以查看. FQ spring boot 在Linux下服务启动报错Unable to find Java 将java 连接到/sbin 文件夹下 ln -s /usr/local/jdk/bin/java /sbin/java Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 17:47:57 "},"program/SpringCloud/":{"url":"program/SpringCloud/","title":"Spring Cloud","keywords":"","body":"Spring Cloud Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-23 16:14:21 "},"program/SpringCloud/stopdesc.html":{"url":"program/SpringCloud/stopdesc.html","title":"SpringCloud组件状态","keywords":"","body":"Spring Cloud 组件停更说明 参考资料: 见官网 说明: [ ] 停更 [x] 建议使用 服务注册 [ ] Eureka [x] Zookeeper [x] Consul [x] Nacos (Alibaba) 服务调用 [x] Ribbon [x] LoadBalancer 服务调用2 [ ] Feign [x] OpenFeign 服务降级 [ ] Hystrix [x] resilience4j (国外推荐) [x] Sentine (国内推荐- 来自Alibaba组件) 服务网关 [ ] Zuul [ ] Zuul2 (未开发完成) [x] Gateway 服务配置 [ ] Config [x] Apollo (上海携程) [x] Nacos (Alibaba) 服务总线 [ ] Bus [x] Nacos Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-23 11:15:23 "},"program/SpringCloud/version..html":{"url":"program/SpringCloud/version..html","title":"版本选型","keywords":"","body":"版本选型 Spring Boot 版本选型: 19年以后不再使用 1.5 版本, 一定要使用2.x版本 Spring Cloud 版本选型: H版 采用伦敦地铁站来命名. Hoxton.SR3 Spring Boot 和 Spring Cloud 版本匹配对应 Release Train Boot Version Hoxton 2.2.x Greenwich 2.1.x Finchley 2.0.x Edgware 1.5.x Dalston 1.5.x 查看版本匹配关系 https://start.spring.io/actuator/info \"Hoxton.SR3\":\"Spring Boot >=2.2.0.M4 and 或者在Spring官网Spring Cloud Reference Doc点进去可以看到,推荐的匹配版本 Release Train Version: Hoxton.SR3 Supported Boot Version: 2.2.5.RELEASE Spring Cloud 和 Spring Cloud Alibaba版本对应关系 https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E Spring Cloud Version Spring Cloud Alibaba Version Spring Boot Version Spring Cloud Hoxton.SR3 2.2.1.RELEASE 2.2.5.RELEASE Spring Cloud Hoxton.RELEASE 2.2.0.RELEASE 2.2.X.RELEASE Spring Cloud Greenwich 2.1.2.RELEASE 2.1.X.RELEASE Spring Cloud Finchley 2.0.2.RELEASE 2.0.X.RELEASE Spring Cloud Edgware 1.5.1.RELEASE 1.5.X.RELEASE Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-22 14:14:05 "},"program/SpringCloud/project.html":{"url":"program/SpringCloud/project.html","title":"微服务框架","keywords":"","body":"Spring Cloud 工程搭建 环境准备 约定 > 配置 > 编码 工程结构 project --module Maven Maven 选择3.5.2以上 开启跳过maven单元测试 skip test 字符编码 settings - Editor - File Encodings: Global Encoding UTF-8 Project Encoding UTF-8 Default encoding for properties files: UTF-8 注解激活生效 setting-build-compiler-Annotation Processors 打钩 Enable annotation processing Java编译版本 setting-build-compiler-Java Compiler 选择java版本8 File Type 过滤 settings - Editor - File Types 添加不需要显示的文件 父工程 (聚合模块) 项目创建 创建标准maven项目, 项目下面只保留pom文件. pom文件 4.0.0 org.springframework.boot spring-boot-starter-parent 2.2.5.RELEASE com.yangb microservice 0.0.1-SNAPSHOT pom microservice 微服务框架 http://book.yangb.xyz 2.2.5.RELEASE Hoxton.SR3 2.2.1.RELEASE UTF-8 1.8 1.8 4.12 1.2.17 1.16.18 5.1.47 1.1.16 1.3.0 org.springframework.boot spring-boot-dependencies ${spring-boot.version} pom import org.springframework.cloud spring-cloud-dependencies ${spring-cloud.version} pom import com.alibaba.cloud spring-cloud-alibaba-dependencies ${spring-cloud-alibaba.version} mysql mysql-connector-java ${mysql.version} com.alibaba druid ${druid.version} org.mybatis.spring.boot mybatis-spring-boot-starter ${mybatis.spring.boot.version} junit junit ${junit.version} log4j log4j ${log4j.version} org.projectlombok lombok ${lombok.version} true org.springframework.boot spring-boot-maven-plugin true true 业务子模块 微服务模块步骤: 建model 改POM 写YML 主启动 业务类 例如: 支付模块 pom.xml microservice com.yangb 0.0.1-SNAPSHOT 4.0.0 business-payment jar 业务模块 - 支付 org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-actuator org.mybatis.spring.boot mybatis-spring-boot-starter com.alibaba druid-spring-boot-starter 1.1.10 mysql mysql-connector-java org.springframework.boot spring-boot-starter-jdbc org.springframework.boot spring-boot-devtools runtime true org.projectlombok lombok true org.springframework.boot spring-boot-starter-test test application.yml server: port: 8001 spring: application: name: payment-service datasource: druid: url: jdbc:mysql://localhost:3306/quick_db?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=UTC username: root password: root initial-size: 1 min-idle: 1 max-active: 20 test-on-borrow: true # driver-class-name: com.mysql.jdbc.Driver driver-class-name: com.mysql.cj.jdbc.Driver # MySql8.x mybatis: mapper-locations: classpath:mapper/*.xml type-aliases-package: com.yangb.business.payment.entity 主启动 /** * Created by YangBin on 2020/4/22 * Copyright (c) 2020 杨斌. All rights reserved. */ @SpringBootApplication public class PaymentServer { public static void main(String[] args) { SpringApplication.run(PaymentServer.class, args); } } 整合Spring Boot 单体应用快速开发框架 https://github.com/yangb92/SpringBootQuickDevlop 授权模块我们最后使用OAuth2.0统一认证, 先不进行整合. 可参考本文档SpringBoot章节 模块名称 描述 tk.mybatis 使用tk.mybatis框架,简化数据库操作。 PageHelper 分页插件 generator 自动生成Entity,Mapper和Dao 注册中心 见文档 服务发现 负载均衡 见文档 负载均衡 服务调用 见文档 服务调用 服务降级 参考文档Hystrix Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-23 15:39:36 "},"program/SpringCloud/Discover.html":{"url":"program/SpringCloud/Discover.html","title":"服务发现","keywords":"","body":"服务注册与发现 Eureka 服务端 建model 改POM 写YML 主启动 业务类 POM microservice com.yangb 0.0.1-SNAPSHOT 4.0.0 serve-discover jar org.springframework.cloud spring-cloud-starter-netflix-eureka-server org.springframework.boot spring-boot-maven-plugin true true application.yml server: port: 35001 eureka: instance: hostname: localhost client: register-with-eureka: false # 不向注册中心注册自己 fetch-registry: false # 注册中心不需要去检索服务 service-url: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ # 服务地址 主启动类 /** * Created by yangb on 2020/4/22 * Copyright (c) 2020 杨斌 All rights reserved. */ @SpringBootApplication @EnableEurekaServer public class DiscoverServer { public static void main(String[] args) { SpringApplication.run(DiscoverServer.class, args); } } 访问http://localhost:35001/ 客户端 POM org.springframework.cloud spring-cloud-starter-netflix-eureka-client application.yml # 服务注册 eureka: client: service-url: defaultZone: http://localhost:35001/eureka 在最新版本的Eurika,不需要在主启动类添加@EnableEurekaClient注解来开启了, 引入依赖自动注册服务 注册中心集群 互相注册,相互守望 修改系统hosts文件 127.0.0.1 eureka35001.com 127.0.0.1 eureka35002.com 服务端 application.yml 35001 服务 server: port: 35001 eureka: instance: hostname: eureka35001.com client: register-with-eureka: false # 不向注册中心注册自己 fetch-registry: false # 注册中心不需要去检索服务 service-url: defaultZone: http://eureka35002:35002/eureka/ # 服务地址 35002 服务 server: port: 35002 eureka: instance: hostname: eureka35002.com client: register-with-eureka: false # 不向注册中心注册自己 fetch-registry: false # 注册中心不需要去检索服务 service-url: defaultZone: http://eureka35001:35001/eureka/ # 服务地址 客户端 application.yml # 服务注册 eureka: client: service-url: defaultZone: http://eureka35001:35001/eureka,http://eureka35002:35002/eureka # 这里不一定要配置,因为默认提供的已经够用了 instance: instance-id: ${spring.application.name}:${server.port} # 实例信息 prefer-ip-address: true # 带实例IP地址 这里如果不改hosts文件, 所有地址使用默认的localhost也没有问题 Eureka自我保护机制 EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE. 如果我们在Eureka Server看到了这段提示, 说明Eureka进入了保护模式 原因 某时刻一个微服务不可用了,Eureka不会立刻清理,依旧会对该微服务的信息保存. 什么是自我保护 默认情况下, 如果Eureka在一定时间内没有接收到某个微服务实例的心跳, EurekaServer将会注销该实例(默认90s) 属于CAP里面的AP分支设计思想: 好死不如赖活着的设计哲学 关闭自我保护 服务端 eureka: server: enable-self-preservation: false # 关闭自我保护 eviction-interval-timer-in-ms: 3000 # 如果超过3秒收不到心跳,剔除此服务 客户端 eureka: instance: lease-renewal-interval-in-seconds: 30 # Eureka 客户端向服务端发送心跳的时间间隔 lease-expiration-duration-in-seconds: 90 # Eureka服务端在收到最后一次心跳后等待的时间上限, 超时将剔除服务 DiscoverClient @Autowired private DiscoveryClient discoveryClient; String clients = discoveryClient.getServices().stream() .map(item -> discoveryClient.getInstances(item).stream() .map(instance -> instance.getHost() + instance.getPort() + instance.getUri() + instance.getScheme() ).collect(Collectors.joining(\"|\"))) .collect(Collectors.joining(\"/\")); Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-23 17:58:18 "},"program/SpringCloud/ServiceCall.html":{"url":"program/SpringCloud/ServiceCall.html","title":"服务调用","keywords":"","body":"服务调用 OpenFeign 申明式的Web服务客户端, 只需要创建一个接口并在接口上添加注解即可. 本身已经集成了Ribbon支持负载均衡. pom.xml org.springframework.cloud spring-cloud-starter-openfeign 启动类配置 @SpringBootApplication @EnableFeignClients public class OrderServer { ... 远程接口 /** * Created by yangb on 2020/4/23 * Copyright (c) 2020 杨斌 All rights reserved. */ @FeignClient(\"PAYMENT-SERVICE\") public interface PaymentFeignService { @GetMapping(\"/payment/{id}\") ResultVo getPayment(@PathVariable(\"id\") Long id); } 超时控制 Feign 默认只等待1秒钟, 超时报错. 因为使用了ribbon, 所以配置ribbon的连接建立时间 配置超时时间: # feign 连接超时配置 ribbon: ReadTimeout: 5000 # 连接建立后响应时间 ConnectTimeout: 5000 # 建立连接所用的时间 日志功能 日志级别 NONE: 默认,不显示日志 BASIC: 记录请求方法,url,响应状态码和执行时间 HEADERS: 增加请求和响应头 FULL: 增加请求和响应的正文 配置类 /** * Created by yangb on 2020/4/23 * Copyright (c) 2020 杨斌 All rights reserved. */ @Configuration public class FeignConfig { @Bean Logger.Level feignLoggerLevel(){ return Logger.Level.FULL; } } application.yml logging: level: com.yangb.business.order.service.PaymentFeignService: debug # feign日志以什么级别监控哪个接口 Ribbon + HttpTemplate Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-23 15:36:08 "},"program/SpringCloud/Breaker.html":{"url":"program/SpringCloud/Breaker.html","title":"断路器","keywords":"","body":"断路器 学习方法: 在Github找源码看WIKI 理论学习 服务降级 服务器忙,请稍后再试. 不让客户端等待立刻fullback. 那些情况会出现降级 程序运行异常 超时 服务熔断出发服务降级 线程池/信号量打满也会导致服务降级 服务熔断 类似保险丝, 达到最大服务访问后,直接拒绝访问,然后调用降级的方法并返回友好提示 降级 -> 熔断 ->恢复调用线路 服务限流 高并发操作,严禁一窝蜂过来拥挤. 一秒N个, 有序进行. Hystrix(停更) Sentinel Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-23 17:54:57 "},"program/SpringCloud/gateway.html":{"url":"program/SpringCloud/gateway.html","title":"服务网关","keywords":"","body":"服务网关 Spring Cloud Gateway Gateway 是 Zull1.x 的替代. 概念 (1) 功能特性 基于异步非阻塞模型上进行开发, 在 Spring Framework 5, Project Reactor 和 Spring Boot 2.0 进行构建. 特性: 动态路由 对路由指定 Predicate (断言) 和 Filter (过滤器). 集成 Hystrix 断路器 集成 Spring Cloud 服务发现 限流 路径重写 (2) 与Zuul的区别 Zuul1.x 基于 Servlet2.5 之上的一个阻塞式处理模型, 在高并发不具优势. Gateway 用的是 Spring WebFlux 是 Spring 5.0 引入新的响应式框架. (3) 核心概念 Route (路由) Predicate (断言) Filter (过滤) (4) 工作流程 Client -> Spring Cloud Gateway -> Gateway Handler Mapping -> Gateway Web Handler -> Filter -> Proxied Service 用法 (1) pom.xml 配置 org.springframework.cloud spring-cloud-starter-gateway org.springframework.cloud spring-cloud-starter-netflix-eureka-client (2) application.yml 配置 server: port: 35002 spring: application: name: gateway-serve cloud: gateway: routes: - id: payment-service # 路由的id, 要求唯一 uri: http://localhost:8001 # 匹配后提供服务的路由地址 predicates: - Path=/payment/** # 断言,路径匹配进行路由 - id: order-service uri: http://localhost:8002 predicates: - Path=/order/** eureka: instance: hostname: gateway-serve client: service-url: defaultZone: http://localhost:35001/eureka (3) 编码方式配置路由 参考官方文档. Tip: 你会发现还是通过yml配置路由简单一点. (4) 动态路由配置 application.yml ... spring: application: name: gateway-serve cloud: gateway: discovery: locator: enabled: true # 开启从注册中心动态创建路由的功能 routes: - id: payment-service uri: lb://PAYMENT-SERVICE # 注册中心服务地址 predicates: - Path=/payment/** ... lb://... 说明: lb 指 loadbalance (5) 断言 Predicate 官方文档 断言列表: After Route Predicate 在指定日期时间之后请求 predicates: - After=2017-01-20T17:42:47.789-07:00[America/Denver] Before Route Predicate 在指定日期时间之前请求 predicates: - Before=2017-01-20T17:42:47.789-07:00[America/Denver] Between Route Predicate 在指定日期时间之间请求 predicates: - Between=2017-01-20T17:42:47.789-07:00[America/Denver], 2017-01-21T17:42:47.789-07:00[America/Denver] Cookie Route Predicate 匹配具有给定名称且其值与正则表达式匹配的 cookie predicates: - Cookie=chocolate, ch.p Header Cookie Route Predicate 名称且其值与正则表达式匹配的 head 匹配 predicates: - Header=X-Request-Id, \\d+ Host Route Predicate 主机名匹配 predicates: - Host=**.somehost.org,**.anotherhost.org Method Route Predicate 方法匹配 predicates: - Method=GET,POST Path Route Predicate 路径匹配 predicates: - Path=/red/{segment},/blue/{segment} Query Route Predicate 参数匹配, 参数名称和参数值得正则表达式 predicates: - Query=red, gree. RemoteAddr Route Predicate IP地址匹配 ip地址/子网掩码 predicates: - RemoteAddr=192.168.1.1/24 Weight Route Predicate 配置权重, 组名称和权重值,权重是按组计算的,将20%的流量转发到这个路由 predicates: - Weight=group1, 2 (6) 过滤器 Filter 官方文档 官方自带30个过滤器网关过滤器和10个全局过滤器. 自定义过滤器 @Component @Slf4j public class AuthorizationFilter implements GlobalFilter, Ordered { @Override public Mono filter(ServerWebExchange exchange, GatewayFilterChain chain) { log.info(\"*** Coming to AuthorizationFilter\"); String uname = exchange.getRequest().getQueryParams().getFirst(\"uname\"); if (uname == null) { log.info(\"*** 用户名为Null,非法用户!\"); exchange.getResponse() .setStatusCode(HttpStatus.NON_AUTHORITATIVE_INFORMATION); return exchange.getResponse().setComplete(); } return chain.filter(exchange); } @Override public int getOrder() { // 过滤器顺序.数字越小,优先级越高 return 0; } } Spring Cloud Netflix Zuul ( 已停用 ) Zuul 1.x 版本已停用, Zuul2.0 还在开发中. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-24 11:26:17 "},"program/SpringSecurity/":{"url":"program/SpringSecurity/","title":"SpringSecurity","keywords":"","body":"Spring Security Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-15 09:09:31 "},"program/SpringSecurity/AuthenticationProvider.html":{"url":"program/SpringSecurity/AuthenticationProvider.html","title":"自定义认证对象","keywords":"","body":"自定义认证方式 自定义认证提供者 @Component public class DaoAuthenticationProvider implements AuthenticationProvider { @Autowired private AppUserMapper appUserMapper; @Autowired private AppPermissionMapper permissionMapper; @Autowired private PasswordEncoder passwordEncoder; @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException { String username = authentication.getName(); String password = authentication.getCredentials().toString(); AppUser user = appUserMapper.queryByUsername(username); if(user == null){ throw new UsernameNotFoundException(\"用户未找到\"); } if(!passwordEncoder.matches(password,user.getPassword())){ throw new BadCredentialsException(\"密码错误\"); } List permissions = permissionMapper.queryByUserid(user.getId()); return new UsernamePasswordAuthenticationToken(user,password, AuthorityUtils.createAuthorityList(permissions.stream().map(item -> item.getCode()).toArray(String[]::new))); } @Override public boolean supports(Class authentication) { return (UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication)); } } 在WebSecurityConfig中注入 /** * @author Created by yangb on 2020/4/14 */ @Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled = true) public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Resource private DaoAuthenticationProvider daoAuthenticationProvider; @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.authenticationProvider(daoAuthenticationProvider); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\").hasAuthority(\"ADMIN\") .anyRequest().authenticated() .and() .formLogin() .loginProcessingUrl(\"/login\") .successHandler((request, response, authentication) -> { //登陆陈宫返回json数据 response.setContentType(\"application/json;charset=utf-8\"); PrintWriter out = response.getWriter(); out.write(JSON.toJSONString(ResultVo.makeSuccess(\"登陆成功\"))); out.flush(); out.close(); }) .failureHandler((request, response, exception) -> { //登陆失败返回json数据 response.setContentType(\"application/json;charset=utf-8\"); PrintWriter out = response.getWriter(); ResultVo result = ResultVo.makeFailed(exception.getMessage()); out.write(JSON.toJSONString(result)); out.flush(); out.close(); }) .permitAll() .and() .csrf().disable() .exceptionHandling().authenticationEntryPoint((request, response, authException) -> { //访问未授权的资源返回数据 response.setContentType(\"application/json;charset=utf-8\"); PrintWriter out = response.getWriter(); out.write(JSON.toJSONString(ResultVo.makeFailed(\"请登录后访问\"))); out.flush(); out.close(); }); } } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-15 08:51:03 "},"program/SpringSecurity/SpringSecurity.html":{"url":"program/SpringSecurity/SpringSecurity.html","title":"SpringSecurity单体应用","keywords":"","body":"Spring Security 基础概念 认证 会话 授权 授权的数据模型 主体 资源 权限 角色 角色和权限关系 主体和角色关系 通常企业开发中将资源和权限表合并为一张表. 数据模型如下: 用户 - 用户角色关系 -> 角色 - 角色权限关系 -> 权限 RBAC 业界的授权方案 基于角色的访问控制 Role-Base Access Control 基于资源的访问控制 Resource-Based Access Control 基于Session的认证方式 Spring Security WebSecurityConfig 用户信息 密码编码器 安全拦截机制 结构总览 解决用户的 安全访问控制, Spring Security 对web资源的保护是靠Filter实现的. SpringSecurityFilterChain 是一个 Servlet 过滤器 实现了 javax.servlet.Filter. 过滤外部请求. FilterChainProxy代理了多个Filter, 形成Filter链表. AuthenticationManager 负责授权, AccessDecisionManager 负责认证, 自定义UserDetailService @Service public class SpringDataUserDetailService implements UserDetailsService PasswordEncoder 使用BCryptPasswordEncoder加密 @Bean public PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } BCrypt 加密,每次加密结果都不一样,但是校验可以通过,增加了安全性 // 加密原始密码 String hashpw = BCrypt.hashpw(\"123\", BCrypt.gensalt()); System.out.println(hashpw); //校验密码一致性 boolean checkpw = BCrypt.checkpw(\"123\", \"$2a$10$e/Vgw1zKQDdyxd/DvyNSMeeT0TQhaDB9KbUoN8jC2f8MV9lGUobcy\"); System.out.println(checkpw); boolean checkpw1 = BCrypt.checkpw(\"123\", \"$2a$10$jIueZHE5S7WJjnZrD//HDugBxKsdLdYfuarmXC.R8S6rJqCv3ifEu\"); System.out.println(checkpw1); 安全拦截 @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/r/r1\").hasAuthority(\"p1\") .antMatchers(\"/r/r2\").hasAuthority(\"p2\") .antMatchers(\"/r\").authenticated() .anyRequest().permitAll() .and() .formLogin(); } 自定义登录页面 增加登录页面 @GetMapping(\"/login-view\") public String login(){ return \"login\"; } 自定义登录页面 login.html 用户名: 密码: 配置http安全设置 @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() ... .formLogin() .loginPage(\"/login-view\") // 登录页面 .loginProcessingUrl(\"/login\") //登录路径 .successForwardUrl(\"/r\") //登录成功跳转路径 .permitAll() .and() .csrf().disable(); // 关闭csrf安全验证 连接数据库认证 添加数据库依赖 org.springframework.boot spring-boot-starter-data-jdbc mysql mysql-connector-java 5.1.48 配置数据库 spring: datasource: username: root password: root url: jdbc:mysql://localhost:3306/user_db driver-class-name: com.mysql.jdbc.Driver 实体DTO @Data @Table(\"t_user\") public class UserDto { @Id private String id; private String username; private String password; private String fullname; private String mobile; } Dao @Repository public interface UserDao extends CrudRepository { @Query(\"SELECT * FROM `t_user` where username=:username\") UserDto findByUsername(@Param(\"username\") String username); } UserDetailService @Autowired private UserDao userDao; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { UserDto userDto = userDao.findByUsername(username); if(userDto == null){ // 如果用户查不到, 返回null, 由provider抛出异常 return null; } UserDetails details = User.withUsername(userDto.getUsername()).password(userDto.getPassword()).authorities(\"p1\").build(); return details; } 会话管理 获取用户身份 //获取当前用户信息 private String getUsername(){ Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); Object principal = authentication.getPrincipal(); if(principal == null){ return \"匿名用户\"; } if (principal instanceof UserDetails){ UserDetails userDetails = (UserDetails) principal; return userDetails.getUsername(); }else { return principal.toString(); } } 会话控制 机制 描述 always 如果没有session存在就创建一个 ifRequired 如果需要就创建一个Session(默认)登录时 never SpringSecurity将不会创建Session,但是如果应用中其他地方创建了Session,那么SpringSecurity将使用它 stateless 绝对不会创建和使用 配置方式 @Override protected void configure(HttpSecurity http) throws Exception { http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED); 自定义退出 .logout() .logoutUrl(\"/logout\") //退出地址 .logoutSuccessUrl(\"/index\"); //退出页面 Web的授权 使用资源授权, 更灵活. http.authorizeRequests() .antMatchers(\"/r/r1\").hasAuthority(\"p1\") .antMatchers(\"/r/r2\").hasAuthority(\"p2\") .antMatchers(\"/r/r3\").hasAnyAuthority(\"p1\",\"p2\") .antMatchers(\"/r/r4\").access(\"hasAuthority('p1') and hasAuthority('p2')\") .antMatchers(\"/r/**\").authenticated() .anyRequest().permitAll() 方法授权 建议基于Controller进行拦截 开启方法拦截 @EnableGlobalMethodSecurity(prePostEnabled = true) //开启方法授权 public class WebSecurityConfig extends WebSecurityConfigurerAdapter{ @PreAuthorize 在方法上加注解 p1 权限才能访问 @RequestMapping(\"/r/r1\") @PreAuthorize(\"hasAuthority('p1')\") public String r1(ModelMap map){ map.put(\"name\", \"权限1页面\"); return \"index\"; } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 10:16:54 "},"program/SpringSecurity/SpringSecurityOAuth2.html":{"url":"program/SpringSecurity/SpringSecurityOAuth2.html","title":"SpringSecurityOAuth2.0认证中心","keywords":"","body":"分布式系统认证方案 基于Token的认证方式更适合分布式认证. 项目搭建 https://github.com/yangb92/SpringAuthorization/tree/spring-cloud-security-oauth2 配置授权服务 创建配置类,开启认证服务 @Configuration @EnableAuthorizationServer public class AuthorizationServer extends AuthorizationServerConfigurerAdapter { 配置客户端详细信息 clentId: (必须) 客户id标识 secret: 客户端安全码 scope: 客户端权限 authorizedGrantTypes: 客户端授权类型,默认为空 authorities: 此客户端可以使用的授权类型,默认为空 内存方式配置客户端 @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient(\"c1\") .secret(new BCryptPasswordEncoder().encode(\"secret\")) //客户端秘钥 .resourceIds(\"res1\", \"res2\") //可访问资源列表 .authorizedGrantTypes(\"authorization_code\", \"password\", \"client_credentials\", \"implicit\", \"refresh_token\") //运行授权的类型 .scopes(\"all\") //允许授权的范围 .autoApprove(false) // false 跳转到授权页面 .redirectUris(\"http://www.baidu.com\") //授权回调地址 .and() .withClient ... } 配置令牌访问的端点和令牌服务 令牌服务 TokenStore: 令牌存储策略 InMemoryTokenStore: 存储在内存 工作在单服务器 JdbcTokenStore: 存储在数据库 可以在多个服务器共享 JwtTokenStore: 不需要后端存储 配置存储方式令牌 存在内存 @Configuration public class TokenConfig { @Bean public TokenStore tokenStore() { return new InMemoryTokenStore(); } } 配置令牌管理服务 @Autowired private TokenStore tokenStore; @Autowired private ClientDetailsService clientDetailsService; // 令牌管理服务 @Bean public AuthorizationServerTokenServices tokenServices() { DefaultTokenServices services = new DefaultTokenServices(); services.setClientDetailsService(clientDetailsService); // 客户端详情服务 services.setSupportRefreshToken(true); // 支持令牌刷新 services.setTokenStore(tokenStore); // 令牌存储策略 services.setAccessTokenValiditySeconds(7200); // 令牌有效期2小时 services.setRefreshTokenValiditySeconds(259200); // 刷新令牌默认有效期3天 return services; } 令牌访问端点配置 AuthorizationServerEndpointsConfigurer 通过设定以下属性决定支持的授权类型(Grant Types) authenticationManager: 认证管理器,password授权类型.用于密码模式需要配置 UserDetailService: 用于密码模式需要配置 authorizationCodeServices: 设置授权码服务的,用于authorization_code授权类型 implicitGrantService: 用于设置隐式授权模式. tokenGranter: 当设置了即TokenGranter接口实现, 授权将由自己掌控, 这个一般用来做扩展用途. 配置授权端点的URL(Endpoint URLs) AuthorizationServerEndpointsConfiguration 这个配置对象有一个叫做pathMapping()的方法用来配置端点的URL连接 第一个参数:默认连接, 第二个参数:你需要替换的连接 框架默认的连接如下: /oauth/authorize: 授权端点 /oauth/token: 令牌端点 /oauth/confirm_access: 用户确认授权端点 /oauth/error: 授权服务错误信息端点 /oauth/check_token: 用于资源服务访问的令牌解析端点 /oauth/token_key: 提供公有密匙的端点, 如果使用JWT令牌的话 WebSecurity配置 @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) @Configuration public class WebSecurityConfig extends WebSecurityConfigurerAdapter { // 认证管理器 @Bean @Override protected AuthenticationManager authenticationManager() throws Exception { return super.authenticationManager(); } // 密码编码器 @Bean public PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } // 安全拦截机制 @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/r/r1\").hasAuthority(\"p1\") .antMatchers(\"/login**\").permitAll() .anyRequest().authenticated() .and() .formLogin(); } } 配置令牌访问端点和授权码服务 @Configuration @EnableAuthorizationServer public class AuthorizationServer extends AuthorizationServerConfigurerAdapter { @Autowired private TokenStore tokenStore; @Autowired private ClientDetailsService clientDetailsService; @Autowired private AuthorizationCodeServices authorizationCodeServices; @Autowired private AuthenticationManager authenticationManager; @Autowired private AuthorizationServerTokenServices tokenServices; // 令牌访问端点 @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints.authenticationManager(authenticationManager) //认证管理器 .authorizationCodeServices(authorizationCodeServices) // 授权码服务 .tokenServices(tokenServices) // 令牌管理服务 .allowedTokenEndpointRequestMethods(HttpMethod.POST); } // 配置授权码服务 @Bean public AuthorizationCodeServices authorizationCodeServices() { // 设置授权码模式的授权码如何存取,暂时采用内存方式 return new InMemoryAuthorizationCodeServices(); } ... 配置令牌端点的安全约束 // 令牌访问安全约束 @Override public void configure(AuthorizationServerSecurityConfigurer security) throws Exception { security .tokenKeyAccess(\"permitAll()\") //oauth/token_key 是公开 .checkTokenAccess(\"permitAll()\") //oauth/check_token 公开 .allowFormAuthenticationForClients(); //表单认证 } 授权码模式 最为安全 资源拥有者打开客户端,客户端要求资源拥有者给予授权,它将被浏览器重定向到服务器,重定向时会附加客户端身份信息./uaa/oauth/authorize?client_id=c1&response_type=code&scope=all&redirect_url=http://www.baidu.com/ 参数: client_id: 客户端标识 response_type: 授权码模式固定位code scope:客户端权限 redirect: 跳转url,授权码申请成功后跳转到此地址,并在后面带上code参数(授权码) 和配置客户端跳转url一致 浏览器重定向授权服务器授权页面,之后用户将同意授权 授权服务器授权码(AuthorizationCode)带到url参数上发送给client(通过redirect_uri) 客户端拿着授权码向授权服务器索要访问access_token/uaa/oauth/token?client_id=c1&client_secret=secret&grant_type=authorization_code&code=5pgxfcD&redirect_uri=http://www.baidu.com/ 参数: cilent_id: 客户端标识 secret: 客户端密匙 grant_type: 授权类型 code: 授权码, 注意:授权码只使用一次就无效了. redirect_uri: 和配置客户端跳转url一致 服务器返回授权码 { \"access_token\": \"6b94c4c1-1803-484e-b5da-943b96266ff1\", \"token_type\": \"bearer\", \"refresh_token\": \"8b4a2631-ef09-4145-9f32-f96b0904e5d8\", \"expires_in\": 43199, \"scope\": \"all\" } 简化模式 资源拥有者打开客户端,要求资源拥有者给与授权,它将被浏览器重定向到授权服务器, 重定向时会附加客户端信息. /uaa/oauth/authorize?client_id=c1&response_type=token&scope=all&redirect_uri=http://www.baidu.com response_type=token 说明是简化模式 浏览器重定向到授权服务器页面,用户同意授权 授权服务器将令牌,以Hash的形式存放在重定向uri的fragment发送给浏览器.https://www.baidu.com/#access_token=6b94c4c1-1803-484e-b5da-943b96266ff1&token_type=bearer&expires_in=42776 注: fragment http://example.com#L18 这个L18就是fragment的值. 一般来说,简化模式用于没有服务端的第三方单页面应用. 密码模式 资源拥有者将用户名,密码发送给客户端. 客户端拿着用户名和密码向授权服务器请求令牌/uaa/oauth/token?client_id=c1&client_secret=secret&grant_type=password&username=lisi&password=123 授权服务器将令牌发送给client] 这种模式十分简单,意味着直接将用户敏感信息泄露给了client, 因此这种模式只适用于我们自己的系统 客户端模式 客户端向授权服务器发送自己的身份信息,并请求令牌 确认客户端身份无误后,将令牌发送给clien /uaa/oauth/token?client_id=c1&client_secret=secret&grant_type=client_credentials 资源服务器配置 资源服务配置 测试: GET http://localhost:53021/order/r1 首先申请Token,将Token放在请求头中,访问资源服务接口 Authorization:Bearer 6b94c4c1-1803-484e-b5da-943b96266ff1 JWT 令牌 介绍 JWT令牌本身存储了用户信息.不需要进行存储. 优点: 基于json 自定义内容,易扩展. 非对称加密,防篡改,安全 资源服务使用JWT不依赖认证服务. 缺点: 令牌过长, 占用空间大. JWT令牌结构 Header Payload Signture UAA 认证端配置 配置: JWT TockenStore private String SIGN_KEY = \"123\"; @Bean public TokenStore tokenStore() { // JWT 令牌存储方案 return new JwtTokenStore(accessTokenConverter()); } // 令牌转换器 @Bean public JwtAccessTokenConverter accessTokenConverter() { JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); converter.setSigningKey(SIGN_KEY); // 对称密匙 return converter; } 配置令牌管理服务 // 令牌管理服务 @Bean @DependsOn({\"tokenStore\",\"accessTokenConverter\"}) public AuthorizationServerTokenServices tokenServices(ClientDetailsService clientDetailsService) { DefaultTokenServices services = new DefaultTokenServices(); services.setClientDetailsService(clientDetailsService); // 客户端详情服务 services.setSupportRefreshToken(true); // 支持令牌刷新 services.setTokenStore(tokenStore); // 令牌存储策略 // 令牌增强 TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain(); tokenEnhancerChain.setTokenEnhancers(Arrays.asList(accessTokenConverter)); services.setTokenEnhancer(tokenEnhancerChain); services.setAccessTokenValiditySeconds(7200); // 令牌有效期2小时 services.setRefreshTokenValiditySeconds(259200); // 刷新令牌默认有效期3天 return services; } 资源服务配置 TokenConfig @Configuration public class TokenConfig { private String SIGN_KEY = \"123\"; @Bean public TokenStore tokenStore() { // JWT 令牌存储方案 return new JwtTokenStore(accessTokenConverter()); } // 令牌转换器 @Bean public JwtAccessTokenConverter accessTokenConverter() { JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); converter.setSigningKey(SIGN_KEY); // 对称密匙 return converter; } } 资源服务配置 @Override public void configure(ResourceServerSecurityConfigurer resources) throws Exception { resources.resourceId(RESOURCE_ID) // .tokenServices(tokenServices) //验证令牌的服务 .tokenStore(tokenStore) .stateless(true); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 10:50:18 "},"program/SpringSecurity/ContextRepository.html":{"url":"program/SpringSecurity/ContextRepository.html","title":"Redis会话共享","keywords":"","body":"定制 Security 上下文存储 使用Redis管理会话 Docker Redis安装 在目录/usr/local/docker/redis创建docker-compose.yml配置文件 docker-compose.yml version: '3' services: redis: image: redis:5 container_name: redis restart: always ports: - '6379:6379' volumes: - ./data:/data 运行 docker-compose up -d 加入Redis依赖 org.springframework.boot spring-boot-starter-data-redis application.yml配置文件 spring: redis: host: 192.168.10.45 timeout: 3000 配置RedisConfig.java配置文件 /** * Created by yangb on 2020/4/17 */ @Configuration public class RedisConfig { @Bean public RedisTemplate securityContextRedisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); template.setValueSerializer(new SecurityContextSerializer()); return template; } /** * SecurityContext 序列化 */ private class SecurityContextSerializer implements RedisSerializer{ @Override public byte[] serialize(SecurityContext securityContext) throws SerializationException { if (securityContext == null) { return null; } String s = JSON.toJSONString(securityContext); return s.getBytes(Charset.forName(\"UTF-8\")); } @Override public SecurityContext deserialize(byte[] bytes) throws SerializationException { SecurityContextImpl securityContext = new SecurityContextImpl(); if (bytes == null) { return securityContext; } String json = new String(bytes, Charset.forName(\"UTF-8\")); final JSONObject jb = JSON.parseObject(json); JSONObject authentication = jb.getJSONObject(\"authentication\"); if(authentication == null) { return securityContext; } AppUser user = authentication.getObject(\"principal\", AppUser.class); JSONArray authorities = authentication.getJSONArray(\"authorities\"); String [] authoritiesArray = new String[authorities.size()]; for (int i = 0; i 配置RedisSecurityContextRepository.java上下文仓库 /** * Created by yangb on 2020/4/17 */ @Component public class RedisSecurityContextRepository implements SecurityContextRepository { @Resource private RedisTemplate securityContextRedisTemplate; @Override public SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder) { String requestedSessionId = requestResponseHolder.getRequest().getRequestedSessionId(); return securityContextRedisTemplate.opsForValue().get(requestedSessionId); } @Override public void saveContext(SecurityContext context, HttpServletRequest request, HttpServletResponse response) { String requestedSessionId = request.getRequestedSessionId(); securityContextRedisTemplate.opsForValue().set(requestedSessionId,context,30, TimeUnit.MINUTES); } @Override public boolean containsContext(HttpServletRequest request) { return securityContextRedisTemplate.hasKey(request.getRequestedSessionId()); } /** * 清除Redis上下文 */ public boolean cleanContext(HttpServletRequest request){ return securityContextRedisTemplate.delete(request.getRequestedSessionId()); } } 配置上下文仓库 和 退出时执行清除Redis中上下环境, @Override protected void configure(HttpSecurity http) throws Exception { http .securityContext() .securityContextRepository(redisSecurityContextRepository); .logout() .logoutSuccessHandler((request, response, authentication) -> { redisSecurityContextRepository.cleanContext(request); //清除缓存会话 }) ... Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 17:24:32 "},"program/SpringMVC/":{"url":"program/SpringMVC/","title":"SpringMVC","keywords":"","body":"Spring MVC Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-15 09:00:55 "},"program/SpringMVC/HandlerMethodArgumentResolver.html":{"url":"program/SpringMVC/HandlerMethodArgumentResolver.html","title":"自定义参数解析器","keywords":"","body":"自定义参数解析器 HandlerMethodArgumentResolver 定义注解 /** * 标记当前用户注解, 由MVC参数解析器注入 * @author Created by yangb on 2020/4/14 */ @Target({ElementType.PARAMETER}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface CurrentUser { } 定义参数解析器UserHandlerMethodArgumentResolver.java /** * 自定义参数解析器 * @author Created by yangb on 2020/4/14 */ public class UserHandlerMethodArgumentResolver implements HandlerMethodArgumentResolver { @Override public boolean supportsParameter(MethodParameter methodParameter) { //判断是否需要解析参数, 如果方法参数有CurrentUser注解,需要解析返回true return methodParameter.hasParameterAnnotation(CurrentUser.class); } @Override public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception { // 解析参数,返回参数对象 Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal(); if(principal instanceof AppUser){ return (AppUser) principal; } return null; } } 在MVC中配置该参数解析器 @Configuration public class WebMvcConfig implements WebMvcConfigurer { /** * 添加参数解析器 * @param resolvers */ @Override public void addArgumentResolvers(List resolvers) { resolvers.add(new UserHandlerMethodArgumentResolver()); } } 在Controller中使用 @RequestMapping(\"/admin\") public ResultVo admin(@CurrentUser AppUser user) { return ResultVo.makeSuccess(user); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-15 09:01:55 "},"program/Docker/":{"url":"program/Docker/","title":"Docker","keywords":"","body":"Docker Docker 文档: https://www.funtl.com/zh/docs-docker/ 基本概念 Docker 包括三个基本概念 镜像（Image） Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 分层存储:镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。 容器（Container） 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。 按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。 仓库（Repository） 公有仓库 私有仓库 标题 说明 镜像(Images) Docker 镜像是用于创建 Docker 容器的模板。 容器(Container) 容器是独立运行的一个或一组应用。 客户端(Client) Docker 客户端通过命令行或者其他工具使用 Docker API (https://docs.docker.com/reference/api/docker_remote_api) 与 Docker 的守护进程通信。 主机(Host) 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。 仓库(Registry) Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。 Docker Machine Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 13:41:37 "},"program/Docker/install.html":{"url":"program/Docker/install.html","title":"Docker 安装","keywords":"","body":"Docker安装 Ubuntu 安装 脚本自动安装: curl -fsSL get.docker.com -o get-docker.sh sh get-docker.sh --mirror Aliyun 检测Docker是否安装成功 docker version 配置阿里云Docker镜像加速器 下载镜像 docker pull 镜像名称 启动镜像 docker run -p 80:8080 tomcat Docker 仓库 公共仓库: https://hub.docker.com Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 13:41:59 "},"program/Docker/Compose.html":{"url":"program/Docker/Compose.html","title":"Docker-Compose安装卸载","keywords":"","body":"Docker Compose 学习地址https://www.funtl.com/zh/docker-compose/ Docker 三剑客之一, 必会. 负责实现对Docker集群的快速编排. 安装 Compose 支持 Linux、macOS、Windows 10 三大平台。Compose 可以通过 Python 的包管理工具 pip 进行安装 二进制包 $ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose $ sudo chmod +x /usr/local/bin/docker-compose PIP 安装 $ sudo pip install -U docker-compose 测试 docker-compose version bash 补全命令 $ curl -L https://raw.githubusercontent.com/docker/compose/1.8.0/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose 容器中执行 Compose 既然是一个 Python 应用，自然也可以直接用容器来执行它。 $ curl -L https://github.com/docker/compose/releases/download/1.8.0/run.sh > /usr/local/bin/docker-compose $ chmod +x /usr/local/bin/docker-compose 卸载 如果是二进制包方式安装的，删除二进制文件即可。 $ sudo rm /usr/local/bin/docker-compose 如果是通过 pip 安装的，则执行如下命令即可删除。 $ sudo pip uninstall docker-compose 基本使用 编写docker-compose.yml 这个是Compose使用的主模板文件 version: '3' services: tomcat: restart: always image: tomcat container_name: tomcat ports: - 80:8080 运行compose项目 docker-compose up Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-15 10:49:02 "},"program/Docker/ComposeCommand.html":{"url":"program/Docker/ComposeCommand.html","title":"Docker-Compose命令说明","keywords":"","body":"Docker-Compose 命令说明 命令对象与格式 对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。 执行 docker-compose [COMMAND] --help 或者 docker-compose help [COMMAND] 可以查看具体某个命令的使用格式。 docker-compose 命令的基本的使用格式是 docker-compose [-f=...] [options] [COMMAND] [ARGS...] 命令选项 -f, --file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。 -p, --project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。 --x-networking 使用 Docker 的可拔插网络后端特性 --x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge --verbose 输出更多调试信息。 -v, --version 打印版本并退出。 build 格式为 docker-compose build [options] [SERVICE...]。 构建（重新构建）项目中的服务容器。 服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。 可以随时在项目目录下运行 docker-compose build 来重新构建服务。 选项包括： --force-rm 删除构建过程中的临时容器。 --no-cache 构建镜像过程中不使用 cache（这将加长构建过程）。 --pull 始终尝试通过 pull 来获取更新版本的镜像。 #config 验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。 #down 此命令将会停止 up 命令所启动的容器，并移除网络 #exec 进入指定的容器。 #help 获得一个命令的帮助。 #images 列出 Compose 文件中包含的镜像。 #kill 格式为 docker-compose kill [options] [SERVICE...]。 通过发送 SIGKILL 信号来强制停止服务容器。 支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。 $ docker-compose kill -s SIGINT 1 #logs 格式为 docker-compose logs [options] [SERVICE...]。 查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 --no-color 来关闭颜色。 该命令在调试问题的时候十分有用。 #pause 格式为 docker-compose pause [SERVICE...]。 暂停一个服务容器。 #port 格式为 docker-compose port [options] SERVICE PRIVATE_PORT。 打印某个容器端口所映射的公共端口。 选项： --protocol=proto 指定端口协议，tcp（默认值）或者 udp。 --index=index 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。 #ps 格式为 docker-compose ps [options] [SERVICE...]。 列出项目中目前的所有容器。 选项： -q 只打印容器的 ID 信息。 #pull 格式为 docker-compose pull [options] [SERVICE...]。 拉取服务依赖的镜像。 选项： --ignore-pull-failures 忽略拉取镜像过程中的错误。 #push 推送服务依赖的镜像到 Docker 镜像仓库。 #restart 格式为 docker-compose restart [options] [SERVICE...]。 重启项目中的服务。 选项： -t, --timeout TIMEOUT 指定重启前停止容器的超时（默认为 10 秒）。 #rm 格式为 docker-compose rm [options] [SERVICE...]。 删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。 选项： -f, --force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。 -v 删除容器所挂载的数据卷。 #run 格式为 docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]。 在指定服务上执行一个命令。 例如： $ docker-compose run ubuntu ping docker.com 1 将会启动一个 ubuntu 服务容器，并执行 ping docker.com 命令。 默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。 该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。 两个不同点： 给定命令将会覆盖原有的自动运行命令； 不会自动创建端口，以避免冲突。 如果不希望自动启动关联的容器，可以使用 --no-deps 选项，例如 $ docker-compose run --no-deps web python manage.py shell 1 将不会启动 web 容器所关联的其它容器。 选项： -d 后台运行容器。 --name NAME 为容器指定一个名字。 --entrypoint CMD 覆盖默认的容器启动指令。 -e KEY=VAL 设置环境变量值，可多次使用选项来设置多个环境变量。 -u, --user=\"\" 指定运行容器的用户名或者 uid。 --no-deps 不自动启动关联的服务容器。 --rm 运行命令后自动删除容器，d 模式下将忽略。 -p, --publish=[] 映射容器端口到本地主机。 --service-ports 配置服务端口并映射到本地主机。 -T 不分配伪 tty，意味着依赖 tty 的指令将无法运行。 #scale 格式为 docker-compose scale [options] [SERVICE=NUM...]。 设置指定服务运行的容器个数。 通过 service=num 的参数来设置数量。例如： $ docker-compose scale web=3 db=2 1 将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。 一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。 选项： -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 #start 格式为 docker-compose start [SERVICE...]。 启动已经存在的服务容器。 #stop 格式为 docker-compose stop [options] [SERVICE...]。 停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。 选项： -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 #top 查看各个服务容器内运行的进程。 #unpause 格式为 docker-compose unpause [SERVICE...]。 恢复处于暂停状态中的服务。 #up 格式为 docker-compose up [options] [SERVICE...]。 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。 链接的服务都将会被自动启动，除非已经处于运行状态。 可以说，大部分时候都可以直接通过该命令来启动一个项目。 默认情况，docker-compose up 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。 当通过 Ctrl-C 停止命令时，所有容器将会停止。 如果使用 docker-compose up -d，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。 默认情况，如果服务容器已经存在，docker-compose up 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 docker-compose up --no-recreate。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 docker-compose up --no-deps -d 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。 选项： -d 在后台运行服务容器。 --no-color 不使用颜色来区分不同的服务的控制台输出。 --no-deps 不启动服务所链接的容器。 --force-recreate 强制重新创建容器，不能与 --no-recreate 同时使用。 --no-recreate 如果容器已经存在了，则不重新创建，不能与 --force-recreate 同时使用。 --no-build 不自动构建缺失的服务镜像。 -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 #version 格式为 docker-compose version。 打印版本信息。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-15 10:51:07 "},"program/Docker/ComposeTemplate.html":{"url":"program/Docker/ComposeTemplate.html","title":"Docker-Compose模板文件","keywords":"","body":"Docker Compose 模板文件 模板文件是使用 Compose 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 docker run 相关参数的含义都是类似的。 默认的模板文件名称为 docker-compose.yml，格式为 YAML 格式。 version: \"3\" services: webapp: image: examples/web ports: - \"80:80\" volumes: - \"/data\" 注意每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）等来自动构建生成镜像。 如果使用 build 指令，在 Dockerfile 中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在 docker-compose.yml 中再次设置。 下面分别介绍各个指令的用法。 build 指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。 version: '3' services: webapp: build: ./dir 你也可以使用 context 指令指定 Dockerfile 所在文件夹的路径。 使用 dockerfile 指令指定 Dockerfile 文件名。 使用 arg 指令指定构建镜像时的变量。 version: '3' services: webapp: build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 使用 cache_from 指定构建镜像的缓存 build: context: . cache_from: - alpine:latest - corp/web_app:3.14 cap_add, cap_drop 指定容器的内核能力（capacity）分配。 例如，让容器拥有所有能力可以指定为： cap_add: - ALL 去掉 NET_ADMIN 能力可以指定为： cap_drop: - NET_ADMIN command 覆盖容器启动后默认执行的命令。 command: echo \"hello world\" configs 仅用于 Swarm mode cgroup_parent 指定父 cgroup 组，意味着将继承该组的资源限制。 例如，创建了一个 cgroup 组名称为 cgroups_1。 cgroup_parent: cgroups_1 container_name 指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式。 container_name: docker-web-container 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。 deploy 仅用于 Swarm mode devices 指定设备映射关系。 devices: - \"/dev/ttyUSB1:/dev/ttyUSB0\" #depends_on 解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web version: '3' services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres 注意：web 服务不会等待 redis db 「完全启动」之后才启动。 #dns 自定义 DNS 服务器。可以是一个值，也可以是一个列表。 dns: 8.8.8.8 dns: - 8.8.8.8 - 114.114.114.114 #dns_search 配置 DNS 搜索域。可以是一个值，也可以是一个列表。 dns_search: example.com dns_search: - domain1.example.com - domain2.example.com #tmpfs 挂载一个 tmpfs 文件系统到容器。 tmpfs: /run tmpfs: - /run - /tmp #env_file 从文件中获取环境变量，可以为单独的文件路径或列表。 如果通过 docker-compose -f FILE 方式来指定 Compose 模板文件，则 env_file 中变量的路径会基于模板文件路径。 如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准。 env_file: .env env_file: - ./common.env - ./apps/web.env - /opt/secrets.env 环境变量文件中每一行必须符合格式，支持 # 开头的注释行。 # common.env: Set development environment PROG_ENV=development #environment 设置环境变量。你可以使用数组或字典两种格式。 只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。 environment: RACK_ENV: development SESSION_SECRET: environment: - RACK_ENV=development - SESSION_SECRET 如果变量名称或者值中用到 true|false，yes|no 等表达 布尔 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括 y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF #expose 暴露端口，但不映射到宿主机，只被连接的服务访问。 仅可以指定内部端口为参数 expose: - \"3000\" - \"8000\" #external_links 注意：不建议使用该指令。 链接到 docker-compose.yml 外部的容器，甚至并非 Compose 管理的外部容器。 external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql #extra_hosts 类似 Docker 中的 --add-host 参数，指定额外的 host 名称映射信息。 extra_hosts: - \"googledns:8.8.8.8\" - \"dockerhub:52.1.157.61\" 会在启动后的服务容器中 /etc/hosts 文件中添加如下两条条目。 8.8.8.8 googledns 52.1.157.61 dockerhub #healthcheck 通过命令检查容器是否健康运行。 healthcheck: test: [\"CMD\", \"curl\", \"-f\", \"http://localhost\"] interval: 1m30s timeout: 10s retries: 3 #image 指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。 image: ubuntu image: orchardup/postgresql image: a4bc65fd #labels 为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。 labels: com.startupteam.description: \"webapp for a startup team\" com.startupteam.department: \"devops department\" com.startupteam.release: \"rc3 for v1.0\" #links 注意：不推荐使用该指令。 #logging 配置日志选项。 logging: driver: syslog options: syslog-address: \"tcp://192.168.0.42:123\" 目前支持三种日志驱动类型。 driver: \"json-file\" driver: \"syslog\" driver: \"none\" options 配置日志驱动的相关参数。 options: max-size: \"200k\" max-file: \"10\" #network_mode 设置网络模式。使用和 docker run 的 --network 参数一样的值。 network_mode: \"bridge\" network_mode: \"host\" network_mode: \"none\" network_mode: \"service:[service name]\" network_mode: \"container:[container name/id]\" #networks 配置容器连接的网络。 version: \"3\" services: some-service: networks: - some-network - other-network networks: some-network: other-network: #pid 跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。 pid: \"host\" #ports 暴露端口信息。 使用宿主端口：容器端口 (HOST:CONTAINER) 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。 ports: - \"3000\" - \"8000:8000\" - \"49100:22\" - \"127.0.0.1:8001:8001\" 注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。 #secrets 存储敏感数据，例如 mysql 服务密码。 version: \"3.1\" services: mysql: image: mysql environment: MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password secrets: - db_root_password - my_other_secret secrets: my_secret: file: ./my_secret.txt my_other_secret: external: true #security_opt 指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。 security_opt: - label:user:USER - label:role:ROLE #stop_signal 设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。 stop_signal: SIGUSR1 #sysctls 配置容器内核参数。 sysctls: net.core.somaxconn: 1024 net.ipv4.tcp_syncookies: 0 sysctls: - net.core.somaxconn=1024 - net.ipv4.tcp_syncookies=0 #ulimits 指定容器的 ulimits 限制值。 例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。 ulimits: nproc: 65535 nofile: soft: 20000 hard: 40000 #volumes 数据卷所挂载路径设置。可以设置宿主机路径 （HOST:CONTAINER） 或加上访问模式 （HOST:CONTAINER:ro）。 该指令中路径支持相对路径。 volumes: - /var/lib/mysql - cache/:/tmp/cache - ~/configs:/etc/configs/:ro #其它指令 此外，还有包括 domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir 等指令，基本跟 docker run 中对应参数的功能一致。 指定服务容器启动后执行的入口文件。 entrypoint: /code/entrypoint.sh 指定容器中运行应用的用户名。 user: nginx 指定容器中工作目录。 working_dir: /code 指定容器中搜索域名、主机名、mac 地址等。 domainname: your_website.com hostname: test mac_address: 08-00-27-00-0C-0A 允许容器中运行一些特权命令。 privileged: true 指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 always 或者 unless-stopped。 restart: always 以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。 read_only: true 打开标准输入，可以接受外部输入。 stdin_open: true 模拟一个伪终端。 tty: true #读取变量 Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 .env 文件中的变量。 例如，下面的 Compose 文件将从运行它的环境中读取变量 ${MONGO_VERSION} 的值，并写入执行的指令中。 version: \"3\" services: db: image: \"mongo:${MONGO_VERSION}\" 如果执行 MONGO_VERSION=3.2 docker-compose up 则会启动一个 mongo:3.2 镜像的容器；如果执行 MONGO_VERSION=2.8 docker-compose up 则会启动一个 mongo:2.8 镜像的容器。 若当前目录存在 .env 文件，执行 docker-compose 命令时将从该文件中读取变量。 在当前目录新建 .env 文件并写入以下内容。 # 支持 # 号注释 MONGO_VERSION=3.6 执行 docker-compose up 则会启动一个 mongo:3.6 镜像的容器。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-15 11:07:19 "},"program/Docker/demo.html":{"url":"program/Docker/demo.html","title":"Docker-Compose常用配置","keywords":"","body":"Docker 实战 Tomcat version: '3.1' services: tomcat: restart: always image: tomcat container_name: tomcat ports: - 8080:8080 volumes: - /usr/local/docker/tomcat/webapps/test:/usr/local/tomcat/webapps/test environment: TZ: Asia/Shanghai MySql MySQL5 version: '3.1' services: mysql: restart: always image: mysql:5.7.22 container_name: mysql ports: - 3306:3306 environment: TZ: Asia/Shanghai MYSQL_ROOT_PASSWORD: 123456 command: --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 --max_allowed_packet=128M --sql-mode=\"STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO\" volumes: - mysql-data:/var/lib/mysql volumes: mysql-data: MySQL8 version: '3.1' services: db: image: mysql restart: always environment: MYSQL_ROOT_PASSWORD: 123456 command: --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 ports: - 3306:3306 volumes: - ./data:/var/lib/mysql adminer: image: adminer restart: always ports: - 8080:8080 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-15 11:10:42 "},"program/CI/":{"url":"program/CI/","title":"持续集成 CI","keywords":"","body":"持续集成 方案一: gitlab -> gitrunner -> docker -> docker-compose Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 09:44:41 "},"program/CI/GitLabOnDocker.html":{"url":"program/CI/GitLabOnDocker.html","title":"Gitlab On Docker","keywords":"","body":"Gitlab Docker 安装 Gitlab Docker安装 获取Gitlab镜像 汉化版的gitlab docker pull twang2218/gitlab-ce-zh docker-compose.yml 配置gitlab 在 /usr/local/docker/gitlab'目录下,创建docker-compose.yml文件 version: '3' services: web: image: 'twang2218/gitlab-ce-zh' restart: always hostname: 'gitlab.yangb.xyz' environment: TZ: 'Asia/Shanghai' GITLAB_OMNIBUS_CONFIG: | external_url 'http://gitlab.yangb.xyz' prots: - '80:80' - '443:443' - '22:22' volumes: - /usr/local/docker/gitlab/config:/etc/gitlab - /usr/local/docker/gitlab/data:/var/opt/gitlab - /usr/local/docker/logs:/var/log/gitlab GITLAB_OMNIBUS_CONFIG: | 配置详解 external_url 'http://gitlab.yangb.xyz:8080' # 访问地址和端口 gitlab_rails['gitlab_shell_ssh_port'] = 2222 # ssh 访问端口,免密访问 unicorn['port'] = 8888 # 内部端口 nginx['listen_port'] = 8080 # nginx端口和上面端口需要一致 ports: #上面端口映射关系 '8080:8080' '8443:443' '2222:22' Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 09:42:23 "},"program/CI/GitLabRunnerDocker.html":{"url":"program/CI/GitLabRunnerDocker.html","title":"GilabRunner","keywords":"","body":"GitLab Runner linux 系统安装 添加依赖库 # For Debian/Ubuntu/Mint curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash # For RHEL/CentOS/Fedora curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh | sudo bash 安装 # MacOS sudo brew install gitlab-ci-multi-runner # For Debian/Ubuntu/Mint sudo apt-get install gitlab-ci-multi-runner # For RHEL/CentOS/Fedora sudo yum install gitlab-ci-multi-runner 常见问题: GitRunner 执行Docker 命令启动Permission Denied,需要将gitlab-runner加入Docker组 gpasswd -a gitlab-runner docker newgrp docker GitLab Runner Docker安装 使用GitLab CI 运行构建任务会影响GitLab性能. GitLab CI最大的作用是管理项目的构建状态,因此构建任务由GitLab Runner(GitLab 高级技能)来做. 环境准备 创建工作目录: /usr/local/docker/runner 创建构建目录: /usr/local/runner/evironment 下载jdk-8u152-linux-x64.tar.gz并复制到/usr/local/runner/evironment 下载apache-maven-3.5.3-bin.tar.gz并复制到/usr/local/docker/runner/environment daemon.json 在 /usr/local/docker/runner/environment 目录下创建 daemon.json，用于配置加速器和仓库地址 { \"registry-mirrors\": [ \"https://registry.docker-cn.com\" ], \"insecure-registries\": [ \"192.168.10.133:5000\" ] } Dockerfile 在 /usr/local/docker/runner/environment 目录下创建 Dockerfile FROM gitlab/gitlab-runner MAINTAINER Lusifer # 修改软件源 RUN echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse' > /etc/apt/sources.list && \\ echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse' >> /etc/apt/sources.list && \\ echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse' >> /etc/apt/sources.list && \\ echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse' >> /etc/apt/sources.list && \\ apt-get update -y && \\ apt-get clean # 安装 Docker RUN apt-get -y install apt-transport-https ca-certificates curl software-properties-common && \\ curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add - && \\ add-apt-repository \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\" && \\ apt-get update -y && \\ apt-get install -y docker-ce COPY daemon.json /etc/docker/daemon.json # 安装 Docker Compose WORKDIR /usr/local/bin RUN wget https://raw.githubusercontent.com/topsale/resources/master/docker/docker-compose RUN chmod +x docker-compose # 安装 Java RUN mkdir -p /usr/local/java WORKDIR /usr/local/java COPY jdk-8u152-linux-x64.tar.gz /usr/local/java RUN tar -zxvf jdk-8u152-linux-x64.tar.gz && \\ rm -fr jdk-8u152-linux-x64.tar.gz # 安装 Maven RUN mkdir -p /usr/local/maven WORKDIR /usr/local/maven # RUN wget https://raw.githubusercontent.com/topsale/resources/master/maven/apache-maven-3.5.3-bin.tar.gz COPY apache-maven-3.5.3-bin.tar.gz /usr/local/maven RUN tar -zxvf apache-maven-3.5.3-bin.tar.gz && \\ rm -fr apache-maven-3.5.3-bin.tar.gz # COPY settings.xml /usr/local/maven/apache-maven-3.5.3/conf/settings.xml # 配置环境变量 ENV JAVA_HOME /usr/local/java/jdk1.8.0_152 ENV MAVEN_HOME /usr/local/maven/apache-maven-3.5.3 ENV PATH $PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin WORKDIR / docker-compose.yml 在 /usr/local/docker/runner 目录下创建 docker-compose.yml version: '3.1' services: gitlab-runner: build: environment restart: always container_name: gitlab-runner privileged: true volumes: - ./config:/etc/gitlab-runner - /var/run/docker.sock:/var/run/docker.sock version: '3.1' services: gs-wsbs: image: gs-wsbs restart: always container_name: gs-wsbsdt privileged: true ports: - '8090:8080' 注册 Runner docker exec -it gitlab-runner gitlab-runner register # 输入 GitLab 地址 Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/): http://192.168.10.132/ # 输入 GitLab Token Please enter the gitlab-ci token for this runner: 1Lxq_f1NRfCfeNbE5WRh # 输入 Runner 的说明 Please enter the gitlab-ci description for this runner: 可以为空 # 设置 Tag，可以用于指定在构建规定的 tag 时触发 ci Please enter the gitlab-ci tags for this runner (comma separated): deploy # 这里选择 true ，可以用于代码上传后直接执行 Whether to run untagged builds [true/false]: true # 这里选择 false，可以直接回车，默认为 false Whether to lock Runner to current project [true/false]: false # 选择 runner 执行器，这里我们选择的是 shell Please enter the executor: virtualbox, docker+machine, parallels, shell, ssh, docker-ssh+machine, kubernetes, docker, docker-ssh: shell 使用Runner GitLab CI 地址与令牌参数 项目 –> 设置 –> CI/CD –> Runner 设置 .gitlab-ci.yml 在项目工程下编写.gitlab-ci.yml配置文件： stages: - build - run - clean build: stage: build only: - v5 script: - mvn clean package -Dmaven.test.skip=true - mv ygzw_wsbsdt_front/target/ygzw_wsbsdt_front.war docker/ROOT.war - cd docker - docker build -t gs-wsbs . run: stage: run only: - v5 script: - cd docker - docker-compose down - docker-compose up -d clean: stage: clean only: - v5 script: - docker rmi $(docker images -q -f dangling=true) 上面的配置把一次 Pipeline 分成五个阶段： 安装依赖(install_deps) 运行测试(test) 编译(build) 部署测试服务器(deploy_test) 部署生产服务器(deploy_production) 注意： 设置 Job.only 后，只有当 develop 分支和 master 分支有提交的时候才会触发相关的 Jobs。 节点说明： stages：定义构建阶段，这里只有一个阶段 deploy deploy：构建阶段 deploy 的详细配置也就是任务配置 script：需要执行的 shell 脚本 only：这里的 master 指在提交到 master 时执行 tags：与注册 runner 时的 tag 匹配 其它命令 删除注册信息 gitlab-ci-multi-runner unregister --name \"名称\" 查看注册列表 gitlab-ci-multi-runner list 附：项目配置 Dockerfile 案例 FROM tomcat:8 MAINTAINER yangb http://yangb.xyz COPY ROOT.war /usr/local/tomcat/webapps/ROOT.war FROM openjdk:8-jre MAINTAINER Lusifer ENV APP_VERSION 1.0.0-SNAPSHOT ENV DOCKERIZE_VERSION v0.6.1 # 检测其他服务的插件 RUN wget https://github.com/jwilder/dockerize/releases/download/$DOCKERIZE_VERSION/dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \\ && tar -C /usr/local/bin -xzvf dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \\ && rm dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz RUN mkdir /app COPY myshop-service-user-provider-$APP_VERSION.jar /app/app.jar ENTRYPOINT [\"dockerize\", \"-timeout\", \"5m\", \"-wait\", \"tcp://192.168.10.131:3306\", \"java\", \"-Djava.security.egd=file:/dev/./urandom\", \"-jar\", \"/app/app.jar\"] EXPOSE 8501 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 09:42:09 "},"Shell/":{"url":"Shell/","title":"Shell","keywords":"","body":"Shell 定时任务crontab 命令行分屏screen tldr命令手册 root权限用户 测试连接远程主机端口 ssh -v -p 80 username@10.0.250.3 -v 调试模式(会打印日志). -p 指定端口 username 可以随意 失败: ssh: connect to host 10.0.250.3 port 80: Connection refused 成功: debug: Connection established. omyzsh 安装 安装zsh apt install zsh 安装git apt install zsh 安装ohmyzsh sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" 配置主题 vi ~/.zshrc 修改 ZSH_THEME=\"agnoster\" # 这是最花哨的一个 java 环境变量配置 编辑profile文件 vi /etc/profile 添加环境变量 JAVA_HOME=/opt/jdk1.8.0_152 #jdk存放位置 JRE_HOME=/opt/jdk1.8.0_152/jre #jre存放位置 PATH=$PATH:$JRE_HOME/bin:$JAVA_HOME/bin export JAVA_HOME export JRE_HOME export PATH 编译profile文件 source /etc/profile 测试一下 java -version Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 18:15:44 "},"Shell/screen.html":{"url":"Shell/screen.html","title":"screen分屏命令","keywords":"","body":"screen 安装 screen，使用命令 apt-get install screen 即可完成。 screen 常用快捷键如下： Ctrl+a 再按shift + s 水平分割当前窗口 Ctrl+a | 垂直分割当前窗口 Ctrl+a c 创建一个新的运行 shell 的窗口并切换到该窗口 Ctrl+a X 关闭当前窗口 Ctrl+a x 锁定当前窗口 Ctrl+a k 杀死当前窗口 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-03-24 21:17:18 "},"Shell/crontab.html":{"url":"Shell/crontab.html","title":"crontab定时任务","keywords":"","body":"crontab 定时任务 1. 列出定时任务 crontal -l 可以使用这种方法在$HOME目录中对crontab文件做一备份: $ crontab -l > $HOME/mycron 2. 编辑crontab文件 crontab -e 3. 删除 crontab -r 使用实例 实例1：每1分钟执行一次myCommand * * * * * myCommand 实例2：每小时的第3和第15分钟执行 3,15 * * * * myCommand 实例3：在上午8点到11点的第3和第15分钟执行 3,15 8-11 * * * myCommand 实例4：每隔两天的上午8点到11点的第3和第15分钟执行 3,15 8-11 */2 * * myCommand 实例5：每周一上午8点到11点的第3和第15分钟执行 3,15 8-11 * * 1 myCommand 实例6：每晚的21:30重启smb 30 21 * * * /etc/init.d/smb restart 实例7：每月1、10、22日的4 : 45重启smb 45 4 1,10,22 * * /etc/init.d/smb restart 实例8：每周六、周日的1 : 10重启smb 10 1 * * 6,0 /etc/init.d/smb restart 实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb 0,30 18-23 * * * /etc/init.d/smb restart 实例10：每星期六的晚上11 : 00 pm重启smb 0 23 * * 6 /etc/init.d/smb restart 实例11：每一小时重启smb * */1 * * * /etc/init.d/smb restart 实例12：晚上11点到早上7点之间，每隔一小时重启smb 0 23-7 * * * /etc/init.d/smb restart Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"Shell/tldr.html":{"url":"Shell/tldr.html","title":"tldr命令手册","keywords":"","body":"tldr 命令手册 https://tldr.sh/ 安装请参考此文档。 TLDR是社区努力通过实际示例来简化的命令手册页 例：tar命令的用法 $ tldr tar tar Archiving utility. Often combined with a compression method, such as gzip or bzip. More information: . - Create an archive from files: tar cf target.tar file1 file2 file3 - Create a gzipped archive: tar czf target.tar.gz file1 file2 file3 - Extract a (compressed) archive into the current directory: tar xf source.tar[.gz|.bz2|.xz] - Extract an archive into a target directory: tar xf source.tar -C directory - Create a compressed archive, using archive suffix to determine the compression program: tar caf target.tar.xz file1 file2 file3 - List the contents of a tar file: tar tvf source.tar - Extract files matching a pattern: tar xf source.tar --wildcards \"*.html\" Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-03-24 21:17:18 "},"Shell/root.html":{"url":"Shell/root.html","title":"root权限用户","keywords":"","body":"创建root权限用户 # 创建用户 adduser tomcat # 设置密码 passwd tomcat # 赋予root权限 vim /etc/sudoers # 文件下面添加如下内容 ----------- # User privilege specification root ALL=(ALL:ALL) ALL tomcat ALL=(ALL:ALL) ALL Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-03-24 21:17:18 "},"Shell/ufw.html":{"url":"Shell/ufw.html","title":"UFW 防护墙","keywords":"","body":"UFW 防火墙管理 教程: https://linuxize.com/post/how-to-setup-a-firewall-with-ufw-on-ubuntu-18-04/ 切记: UFW必须先配置把ssh端口配进去,再开启, 不然连不上服务器就没办法了 Install UFW sudo apt install ufw Check UFW Status sudo ufw status verbose 使用apt命令安装软件包时，它将在/etc/ufw/applications.d目录中添加应用程序配置文件。 该配置文件描述了服务并包含UFW设置。 开放端口 ufw allow 4422/tcp Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-03-28 15:44:19 "},"program/Java/":{"url":"program/Java/","title":"Java","keywords":"","body":"Java Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 17:51:35 "},"program/Java/GuavaCache.html":{"url":"program/Java/GuavaCache.html","title":"GuavaCache定时缓存","keywords":"","body":"Guava Cache Maven 依赖 com.google.guava guava 18.0 延时缓存 指定缓存条目的有效期5分钟, 缓存数量最多不超过1000个, 如果超出,缓存清除那些不经常使用的条目. import com.google.common.cache.Cache; import com.google.common.cache.CacheBuilder; ... public static Cache cache = CacheBuilder .newBuilder() .expireAfterWrite(5,TimeUnit.MINUTES) .maximumSize(1000).build(); // 插入 cache.put(key, value); // 获取 cache.getIfPresent(key); // 移除 cache.invalidate(key); ... Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 17:51:23 "},"program/Java/functioncode.html":{"url":"program/Java/functioncode.html","title":"函数式编程(未完成)","keywords":"","body":"函数式编程 函数式编程语言操纵代码片段就像操作数据一样容易。 虽然 Java 不是函数式语言，但 Java 8 Lambda 表达式和方法引用 (Method References) 允许你以函数式编程。 OO（object oriented，面向对象）是抽象数据，FP（functional programming，函数式编程）是抽象行为。 代码演示 interface Strategy { String approach(String msg); } class Unrelated { static String twice(String msg) { return msg + \" \" + msg; } } public class Fuctioncodetest { public static void main(String[] args) { Strategy[] strategies = { msg -> msg + \"Tom\", // Lambda Unrelated::twice // 方法应用 }; for (Strategy strategy : strategies) { String goodmorning = strategy.approach(\"Goodmorning \"); System.out.println(goodmorning); } } } Lambda表达式 Lambda 表达式产生函数，而不是类。 在 JVM（Java Virtual Machine，Java 虚拟机）上，一切都是一个类，因此在幕后执行各种操作使 Lambda 看起来像函数 —— 但作为程序员，你可以高兴地假装它们“只是函数”。 Lambda 语法尽可能少，这正是为了使 Lambda 易于编写和使用。 递归 接受 int 型参数并生成 int 的接口： // functional/IntCall.java interface IntCall { int call(int arg); } 整数 n 的阶乘将所有小于或等于 n 的正整数相乘。 阶乘函数是一个常见的递归示例： // functional/RecursiveFactorial.java public class RecursiveFactorial { static IntCall fact; public static void main(String[] args) { fact = n -> n == 0 ? 1 : n * fact.call(n - 1); for(int i = 0; i 方法引用 Java 8 方法引用没有历史包袱。方法引用组成：类名或对象名，后面跟 :: 然后跟方法名称。 Runnable接口 class Go { static void go() { System.out.println(\"Go::go()\"); } } new Thread(Go::go).start(); 未绑定的方法引用 未绑定的方法引用是指没有关联对象的普通（非静态）方法。 使用未绑定的引用之前，我们必须先提供对象： class Go { void go() { System.out.println(\"Go::go()\"); } } Go g_o = new Go(); new Thread(g_o::go).start(); 构造函数引用 class Dog { String name; int age = -1; // For \"unknown\" Dog() { name = \"stray\"; } Dog(String nm) { name = nm; } Dog(String nm, int yrs) { name = nm; age = yrs; } } interface MakeNoArgs { Dog make(); } interface Make1Arg { Dog make(String nm); } interface Make2Args { Dog make(String nm, int age); } public class Fuctioncodetest { public static void main(String[] args) { MakeNoArgs mna = Dog::new; Make1Arg m1a = Dog::new; Make2Args m2a = Dog::new; } } Dog 有三个构造函数，函数接口内的 make() 方法反映了构造函数参数列表（ make() 方法名称可以不同）。 注意我们如何对 [1]，[2] 和 [3] 中的每一个使用 Dog :: new。 这 3 个构造函数只有一个相同名称：:: new，但在每种情况下都赋值给不同的接口。编译器可以检测并知道从哪个构造函数引用。 编译器能识别并调用你的构造函数（ 在本例中为 make()）。 函数式接口 方法引用和 Lambda 表达式必须被赋值，同时编译器需要识别类型信息以确保类型正确。 假设你要传递 System.out :: println 到你正在编写的方法 ，你怎么知道传递给方法的参数的类型？ 为了解决这个问题，Java 8 引入了 java.util.function 包。它包含一组接口，这些接口是 Lambda 表达式和方法引用的目标类型。 每个接口只包含一个抽象方法，称为函数式方法。 在编写接口时，可以使用@FunctionalInterface注解强制执行此“函数式方法”模式： 下表描述了 java.util.function 中的目标类型（包括例外情况）： 特征 函数式方法名 示例 无参数； 无返回值 Runnable (java.lang) run() Runnable 无参数； 返回类型任意 Supplier get() getAs类型() Supplier BooleanSupplier IntSupplier LongSupplier DoubleSupplier 无参数； 返回类型任意 Callable (java.util.concurrent) call() Callable 1 参数； 无返回值 Consumer accept() Consumer IntConsumer LongConsumer DoubleConsumer 2 参数 Consumer BiConsumer accept() BiConsumer 2 参数 Consumer； 1 引用； 1 基本类型 Obj类型Consumer accept() ObjIntConsumer ObjLongConsumer ObjDoubleConsumer 1 参数； 返回类型不同 Function apply() To类型 和 类型To类型 applyAs类型() Function IntFunction LongFunction DoubleFunction ToIntFunctionToLongFunction`ToDoubleFunction IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction 1 参数； 返回类型相同 UnaryOperator apply() UnaryOperator IntUnaryOperator LongUnaryOperator DoubleUnaryOperator 2 参数类型相同； 返回类型相同 BinaryOperator apply() BinaryOperator IntBinaryOperator LongBinaryOperator DoubleBinaryOperator 2 参数类型相同; 返回整型 Comparator (java.util) compare() Comparator 2 参数； 返回布尔型 Predicate test() Predicate BiPredicate IntPredicate LongPredicate DoublePredicate 参数基本类型； 返回基本类型 类型To类型Function applyAs类型() IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction 2 参数类型不同 Bi操作 (不同方法名) BiFunction BiConsumer BiPredicate ToIntBiFunction ToLongBiFunction ToDoubleBiFunction 多参数函数式接口 java.util.functional 中的接口是有限的。比如有了 BiFunction，但它不能变化。 如果需要三参数函数的接口怎么办？ 其实这些接口非常简单，很容易查看 Java 库源代码并自行创建。代码示例： // functional/TriFunction.java @FunctionalInterface public interface TriFunction { R apply(T t, U u, V v); } 高阶函数 这个名字可能听起来令人生畏，但是：高阶函数（Higher-order Function）只是一个消费或产生函数的函数。 我们先来看看如何产生一个函数： // functional/ProduceFunction.java import java.util.function.*; interface FuncSS extends Function {} // [1] public class ProduceFunction { static FuncSS produce() { return s -> s.toLowerCase(); // [2] } public static void main(String[] args) { FuncSS f = produce(); System.out.println(f.apply(\"YELLING\")); } } 闭包 考虑一个更复杂的 Lambda，它使用函数作用域之外的变量。 返回该函数会发生什么？ 也就是说，当你调用函数时，它对那些 “外部 ”变量引用了什么? 如果语言不能自动解决这个问题，那将变得非常具有挑战性。 能够解决这个问题的语言被称为支持闭包，或者叫作在词法上限定范围( 也使用术语变量捕获 )。Java 8 提供了有限但合理的闭包支持，我们将用一些简单的例子来研究它。 函数组合 函数组合（Function Composition）意为“多个函数组合成新函数”。它通常是函数式编程的基本组成部分。在前面的 TransformFunction.java 类中，有一个使用 andThen() 的函数组合示例。一些 java.util.function 接口中包含支持函数组合的方法 7。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 13:47:02 "},"program/Java/flowcode.html":{"url":"program/Java/flowcode.html","title":"流式编程(未完成)","keywords":"","body":"流式编程 流创建 你可以通过 Stream.of() 很容易地将一组元素转化成为流 Stream.of(\"it\", \"is\", \"of\", \"yang\", \"b\").forEach(System.out::println); 除此之外，每个集合都可以通过调用 stream() 方法来产生一个流。 List worlds = Arrays.asList(\"it\", \"is\", \"of\", \"yang\", \"b\"); worlds.stream() .mapToInt(item -> item.length()) .forEach(System.out::println); 随机数流 控制流的大小和界限 Random random = new Random(24); random.ints(10,2,10).boxed().forEach(System.out::println); Random 类只能生成基本类型 int， long， double 的流,boxed() 流操作将会自动地把基本类型包装成为对应的装箱类型stream int 类型的范围 IntStream 类提供了 range() 方法用于生成整型序列的流。编写循环时，这个方法会更加便利： range(10, 20).sum(); 实用的repeat函数,产生的循环更加清晰, public static void repeat(int n, Runnable action) { range(0, n).forEach(i -> action.run()); } generate() public class Fuctioncodetest implements Supplier { Random rand = new Random(47); char[] letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray(); @Override public String get() { return \"\" + letters[rand.nextInt(letters.length)]; } public static void main(String[] args) { String word = Stream.generate(new Fuctioncodetest()).limit(30).collect(Collectors.joining()); System.out.println(word); } } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-22 11:16:09 "},"program/Java/hutool.html":{"url":"program/Java/hutool.html","title":"糊涂工具包","keywords":"","body":"糊涂工具包 文档网站: https://hutool.cn/docs Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-23 09:09:47 "},"Python/Python.html":{"url":"Python/Python.html","title":"Python","keywords":"","body":"Python 依赖管理requirement 生成当前项目的requirement.txt pip freeze > requirements.txt 安装requirements.txt依赖 pip install -r requirements.txt 虚拟环境 虚拟环境相当于一个容器，在这个容器中安装的任何软件包都不会影响整个环境 Python3 虚拟环境 环境安装: sudo apt-get install python3-venv 创建虚拟环境 python3 -m venv myvenv（名称随意） 激活虚拟环境 ./myvenv venv/bin/activate 退出虚拟环境 deactivate Python2 虚拟环境 安装 pip install virtualenv 创建虚拟环境 virtualenv [虚拟环境的名字] 创建环境的时候指定Python解释器 virtualenv -p C:\\Python36\\python.exe [virutalenv name] 进入环境 Linux 虚拟环境 source /path/bin/activate 退出 deactivate Python 国内镜像源使用 让PIP源使用国内镜像，提升下载速度和安装成功率。 对于Python开发用户来讲，PIP安装软件包是家常便饭。但国外的源下载速度实在太慢，浪费时间。而且经常出现下载后安装出错问题。所以把PIP安装源替换成国内镜像，可以大幅提升下载速度，还可以提高安装成功率。 国内源： 新版ubuntu要求使用https源，要注意。 清华：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学：http://pypi.hustunique.com/ 山东理工大学：http://pypi.sdutlinux.org/ 豆瓣：http://pypi.douban.com/simple/ 临时使用： 可以在使用pip的时候加参数-i https://pypi.tuna.tsinghua.edu.cn/simple 例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider，这样就会从清华这边的镜像去安装pyspider库。 永久修改，一劳永逸： Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹) 内容如下： [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host=mirrors.aliyun.com windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini。内容同上。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-12-19 10:20:36 "},"DesignPatterns/":{"url":"DesignPatterns/","title":"设计模式","keywords":"","body":"设计模式 学习资料 https://design-patterns.readthedocs.io/ 示例代码 https://github.com/yangb92/DesignPattern4J Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-22 15:37:08 "},"React/React.html":{"url":"React/React.html","title":"React","keywords":"","body":"React 核心概念 虚拟DOM (Virtual Document Object Model) 本质: 在框架的概念中,程序员使用js对象模拟浏览器上的DOM和DOM嵌套关系, 目的: 为了实现页面中DOM元素的高效更新 Diff 算法 (Different 差异算法) Tree Diff : 新旧两颗DOM树逐层对比. Domponent Diff: 在进行tree diff中,每一层中的组件对比, 如果类型不同进行更新 Element Diff: 在组件进行对比的时候,如果组件组件类型相同,则需要进行元素对比 总结 虚拟DOM用JS模拟页面的DOM, Diff算法负责向页面更新JS模拟的DOM 项目实践 环境安装 webpack 开发环境安装 参考资料 安装React组件 cnpm i react react-dom -S -S 代表该模块生产需要使用, -D代表开发使用 Hello React index.js 只需要三步 //1. 这两个包导入格式固定 import React from 'react' //创建组件, 虚拟DOM元素,生命周期 import ReactDOM from 'react-dom' // 把创建好的组件 和 虚拟DOM 放到页面展示 //2. 创建虚拟DOM /* 参数1: 创建元素的类型 [字符串] 元素的名称 参数2: 是一个对象或null, 表示这个DOM元素的属性. 参数3: 子节点 (包括其他虚拟DOM) 参数n: 其他子节点 例: Hello World! */ const myh1 = React.createElement('h1', {id:'myh1',title:'这是h1'},\"Helo World!\") //3. 使用ReactDOM 把虚拟DOM渲染到页面上 /* 参数1: 要渲染的那个虚拟DOM元素 参数2: 指定页面上的一个容器 DOM对象 */ ReactDOM.render(myh1,document.getElementById(\"app\")) index.html 中要存在一个id为app的容器 两个元素的嵌套 const myh1 = React.createElement('h1', {id:'myh1',title:'这是h1'},\"Helo World!\") // mydiv 嵌套 myh1 const mydiv = React.createElement('div',null,'这是一个div',myh1) 启用JSX语法 通过React.createElement方式创建虚拟DOM的方式过于麻烦, JSX是可以直接再JS中写HTML的语法 可以使用babel来将JSX语法转换成React.create Element的形式来执行. babel 插件安装 安装babel插件 cnpm i babel-core babel-loader babel-plugin-transform-runtime -D cnpm i babel-preset-env babel-preset-stage-0 -D 安装能够识别转换jsx语法的包 cnpm i babel-preset-react -D 添加至webpack的module webpack.config.js module: { //所有第三方模块的配置 rules: [ //匹配规则 {test: /\\.js|jsx$/, use: 'babel-loader', exclude: /node_modules/} ] } 在根目录添加.babelrc配置文件 { \"presets\": [\"env\",\"stage-0\",\"react\"], \"plugins\": [\"transform-runtime\"] } 语法注意事项 jsx 中注释使用{/*这是注释*/} 元素的class属性用className代替 label 的for 属性用 hemlFor 代替 数组的map迭代 {names.map(item => {item})} key放在迭代元素上面 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"React/components.html":{"url":"React/components.html","title":"组件","keywords":"","body":"React 组件 创建组件: 方式一 import React from 'react' //创建组件, 虚拟DOM元素,生命周期 import ReactDOM from 'react-dom' // 把创建好的组件 和 虚拟DOM 放到页面展示 /*************定义一个组件******************/ function Hello(props){ // props为组件接收的参数, 为只读属性 return 姓名: {props.name} 年龄: {props.age} 性别: {props.gender} } /********************************************/ ReactDOM.render( {/* 使用组件,传递props数据 */} , document.getElementById(\"app\")) TIP: 组件函数的首字母必须大写 展开运算符 ... 将对象属性展开传递给组件 const user = { name:'Yangb', age:27, gender:'Nan' } 将组件抽出到单独的文件 创建Hello.jsx src/ |--components/ |--Hello.jsx |--index.js |--index.html Hello.jsx import React from 'react' //定义一个组件 props为组件接收的参数, 为只读属性 export default function Hello(props){ return 姓名: {props.name} 年龄: {props.age} 性别: {props.gender} } 在index.js中导入使用Hello组件 import Hello from './components/Hello.jsx' //后缀名jsx不能省略 ... 配置省略 jsx 后缀名 如果看到导入import Hello from '@/components/Hello' ,定义了@为绝对路径 webpack.config.json 中配置 resolve: { extensions: ['.js','.jsx','.json'], //表示这几个后缀名可省略不写 alias: { '@': path.join(__dirname,'./src') //@ 表示src这个路径 } } 创建组件: 方式二 ES6 的 class 定义 // 定义一个动物类 // 注意1: 在class 内部只能写构造器,静态方法,静态属性 // 注意2: class关键字内部,还是用原来的配方,我们把class称为语法糖 class Animal{ // 构造器 constructor(name,age){ this.name = name this.age = age } // 在class内部通过static修饰的属性是静态属性 static info = 'xxx' //实例方法 -> 存在原型中 say(){ console.log(\"我是实例方法\") } //静态方法 -> 存在构造中 static show(){ console.log(\"我是静态方法\") } } 继承: this 只能在super()后面使用 class Person extends Animal{ constructor(name, age, hair){ super(name,age) this.hair = hair } } 使用Class创建一个组件 class Hello extends React.Component{ // 在render方法中返回虚拟jsx的dom, 传入参数可通过this.props获取 render(){ return 姓名: {this.props.name} } } 两种方式的对比 class Hello extends React.Component{ constructor(){ super() this.state = { //这里面的数据可自由修改 msg:'我是一个组件' } } render(){ this.state.msg += '!' //修改值 return 姓名: {this.state.msg} } } class 创建的组件有自己的私有数据和生命周期函数 用构造函数创建出的组件,叫做\"无状态组件\" class 关键字创建出来的组件叫做\"有状态组件\" 1.有状态组件和无状态组件的本质却别就是:有无state属性 2.无状态组件的运行效率更高 例子1: 用组件展示一个简单的评论列表 文件结构 |src ​ |components ​ |CmtItem.jsx ​ |CmtList.jsx ​ |index.js ​ |index.html CmtItem.jsx import React from 'react' // 一个无状态组件,接收参数返回一个评论的条目 export default function(props){ return 姓名: {props.user} 评论: {props.content} } CmtList.jsx import React from 'react' import CmtItem from '@/components/CmtItem' // 评论列表组件 初始化数据,传递给条目 export default class CmtList extends React.Component{ constructor(){ super() this.state = { CommentList:[ {id:1,user:'张三',content:'nice'}, {id:2,user:'李四',content:'good'}, {id:3,user:'王五',content:'excting'} ] } } render(){ return this.state.CommentList.map(Item => ) } } index.js //1. 这两个包导入格式固定 import React from 'react' //创建组件, 虚拟DOM元素,生命周期 import ReactDOM from 'react-dom' // 把创建好的组件 和 虚拟DOM 放到页面展示 import CmtList from '@/components/CmtList' ReactDOM.render( , document.getElementById(\"app\")) 样式 行内样式定义如下, 样式属性类型要按照json规范书写 定义样式的三种方法 方法一和方法二: /* 第一种封装方法 */ const itemStyle = {border:'1px dashed #ccc',margin:'10px',padding:'10px',boxShadow:'0 0 10px #ccc'} const userStyle = {fontSize:\"14px\"} const contentStyle = {fontSize:\"12px\"} /** 第二种封装方法 */ const styles = { itemStyle : {border:'1px dashed #ccc',margin:'10px',padding:'10px',boxShadow:'0 0 10px #ccc'}, userStyle : {fontSize:\"14px\"}, contentStyle : {fontSize:\"12px\"} } {/*使用第一种封装*/} 评论人: {props.user} {/*使用第二种封装*/} 评论内容: {props.content} 方法三: 导入css样式文件 安装插件npm i style-loader css-loader -D webpack.config.js 中配置插件, 为了避免css全局化互相影响,启用css-loader模块化 ... module: { //所有第三方模块的配置 rules: [ //匹配规则 ... //css 样式插件, css-loader的modules参数代表css样式模块化, 只在当前引入的模块起作用, 不添加此参数,样式会在全局中起作用 {test: /\\.css$/, use: ['style-loader', 'css-loader?modules']} ] } ... 编写css文件 .title { text-align:center; color:red; font-size:28px; font-weight:300; } 导入css文件 import cssobj from '@/components/cmt.css' //启用css模块化 评论列表 //如果没启用模块化,直接用css定义的class名称即可 评论列表 设置模块化后的类名称 css-loader添加参数 'css-loader?modules&localIdentName=[path][name]-[local]-[hash:5]' 设置类名是否被模块化 :global不会被模块化 :local 会被模块化, 默认 :global(.test){ italic } 在项目中启用模块化并同时使用bootstrap 把自己的样式表定义为.scss文件 第三方样式表以.css样式结尾 我们只需要为自己的.scss文件启用模块化即可. 操作步骤 安装插件 cnpm i sass-loader node-sass -D 配置插件,处理.scss文件,不处理.css文件 {test: /\\.scss$/,use:['style-loader','css-loader?modules&localIdentName=[path][name]-[local]-[hash:5]','sass-loader']} {test: /\\.css$/, use:['style-loader','css-loader']} 安装bootstrap npm i bootstrap@3.3.7 -S 导入 import 'bootstrap/dist/css/bootstrap.css' > > 如果出现.svg .ttf .woff .eot 字体无法处理, 添加一下插件 cnpm i url-loader file-loader -D 配置插件处理字体文件 {test: /\\.ttf|woff|woff2|eot|svg$/, use: ['url-loader']} React 的生命周期 生命周期函数 (或者钩子函数) React组件的生命周期分为三部分 一个定时器的例子 import React from 'react' export default class Lifecycle extends React.Component{ constructor(){ super() this.state = {date: new Date()} } /** * 组件挂载的时候初始化一个定时器 调用tick方法 */ componentDidMount(){ this.timerID = setInterval( () => this.tick(), 1000 ); } /** * 组件卸载的时候清除定时器 */ componentWillUnmount(){ clearInterval(this.timerID); } /** * 定时器中更新状态 */ tick(){ this.setState({ date: new Date() }) } render(){ return ( 北京时间: {this.state.date.toLocaleTimeString()} ) } } 条件渲染 function Greeting(props){ if(props.loginState){ return } return } function LoginButton(props){ if(props.loginState){ return 退出 } return 登陆 } FORM表单 import React from 'react' export default class Form extends React.Component{ constructor(){ super() this.state = {value: ''} } render(){ return( 名字: ) } handleSubmit = (event)=>{ alert('提交的名字:' + this.state.value) // 阻止事件的执行 event.preventDefault() } handleChange = (event) => { this.setState({value:event.target.value}) } } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"React/webpack.html":{"url":"React/webpack.html","title":"webpack","keywords":"","body":"Webpack 简单使用 基本的webpack项目 npm init -y 快速初始化项目目录 创建目录 dist/ src/ |--index.html |--index.js 执行cnpm i webpack webpack-cli -D 安装webpack工具. 在webpack.config.js中配置webpack module.exports = { mode:'development', // development, production 设置打包的格式,压缩格式和非压缩格式 } webpack 4.x 默认约定了 打包的入口是 src/index.js 打包的输出是 dist/main.js 运行 webpack 命令 在 index.html中引入打包好的../dist/main.js即可使用 webpack-dev-server 的基本使用 安装 cnpm i webpack-dev-server -D 提供默认的webpack.config.js 配置, 运行webpack-dev-server 日志中出现 i ｢wds｣: Project is running at http://localhost:8080/ i ｢wds｣: webpack output is served from / 代表 webpack 打包的文件输入托管路径在当前的/根路径下,访问http://localhost:8080/main.js 可以访问到打包好的main.js 但是由于webpack打包好的文件存在内存,在真实目录中并不能看得到. 但我们可以在文件中引用它. /main.js 即可 支持其他的命令 --open 自动打开浏览器 --port 3000 端口 --hot --progress --compress 传输压缩 --host 127.0.0.1 例如 \"scripts\": { \"dev\": \"webpack-dev-server --open --port 3000 --host 127.0.0.1 --progress --hot\" }, 现在有个问题,我们的首页在src中,需要能够从根目录访问.. html-webpack-plug的使用 在内存中自动生成index.html页面的插件 安装 cnpm i html-webpack-plugin -D 插件 插件的使用 在 webpack.config.js中加入插件 const path = require('path') const HtmlWebPackPlugin = require('html-webpack-plugin') //导入插件 const htmlPlugin = new HtmlWebPackPlugin({ template: path.join(__dirname,'./src/index.html'), //源文件 filename: 'index.html' //生成在内存中的名称 }) // 向外暴露打包的配置信息, webpack支持所有node api和语法 module.exports = { mode:'development', // development production plugins: [ htmlPlugin ] } 并且在 index.html中会自动引入main.js, 所以我们不需要再手动引入main.js了. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"React/event.html":{"url":"React/event.html","title":"事件","keywords":"","body":"React 事件 在React有一套自己的事件绑定机制, 事件名是驼峰规则. 示例: 箭头函数的好处是this 环境指的是当前class的环境.可以使用this获取当前class中的属性. 修改state的数据 在React中,想要为state中的数据重新赋值,不要使用 this.state.* = 值 应该调用 React提供的 this.setState({msg:123}) 在setState中,只会更新对应的值,而不会覆盖其他的值. this.setState的方法执行是异步的,在调用完setState之后要立即获取设置完的值,需要使用this.setState({},callable) 示例代码 import React from 'react' import 'bootstrap/dist/css/bootstrap.css' export default class BindEvent extends React.Component{ constructor(){ super() this.state = { msg: \"你好\" } } render(){ return {/* 在React有一套自己的事件绑定机制, 事件名是驼峰规则. */} this.show('哈哈')}> 按钮 {this.state.msg} } // 箭头函数的好处是this 环境指的是当前class的环境.可以使用this获取当前class中的属性. show = (args) => { // 在React中,想要为state中的数据重新赋值,不要使用 this.state.*** = 值 // 应该调用 React提供的 this.setState({msg:123}) // 在setState中,只会更新对应的值,而不会覆盖其他的值. // this.setState的方法执行是异步的,在调用完setState之后要立即获取设置完的值,需要使用this.setState({},callable) this.setState({ msg:\"你说: \"+args },() => { console.log(this.state.msg) }) } } 同步文本框的值 React 不支持双向绑定, 只支持将state传输到页面, 无法从页面自动绑定数据到state中, 不支持数据的逆向传输. 将属性绑定到文本框 value={this.state.xxx} 将文本框的值同步到属性: 第一步,手动监听文本框的onChange事件 第二部: 获取文本框的值 第三步: 调用setState方法同步最新的值 render(){ return {/* 在React有一套自己的事件绑定机制, 事件名是驼峰规则. */} this.show('哈哈')}> 按钮 {this.state.msg} {/* 第一步,手动监听文本框的onChange事件 */} this.changeTxt(e)} ref='txt' /> } changeTxt = (e) => { // 第二部: 获取文本框的值 //方式一: 通过参数 e 获取 console.log(e.target.value) //方式二: 通过refs属性获取 console.log(this.refs.txt.value) //第三步: 调用setState方法同步最新的值 this.setState({ msg: this.refs.txt.value }) } 绑定this并传参的几种方式 使用箭头函数 bing函数this.xx.bind(this) 传递当前this. 和call/apply的区别bind 只会修改指向不会调用, bind中的参数传递, 第一个参数是this this.method.bind(this,args1,...) 可以在构造函数中执行该方法或在事件中绑定 第三种: 使用箭头函数this的调用即可 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"Android/adb.html":{"url":"Android/adb.html","title":"操作系统","keywords":"","body":"ADB adb速查 https://www.wanandroid.com/blog/show/2310 最全ADB github: https://github.com/mzlogin/awesome-adb adb 常用命令 查看当前连接设备： adb devices 如果发现多个设备： adb -s 设备号 其他指令 查看日志： adb logcat 安装apk文件： adb install xxx.apk 此安装方式，如果已经存在，无法安装； 推荐使用覆盖安装： adb install -r xxx.apk 卸载App: adb uninstall com.zhy.app 1 如果想要保留数据，则： adb uninstall -k com.zhy.app 往手机SDCard传递文件： adb push 文件名 手机端SDCard路径 从手机端下载文件： adb pull /sdcard/xxx.txt 查看手机端安装的所有app包名: adb shell pm list packages 启动Activity: adb shell am start 包名/完整Activity路径 启动服务： adb shell am startservice \"com.zhy.aaa/com.zhy.aaa.MyService\" 屏幕截图： adb shell screencap /sdcard/screen.png 录制视频： adb shell screenrecord /sdcard/demo.mp4 清除APP数据： adb shell pm clear com.example.packagename 查看所有App的名称：该命令可以查看手机上的APP名称。可以在后面加上 -f ，这样还能显示该APP的路径。 即： adb shell pm list packages -f 使用adb shell input命令向屏幕输入一些信息， adb shell input text \"insert%stext%shere\" 注意：%s表示空格。 模拟屏幕点击事件 adb shell input tap 500 1450 1 表示在屏幕上（500，1450）的坐标点上进行一次点击。 模拟手势滑动事件，例如： adb shell input swipe 100 500 100 1450 100 用上面的命令还可以模拟”长按（long press）操作，也就是2个坐标点相同，耗时超过500ms. adb shell input swipe 100 500 100 500 500 模拟点按实体按钮的命令，例如： adb shell input keyevent 25 该命令表示调低音量。数字25是在AOSP源码中的KeyEvent类里定义的一个事件常量。该类定义了将近300个事件常量。 上面这个命令会启动浏览器打开谷歌网址页面。 adb shell am start -a \"android.intent.action.VIEW\" -d \"https://www.google.com\" am 也能发送广播和启动服务。比如启动一个广播，一般要添加一个-a： adb shell am broadcast -a \"our.specified.action\" 使用下面的命令可以直接让手机重启： adb shell am broadcast -a android.intent.action.BOOT_COMPILETED 启动一个服务也是类似，例如: adb shell am startservice \"com.example.crime/com.example.crime.MyService\" adb shell ps命令查看进程信息。可以在该命令后加包名，来查看某个应用程序的进程信息。 adb shell top 命令来查看系统CPU使用情况 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:10 "},"MCU/MicroControllerUnit.html":{"url":"MCU/MicroControllerUnit.html","title":"单片机","keywords":"","body":"单片机 MCU(Micro Controller Unit) 型号解释 STC 89C52 35I-PDIP40 1749HRX921.. STC：公司名称 89：89系列 C：CMOS 52：stc还有51，54，58，516后面的值*4k表示内存空间的大小。52的内存空间为8k。 35：表示单品机的工作频率 I：表示工业级（-40 - 125摄氏度）， C表示商业级（温度范围0-80）军品级别 PDIP：封装型号，包括单片机的形状和大小。 1749：代表生产时间，17年4月9日 80C51引脚封装 总线型 非总线型 总线分为三种：数据总线DB(Data Bus),地址总线AB(Adress Bus),控制总线CB(Control Bus) 单片机组成 CPU RAM ROM I/O T/C ：两个定时/计数器，既可以工作在定时模式，也可工作在计数模式。 C51 知识 很多硬件的开发都使用C语言编程，例如各种单片机，DSP，ARM等。 C51 数据类型 C-51基础数据类型 (有符号和无符号字节数 signed,unsigned) int(16) short(16) long(32) float(32) double(64) char(8) C51 数据类型扩充定义 sfr: 特殊功能寄存器申明 sfr16: sfr的16位数据申明 sbit: 特殊功能位声明 bit：位变量声明 C51 包含的头文件 常用头文件有 reg51.h reg52.h,定义特殊功能寄存器和位寄存器 math.h 定义常用数学运算 C51运算符 与C语言基本相同。 算数运算符 + - * / 布尔运算符： > >= \\ 逻辑运算符： && || ! 位运算: >> \\ & | 按位与或 ～ ^ 按位异或 取反 C51 基本语句 与C基本相同 if while for switch/case do-while 中断服务程序 I/O口定义 单片机要点掌握 最小系统能够运行起来的必要条件，1 电源 2 晶振 3 复位电路 对单片机任意I/O口的随意操作 输出控制的电频高低 输入检测电频高低 定时器 中断：外部中断，定时器中断，串口中断 串口通信：单片机之间，单片机与计算机间 单片机工作的基本时序 振荡周期: 也称时钟周期,指为单片机提供时钟脉冲信号振荡源的周期, TX实验板为11.0592MHZ 状态周期: 每个状态周期为时钟周期的两倍,是振荡周期经二分频后得到的. 机器周期: 一个机器周期包含6个状态周期,也就是12个时钟周期,在一个机器周期内,CPU可以完成一个独立的操作, 指令周期: 它指CPU完成一条操作所需的全部时间,每条指令执行时间都是有一个或几个机器周期组成 MCS-51系统中,有单周期指令,双周期指令和四周期指令. 80C51引脚封装 80C51/89C51 最大4k程序. 管脚: RST/Vpd: 复位/备用电源的输入端, P3.0/RXD, P3.1/TXD,P3.2/INTO ... P3.7/RD: 串口,程序下载命令,中断,定时器,计数器,外部数据存储器. XTAL2 XTAL1: 外部晶振输入端. ALE 中断 中断的概念: CPU 在处理某一事件A, 发生了另一事件B请求CPU迅速去处理(中断发生) CPU暂时中断当前的工作,转去处理事件B(中断响应和中断服务) 待CPU将事件B处理完毕后,再回到原来事件A被中断的地方继续处理事件A(中断返回),这一过程称为中断 中断的嵌套 在中断服务中再次发生中断 中断的优先级 中断源的响应优先级及中端服务入口程序表 中断源 中断标志 中断服务程序入口 优先级顺序 外部中断 0 (INT0) IE0 0003H 高 定时/计数器 0 (T0) TF0 000BH ⬇ 外部中断 1 (INT1) IE1 0013H ⬇ 定时/计数器 1(T1) TF1 001BH ⬇ 串行口 RI或T1 0023H 低 中断响应条件 中断源有中断请求 此中断源的中断允许位为1 CPU开中断 即 EA=1 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:10 "},"DB/db.html":{"url":"DB/db.html","title":"数据库","keywords":"","body":"数据库 PostgresSql 数据库 管理员登陆 su postgres psql \\l 查看数据库 Oracle 数据库表数据闪回 找回删除的数据或者表 闪回查询 查询过去某个时间段的数据库状态 select * from dept as of timestamp to_timestamp('2016-09-10 11:00:00','yyyy-mm-dd hh24:mi:ss'); 闪回表 启用表闪回首先要在表上支持行移动 闪回表操作 alter table dept enable row movement; flashback table dept to timestamp to_timestamp('2016-09-10 11:00:00','yyyy-mm-dd hh24:mi:ss'); 闪回表可能会失败，有可能有以下几种情况： 违反了数据库约束，比如用户不小心删除了子表中的数据，现在想利用闪回表技术进行回退，恰好在这中间，父表中与该数据对应的那条记录也被删除了，在这种情况下，由于违反了外键约束，导致闪回表操作失败了； 撤销数据失效，比如用于支撑闪回操作的撤销数据被覆盖了，这种情况闪回表操作自然会失败； 闪回不能跨越DDL，即在闪回点和当前点之间，表结构有过变更，这种情况闪回操作也会失败。 如果表和数据库被删除了，也可以闪回，请参考 https://www.cnblogs.com/chengxiao/p/5860823.html Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 18:15:44 "},"security/security.html":{"url":"security/security.html","title":"网络安全","keywords":"","body":"Security 网络安全 科学上网服务建设 使用V2Ray https://github.com/233boy/v2ray/wiki/V2Ray%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC v2ray url 可生成 vmess URL 链接 国外VPS服务器 https://bwh88.net/ 境外服务器不易受到监管 家用智能设备攻击思路 破解家用路由器或者控制一台肉鸡, 在内网扫描支持UPnP协议的只能设备, 使用UPnP利用工具miranda进行扫描和利用 UPnP 协议 UPnP为即插即用的缩写（Universal Plug and Play）是一套网络协议。适用于家庭网络，用于设备间的发现和连接。希望实现任何设备只要一接入网络就能被网络中的所有其它设备发现，做到完全的即插即用。 miranda Miranda是Kali提供的一款基于Python语言的UPNP客户端工具。它可以用来发现、查询和操作UPNP设备，尤其是网关设置。 pcap：被动发现设备通过嗅探设备接入网络时发送的NOTIFY消息获取设备信息。 msearch:通过主动发送M-serach消息来发现设备。（一般使用msearch比较快） 发现设备后可用host命令来查看详细信息。 host list：查看发现的设备列表 host get ：获取信息（查询summary之前需执行） host info ：显示查询到的信息 host summary 0 ：显示xml文件的摘要信息 （n为设备在列表中的编号） 获取设备列表 host info 0 deviceList 获取设备支持的命令/服务信息（命令很长使用Tab键补齐很方便 ） host info 0 deviceList WANConnectionDevice services WANIPConnection actions TCP 三次握手 SYN: synchronous 同步 ACK: acknowledgement 确认 client --SYN--> server server --ACK+SYN--> client client --ACK--> server Nmap 常用指令 主机发现: -sn Tcp ping扫描 -Pn 跳过主机发现 -PS/PA/PU/PY[portlist]: SYN/ACK/UDP/SCTP -n: 不做反向DNS查询 --dns-servers 8.8.8.8 : 指定dns服务器 -p-: 扫描所有端口 快速扫描主机的详细信息 nmap -sT -sV -Pn -v xxx.xxx.xxx.xxx 扫描所有的端口开放情况 nmap -sS -p 1-65535 -v 192.168.1.254 扫描网段主机(ping扫描) nmap -sn 192.168.16.100-150 深度扫描网络主机信息 nmap -A -T4 192.168.10.1 半开扫描(TCP SYN扫描) - 隐秘且速度快，比较常用 nmap -sS host Robots 扫描工具 parsero 扫描robots目录的地址 parsero -u url -o 只显示连接成功的 -sb 使用bing搜索引擎查找robots文件. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 18:14:01 "},"security/demo.html":{"url":"security/demo.html","title":"漏洞利用","keywords":"","body":"漏洞利用 CVE-2020-1938 文件包含漏洞 漏洞说明 该漏洞是由于Tomcat AJP协议存在缺陷而导致，攻击者利用该漏洞可通过构造特定参数，读取服务器webapp下的任意文件。若目标服务器同时存在文件上传功能，攻击者可进一步实现远程代码执行。目前，厂商已发布新版本完成漏洞修复。 受影响版本 Apache Tomcat 6 Apache Tomcat 7 Apache Tomcat 8 Apache Tomcat 9 不受影响版本 Apache Tomcat = 7.0.100 Apache Tomcat = 8.5.51 Apache Tomcat = 9.0.31 PoC github: https://github.com/yangb92/AJPy Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-03-24 21:17:18 "},"security/kali.html":{"url":"security/kali.html","title":"Kali","keywords":"","body":"Kali Linux 中文乱码问题 确定locales已经安装，用”apt-get install locales”命令；之后可用”locale -a”查看当前系统支持的字符集。 在命令行输入”dpkg-reconfigure locales”。进入图形化界面之后，（空格是选择，Tab是切换，*是选中），选中en_US.UTF-8和zh_CN.UTF-8，确定后，将en_US.UTF-8选为默认。 安装中文字体，”apt-get install xfonts-intl-chinese “和” apt-get install ttf-wqy-microhei”，这时发现网页不乱码，系统也不乱码。 重启 。 DDOS 洪水攻击 hping3 -c 1000 -d 120 -S -w 64 -p80 --flood --rand-source baidu.com -c: 发送包的数量 -d: 发送的每个数据包的大小,单位字节 -S: 只发送SYN数据包 -w: tcp窗口大小 -p: 目标端口 -flood: 尽可能快的发送数据包,不考虑显示入站回复 --rand-source: 随机性源头IP, 这里伪造的IP只是在局域网伪造,外网出口会还原 主动收集 netdiscover netdiscover 是一个主动/被动侦察工具. 可以扫描IP地址,检查在线主机或搜索为它们发送ARP请求 主动模式: 主动探测发现网络主机,但这种方式往往会引起网络管理员注意. netdiscover -i eth0 -r 192.168.1.0/24 被动模式: netdiscover -p scapy 启动 scapy ARP().display() # 查看ARP函数的用法 ###[ ARP ]### hwsrc: 源MAC地址 psrc: 源IP地址 hwdst: 目标MAC地址 pdst: 目的IP地址 sr1 函数发送请求sr1(ARP(pdst='192.168.1.1')) # 发送ARP请求 使用IP()和ICMP()生成ping包. 思路: 修改IP包头的dst(目的地址) 拼接ICMP的数据包类型 使用sr1进行发送数据包并接收数据包 sr1(IP(dst='192.168.1.1')/ICMP(),timeout=1) 构造TCP协议数据包 构造UDP协议数据包 僵尸扫描 nmap 扫描网络中的哪些机器可以被当成僵尸主机 被动收集 域名IP查询 dig (选项) 域名 @DNS服务地址: 指定域名进行解析 any: 显示所有类型域名记录.默认只显示A记录 dig yangb.xyz dig @114.114.114.114 yangb.xyz dig @114.114.114.114 yangb.xyz any -x ip:反查域名 子域名信息收集 使用搜索引擎: site:顶级域名 例如: site:qq.com Maltego 收集子域名(更加专业强大) 学习视频: http://www.shodan.io/ 超强搜索引擎, 可以搜索未经授权的站点, 包括网络摄像头. Kali 网络配置 实用Kali虚拟机需要开启桥接模式。 修改/etc/network/interfaces文件 dhcp 自动获取ip地址 auto eth0 iface eth0 dhcp 手动IP设置 auto eth0 iface eth0 inet static address 192.168.10.188 netmask 255.255.255.0 gateway 192.168.10.1 重启网络服务 /etc/init.d/networking restart 网络中图片嗅探 driftnet [options] [filter code] 主要参数： -b 捕获到新的图片时发出嘟嘟声 -i interface 选择监听接口 -f file 读取一个指定pcap数据包中的图片 -p 不让所监听的接口使用混杂模式 -a 后台模式：将捕获的图片保存到目录中（不会显示在屏幕上） -m number 指定保存图片数的数目 -d directory 指定保存图片的路径 -x prefix 指定保存图片的前缀名 使用举例： 1.实时监听： driftnet -i wlan0 2.读取一个指定pcap数据包中的图片： driftnet -f /home/linger/backup/ap.pcapng -a -d /root/drifnet/ Installing the Metasploit Framework on Linux curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb > msfinstall && chmod 755 msfinstall && ./msfinstall 如果安装失败 apt-get update 如果update出现key错误,先添加key apt-key adv --recv-keys --keyserver keyserver.ubuntu.com CDFB5FA52007B954 msfvenom 使用 https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom 查看能生成木马文件的格式类型,编码类型等等,都可以用-l参数来显示 msfvenom -l formats Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-07 10:26:14 "},"security/google.html":{"url":"security/google.html","title":"谷歌黑客语法","keywords":"","body":"谷歌黑客语法 site：可以限制你搜索范围的域名. inurl：用于搜索网页上包含的URL，这个语法对寻找网页上的搜索，帮助之类的很有用. intext: 只搜索网页部分中包含的文字(也就是忽略了标题、URL等的文字) intitle: 查包含关键词的页面，一般用于社工别人的webshell密码 filetype：搜索文件的后缀或者扩展名 intitle：限制你搜索的网页标题. link: 可以得到一个所有包含了某个指定URL的页面列表. 查找后台地址：site:域名 inurl:login|admin|manage|member|admin_login|login_admin|system|login|user|main|cms 查找文本内容：site:域名 intext:管理|后台|登陆|用户名|密码|验证码|系统|帐号|admin|login|sys|managetem|password|username 查找可注入点：site:域名 inurl:aspx|jsp|php|asp 查找上传漏洞：site:域名 inurl:file|load|editor|Files 找eweb编辑器：site:域名 inurl:ewebeditor|editor|uploadfile|eweb|edit 存在的数据库：site:域名 filetype:mdb|asp|# 查看脚本类型：site:域名 filetype:asp/aspx/php/jsp 迂回策略入侵：inurl:cms/data/templates/images/index/ Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-03-25 12:48:11 "},"Tool/":{"url":"Tool/","title":"工具插件","keywords":"","body":"工具插件 Chrome 插件 Infinity 标签页管理 安装方式 1. 谷歌市场搜索下载 2. 谷歌访问助手 免费访问: 谷歌搜索，Gmail邮箱，Chrome商店... 更好用的谷歌访问助手工具 pp访问助手 www.ppgoogle.net 沙拉查词 多个来源的网页翻译工具 Darkreader 网页暗色模式: https://darkreader.org/ Jetbrains系列产品 Jetbrains系列产品2019.2.3最新激活方法[持续更新] https://zhile.io/2018/08/25/jetbrains-license-server-crack.html?tdsourcetag=s_pctim_aiomsg 漂亮的 Markdown 编辑器 Typora https://www.typora.io/ Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-11-23 13:26:33 "},"Tool/PowerShell.html":{"url":"Tool/PowerShell.html","title":"PowerShell 美化主题","keywords":"","body":"PowerShell 美化 PowerShell 美化效果: 配置windows允许执行没有签名（远程）的Powershell脚本 在设置中面板中搜索PowerShell 找到开发人员设置,打勾这一项 下载Windows包管理工具 Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) 输入 choco -v验证是否安装成功 GIT choco install git 字体库 只需要安装字体库中 DejaVuSansMono 的字体就可以了. 字体下载好右键安装即可. powershell的git集成方案 posh-git Install-Module posh-git 基于posh-git的美化主题oh-my-posh Install-Module oh-my-posh 硬货在这里 刚刚前面做的全都是事前准备而已，这里才是真正影响Powershell主题的主要关键。直接复制到Powershell跑一下吧。 Install-Module -Name PSReadLine -Force -SkipPublisherCheck if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } @\" #requires -Version 2 -Modules posh-git function Write-Theme { param( [bool] `$lastCommandFailed, [string] `$with ) `$lastColor = `$sl.Colors.PromptBackgroundColor `$prompt = Write-Prompt -Object `$sl.PromptSymbols.StartSymbol -ForegroundColor `$sl.Colors.PromptForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor #check the last command state and indicate if failed If (`$lastCommandFailed) { `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.FailedCommandSymbol) \" -ForegroundColor `$sl.Colors.CommandFailedIconForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor } #check for elevated prompt If (Test-Administrator) { `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.ElevatedSymbol) \" -ForegroundColor `$sl.Colors.AdminIconForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor } `$user = [System.Environment]::UserName `$computer = [System.Environment]::MachineName `$path = Get-FullPath -dir `$pwd if (Test-NotDefaultUser(`$user)) { `$prompt += Write-Prompt -Object \"`$user@`$computer \" -ForegroundColor `$sl.Colors.SessionInfoForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor } if (Test-VirtualEnv) { `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.SegmentForwardSymbol) \" -ForegroundColor `$sl.Colors.SessionInfoBackgroundColor -BackgroundColor `$sl.Colors.VirtualEnvBackgroundColor `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.VirtualEnvSymbol) `$(Get-VirtualEnvName) \" -ForegroundColor `$sl.Colors.VirtualEnvForegroundColor -BackgroundColor `$sl.Colors.VirtualEnvBackgroundColor `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.SegmentForwardSymbol) \" -ForegroundColor `$sl.Colors.VirtualEnvBackgroundColor -BackgroundColor `$sl.Colors.PromptBackgroundColor } else { `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.SegmentForwardSymbol) \" -ForegroundColor `$sl.Colors.SessionInfoBackgroundColor -BackgroundColor `$sl.Colors.PromptBackgroundColor } # Writes the drive portion `$prompt += Write-Prompt -Object \"`$path \" -ForegroundColor `$sl.Colors.PromptForegroundColor -BackgroundColor `$sl.Colors.PromptBackgroundColor `$status = Get-VCSStatus if (`$status) { `$themeInfo = Get-VcsInfo -status (`$status) `$lastColor = `$themeInfo.BackgroundColor `$prompt += Write-Prompt -Object `$(`$sl.PromptSymbols.SegmentForwardSymbol) -ForegroundColor `$sl.Colors.PromptBackgroundColor -BackgroundColor `$lastColor `$prompt += Write-Prompt -Object \" `$(`$themeInfo.VcInfo) \" -BackgroundColor `$lastColor -ForegroundColor `$sl.Colors.GitForegroundColor } # Writes the postfix to the prompt `$prompt += Write-Prompt -Object `$sl.PromptSymbols.SegmentForwardSymbol -ForegroundColor `$lastColor `$timeStamp = Get-Date -UFormat %r `$timestamp = \"[`$timeStamp]\" `$prompt += Set-CursorForRightBlockWrite -textLength (`$timestamp.Length + 1) `$prompt += Write-Prompt `$timeStamp -ForegroundColor `$sl.Colors.PromptForegroundColor `$prompt += Set-Newline if (`$with) { `$prompt += Write-Prompt -Object \"`$(`$with.ToUpper()) \" -BackgroundColor `$sl.Colors.WithBackgroundColor -ForegroundColor `$sl.Colors.WithForegroundColor } `$prompt += Write-Prompt -Object (`$sl.PromptSymbols.PromptIndicator) -ForegroundColor `$sl.Colors.PromptBackgroundColor `$prompt += ' ' `$prompt } `$sl = `$global:ThemeSettings #local settings `$sl.PromptSymbols.StartSymbol = '' `$sl.PromptSymbols.PromptIndicator = [char]::ConvertFromUtf32(0x276F) `$sl.PromptSymbols.SegmentForwardSymbol = [char]::ConvertFromUtf32(0xE0B0) `$sl.Colors.PromptForegroundColor = [ConsoleColor]::White `$sl.Colors.PromptSymbolColor = [ConsoleColor]::White `$sl.Colors.PromptHighlightColor = [ConsoleColor]::DarkBlue `$sl.Colors.GitForegroundColor = [ConsoleColor]::Black `$sl.Colors.WithForegroundColor = [ConsoleColor]::DarkRed `$sl.Colors.WithBackgroundColor = [ConsoleColor]::Magenta `$sl.Colors.VirtualEnvBackgroundColor = [System.ConsoleColor]::Red `$sl.Colors.VirtualEnvForegroundColor = [System.ConsoleColor]::White \"@>$env:userprofile\"\\Documents\\WindowsPowerShell\\Modules\\oh-my-posh\\2.0.230\\Themes\\Paradox.psm1\" @\" chcp 65001 Set-PSReadlineOption -EditMode Emacs function which(`$name) { Get-Command `$name | Select-Object Definition } function rmrf(`$item) { Remove-Item `$item -Recurse -Force } function mkfile(`$file) { \"\" | Out-File `$file -Encoding ASCII } Import-Module posh-git Import-Module oh-my-posh Set-Theme Paradox \"@ > $PROFILE chcp 65001 Set-PSReadlineOption -EditMode Emacs Import-Module posh-git Import-Module oh-my-posh Set-Theme Paradox 设置powershell字体,选择安装的powerline字体. 其他主题参考 主题页面 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-31 10:48:01 "},"Tool/hexo.html":{"url":"Tool/hexo.html","title":"Hexo 博客框架","keywords":"","body":"Hexo 博客搭建 博客的基础搭建请参考: 官方文档 推荐主题 主题: https://github.com/jerryc127/hexo-theme-butterfly 主题预览: https://jerryc.me/ 主题安装文档:https://jerryc.me/posts/21cfbf15 博客扩展设置: https://jerryc.me/posts/31391d01 为博客添加宠物 详细资料: https://github.com/EYHN/hexo-helper-live2d 宠物包: https://github.com/xiazeyu/live2d-widget-models npm install --save hexo-helper-live2d 在站點配置文件或者主題配置文件添加以下内容 live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-wanko # 宠物的模型 display: position: right width: 150 height: 300 mobile: show: true 安裝需要的寵物文件: npm install {packagename} Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-11-07 15:10:18 "},"Tool/chromeExp.html":{"url":"Tool/chromeExp.html","title":"Chrome 插件开发","keywords":"","body":"Chrome 编辑页面 document.body.contentEditable = \"true\" 插件开发 mainfest.json { \"name\": \"WSBS\", \"description\": \"网上办事大厅扩展功能\", \"version\": \"1.0\", \"manifest_version\": 2, \"browser_action\": { \"default_popup\": \"main.html\", \"default_icon\": \"main.png\" }, \"permissions\": [ \"tabs\" ] } main.html body { width: 250px; text-align: center; } #build { width: 100%; background-color: brown; color: lightyellow; border: none; height: 30px; } 甘肃人力资源网上办事大厅 说明: 生成当前页面的授权地址, 实现信任传递. 生成授权地址 main.js document.getElementById('build').onclick = function(e){ chrome.tabs.getSelected(null,function(tab) { var pre_url = 'http://www.gszwfw.gov.cn/api/sso/loginTrust?backUrl=http://www.rst.gansu.gov.cn:8080/auth/sso/trust/common/' url = tab.url.match(/(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/).pop() document.getElementById('result').textContent = pre_url + window.btoa(url); }); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 14:13:59 "},"git/git.html":{"url":"git/git.html","title":"git","keywords":"","body":"Git 覆盖分支 把本地的devlop分支强制(-f)推送到远程mastergit push origin devlop:master -f 用devlop覆盖当前分支git reset –hard develop git push origin master –f Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 18:15:44 "},"git/gituse.html":{"url":"git/gituse.html","title":"在项目开发中使用git","keywords":"","body":"项目开发中使用Git 项目开发中如何使用git? 开发人员只需要在dev分支进行代码更新和提交就能满足日常工作需要. 拉取项目 复制项目的地址 2.创建一个文件夹,右键菜单中打开Git Bash命令行,如果没有安装Git,先安装Git工具. git clone git@192.168.10.45:zjapl/gov-gsrs.git 3.进入项目目录 gov-gsrs 进行开发 切换到开发分支 git checkout dev 更新代码 git pull origin dev 提交代码 git push origin dev Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-29 15:47:11 "},"Tool/gitbook.html":{"url":"Tool/gitbook.html","title":"Gitbook 电子书","keywords":"","body":"将GitBook文档托管到Github 将打包的文档发布至公共 gitpage 在 github|gitee 创建一个仓库 创建gitbook文档, 使用 gitbook build打包 安装推送插件cnpm install -g gh-pages 将文档发布到github|gitee gh-pages -d _book 开启仓库的gitpage, 选择gh-pages分支. 本文档使用插件 { \"title\":\"学习笔记\", \"author\":\"杨斌\", \"language\" : \"zh-hans\", \"plugins\": [ \"-search\", \"back-to-top-button\", \"chapter-fold\", \"sharing\", \"donate\", \"search-pro\", \"insert-logo\", \"theme-default\", \"theme-comscore\", \"code\", \"splitter\", \"tbfed-pagefooter\", \"github\", \"hide-element\", \"katex\" ], \"pluginsConfig\": { \"donate\": { \"wechat\": \"https://gitee.com/yangb92/book/raw/gh-pages/git/wxpay.png\", \"alipay\": \"https://gitee.com/yangb92/book/raw/gh-pages/git/alipay.png\", \"title\": \"\", \"button\": \"赏\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\" }, \"insert-logo\": { \"url\": \"https://gitee.com/yangb92/book/raw/gh-pages/favorite.png\", \"style\": \"background: none; max-height: 80px; min-height: 10px\" }, \"theme-default\": { \"showLevel\": true }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy yangb \", \"modify_label\": \"该文章修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"github\":{ \"url\":\"https://github.com/yangb92\" }, \"hide-element\":{ \"elements\": [\".gitbook-link\"] } } } 数学符号使用 行内公式:\\$\\$ x_0 \\$\\$ 公式块: \\$\\$ x_0 = y_2 \\$\\$ 在线符号编辑器 http://latex.codecogs.com/eqneditor/editor.php 公示参考文档: https://blog.csdn.net/weixin_43159148/article/details/88621318 https://blog.csdn.net/weixin_43159148/article/details/88623751 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 18:15:44 "},"Nginx/Nginx.html":{"url":"Nginx/Nginx.html","title":"Nginx","keywords":"","body":"Nginx Nginx 的主从热备 场景: Nginx代理主服务器对外提供服务, 主服务器失去连接后 Nginx 代理转向从服务器为外界提供服务. 当主服务器恢复时, 自动切换至主服务器继续为外界提供服务. Nginx 配置: http { upstream backend { server localhost:9090; server localhost:9999 backup; } server { listen 80; location / { proxy_pass http://backend; } } } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-12-10 16:31:23 "},"Netty/Netty.html":{"url":"Netty/Netty.html","title":"Netty","keywords":"","body":"Netty 问题 我们经常使用应用程序和库来相互通信，例如，浏览器和Web服务器之间的通信。但是通用协议有时不能很好的扩展，比如我们不用Http服务器传输大文件，电子邮件和近时时消息(比如股票信息和游戏数据) 解决方案 Netty 项目致力于提供一个异步事件驱动的网络应用框架，快速开发可维护的高性能，高可扩展性协议的服务器和客户端工具。 换句话说，Netty 是一个NIO 客户端服务器框架，可以快速轻松的开发服务器和客户端之间通信协议的网络应用程序。 “快速而简单” 并不意味着最终的应用程序会受到可维护性或性能问题的影响。Netty 经过精心设计，从实现FTP，SMTP，HTTP 等协议中学到了很多经验 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-09 10:15:11 "},"Docker/Docker.html":{"url":"Docker/Docker.html","title":"Docker","keywords":"","body":"Docker Docker 文档: https://www.funtl.com/zh/docs-docker/ 基本概念 Docker 包括三个基本概念 镜像（Image） Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 分层存储:镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。 容器（Container） 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。 按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。 仓库（Repository） 公有仓库 私有仓库 标题 说明 镜像(Images) Docker 镜像是用于创建 Docker 容器的模板。 容器(Container) 容器是独立运行的一个或一组应用。 客户端(Client) Docker 客户端通过命令行或者其他工具使用 Docker API (https://docs.docker.com/reference/api/docker_remote_api) 与 Docker 的守护进程通信。 主机(Host) 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。 仓库(Registry) Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。 Docker Machine Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。 Docker安装 Ubuntu 安装 脚本自动安装: curl -fsSL get.docker.com -o get-docker.sh sh get-docker.sh --mirror Aliyun 检测Docker是否安装成功 docker version 配置阿里云Docker镜像加速器 下载镜像 docker pull 镜像名称 启动镜像 docker run -p 80:8080 tomcat Docker 仓库 公共仓库: https://hub.docker.com Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-13 13:47:32 "},"maven/maven.html":{"url":"maven/maven.html","title":"maven","keywords":"","body":"Maven maven 本地仓库导入jar包 mvn install:install-file -Dfile=C:\\Users\\DELL\\Documents\\mybash\\uids-sm-1.0.jar -DgroupId=com.zdww -DartifactId=uids-sm -Dversion=1.0 -Dpackaging=jar 注意: 此脚本在powershell中执行会出现错误, 请使用git_bash或其他支持shell的终端执行 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-01-02 15:43:21 "},"股票/股票趋势技术分析.html":{"url":"股票/股票趋势技术分析.html","title":"股票","keywords":"","body":"股票趋势技术分析 股票分析的两种流派: 基本统计分析: 依靠各种统计数据, 检查审计报表,损益报告,资产负债表等指标数据对股票进行评估, 如果其当前售价低于其评定价值, 则认为可以购买 技术分析: 指对市场本身行为研究而非对市场交易商品的研究. 通过股票的走势推断出发展趋势. 道氏理论 技术分析派 查看详情 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-24 10:41:38 "},"股票/道氏理论.html":{"url":"股票/道氏理论.html","title":"道氏理论","keywords":"","body":"道氏理论 要点: 三种趋势 长期趋势: 中期趋势 短期趋势 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2019-10-24 09:53:00 "},"高等数学/":{"url":"高等数学/","title":"高等数学","keywords":"","body":"数学 高等数学 函数与极限 离散数学 集合 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 18:15:44 "},"高等数学/函数与极限.html":{"url":"高等数学/函数与极限.html","title":"函数与极限","keywords":"","body":"函数与极限 1.1 集合 1.1.1 集合 概念 具有某种属性的事物的全体称为集合. a(元素) A(集合) a是A的元素 a∈A; a不是A的元素 a∉A 表示 表示法 列举 说明属性 A={x|使x属于A的属性} 运算 并(和): A∪B(A+B); 交(积): A∩B(AB); 差: A∖B; 1.1.2 实数集 实数集 R: 有理数集(Q)+无理数集; 有理数集的特性 有序性 对加减乘除运算的封闭性(构成数域) 稠密性 通过长度: 有理数 -> 数轴上的点; 数轴上的点不都是有理数. >> √2 实数集多一个特性: 完备性(或连续性) 实数 .. 数轴上的点 (一一对应) 在极限运算下是封闭的 1.1.3 区间 有界区间 设: a 开区间: (a,b) = {x|a 闭区间: [a,b] = {x|a 半开闭区间: (a,b] = {x|a 无界区间 (-∞,b)={x|x (-∞,-∞)={x|x ∈ R};[a,+∞]={x|a 一般区间表示 I 邻域 若 a ∈ R, 𝞭 > 0, 则:U(a,𝞭) = (a-𝞭,a+𝞭); a的𝞭邻域. 去心邻域 \\overset{ \\circ}{ U } (a,\\delta) = (a-\\delta,a)U(a,a+\\delta) a的去心𝞭 领域(只考虑点a邻近的点，不考虑点a) 1.1.4 一些符号 用逻辑符号表达某些数学语言较简洁 符号 说明 ∉ 不属于 ∈ 属于 ∀ 任意的 ∃ 存在 => 蕴含,必要条件 源于,充分条件 等价 ≜ 定义为 max E E中最大的 min E E中最小的 1.1.5 不等式 A-G 不等式 Bernoulli不等式 1.1.6 实数集的界 上界 设E为非空实数集 ∃M ∈ R; ∀x ∈ E; x ≤ M ; 称M是E的一个上界. ∃N ∈ R; ∀x ∈ E; x ≥ N; 称N是E的一个下界. 上确界 最小上界 设E为非空实数集 (1) ∀x ∈ E; x ≤ y; (2) ∀z>0, ∃x ∈ E; x>y-z; 公理: 如果集合有上界必有上确界 1.2 函数 1.2.1 概念与表示 什么是函数? 简言之: 函数是数集间的对应关系. 设D是一个数集 ∀x∈D,x→y,y∈R\\forall x \\in D, x \\rightarrow y, y \\in R∀x∈D,x→y,y∈R; 记为 y=f(x),x∈Dy = f(x), x \\in Dy=f(x),x∈D; 或f:D→R f:D \\rightarrow Rf:D→R; f: 函数, x:自变量 D: 定义域 函数在D上 x0x_0x​0​​ 的对应的f(x0)f(x_0)f(x​0​​) 称为函数在x0x_0x​0​​的值.有时记为∫∣x0\\int \\mid{x_0}∫∣x​0​​ 自变量的字母可以改变 y=f(Δ),Δ∈X\r y = f(\\Delta ), \\Delta \\in X\r y=f(Δ),Δ∈X 函数的表示 (1)定义域 (2)对应关系 可以用解析式,也可以用图表等方式 解析式往往用分段表示 例: 飞机托运行李(千克)与价格(元)之间的关系 p{ 0; 0≤m≤20 7(m-20); 20m≤200\r p\\begin{cases}\r & \\text{ 0; } 0 \\leq m \\leq 20 \\\\ \r & \\text{ 7(m-20); } 20 p{​​​​​ 0; 0≤m≤20​ 7(m-20); 20m≤200​​ 例: Dirichlet 函数 D(x)={ 1 x⇔Irrationalnumber 0 x⇔Rationalnumber\r D(x)=\\begin{cases}\r & \\text{ 1 } x \\Leftrightarrow Irrational number \\\\ \r & \\text{ 0 } x \\Leftrightarrow Rational number\r \\end{cases}\r D(x)={​​​​​ 1 x⇔Irrationalnumber​ 0 x⇔Rationalnumber​​ 函数的奇偶性 如何确定函数的奇偶性 - 根据子函数的奇偶性判断 有界性 有界联系区间 如何叙述无解 函数的单调性 区别单调与严格单调 单调联系区间 周期性 周期不唯一,通常指最小正周期 若f(x)的周期为T,那么f(ax+b)的周期为T/a 周期函数一定有最小正周期吗? (不一定,Dirichlet函数) 函数的运算 加减乘除 f+g, f-g,fg,f/g 复合函数 例: y=2sin3x⇒y=2x,u=sinv,v=3x\r y = 2^{sin3x} \\Rightarrow y=2^x, u=sin v,v=3x\r y=2​sin3x​​⇒y=2​x​​,u=sinv,v=3x Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 18:15:44 "}}