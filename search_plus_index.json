{"./":{"url":"./","title":"介绍","keywords":"","body":"Wiki By leo.yang 位置: 中国 - 杭州 邮箱: 博客: http://yangb.xyz github: https://github.com/yangb92 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-04-13 15:46:04 "},"program/":{"url":"program/","title":"软件编程","keywords":"","body":"程序设计 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/vue/":{"url":"program/vue/","title":"Vue","keywords":"","body":"VUE 学习代码: https://github.com/yangb92/admin-vue-elementui vue-cli 安装 npm install -g @vue/cli 适用脚手架创建项目 vue create demo MVVM介绍 .vue 文件包括 template, script, style. 在scrpt暴露该组件,供外部使用. - 模板 - 脚本 // 1. 引入组件 import HelloWorld from './components/HelloWorld.vue' export default { name: 'App', components: { // 2. 注册组件 HelloWorld } } - 样式 #app { ... } 数据绑定 v-model, v-bind 等等. Vue.extend() 中 data 必须是函数. 例如: export default { name: 'HelloWorld', data(){ return { msg:'Hello Vue' } } } 事件绑定 绑定一个点击事件,例如: 点击 export default { name: 'HelloWorld', methods:{ study(){ alert(\"学有所成!\") } } } 其他事件: 特定事件 .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 计算属性 c 属性是计算得出的,计算逻辑写在此函数中 var vm = new Vue({ data: { a: 1 }, computed: { // 仅读取 aDouble: function () { return this.a * 2 }, // 读取和设置 aPlus: { get: function () { return this.a + 1 }, set: function (v) { this.a = v - 1 } } } }) vm.aPlus // => 2 vm.aPlus = 3 vm.a // => 2 vm.aDouble // => 4 Watch 观察属性 观察属性的变化 var vm = new Vue({ data: { a: 1, b: 2, c: 3, d: 4, e: { f: { g: 5 } } }, watch: { a: function (val, oldVal) { console.log('new: %s, old: %s', val, oldVal) }, // 方法名 b: 'someMethod', // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深 c: { handler: function (val, oldVal) { /* ... */ }, deep: true }, // 该回调将会在侦听开始之后被立即调用 d: { handler: 'someMethod', immediate: true }, // 你可以传入回调数组，它们会被逐一调用 e: [ 'handle1', function handle2 (val, oldVal) { /* ... */ }, { handler: function handle3 (val, oldVal) { /* ... */ }, /* ... */ } ], // watch vm.e.f's value: {g: 5} 'e.f': function (val, oldVal) { /* ... */ } } }) vm.a = 2 // => new: 2, old: 1 动态样式 元素控制 v-if, v-show, v-else, v-else-if A B C Not A/B/C 数据遍历 v-for 预期：Array | Object | number | string | Iterable (2.6 新增) v-for 的默认行为会尝试原地修改元素而不是移动它们。要强制其重新排序元素，你需要用特殊 attribute key 来提供一个排序提示： 通过计算属性进行过滤和排序 过滤: arr = student.filter(p => p.name.indexOf(search) !== -1) 排序: sort((p1,p2) => p1.age - p2.age) 其他属性 v-text: 插入文本 v-html: 插入普通html v-pre: 不渲染元素内容 v-once: 只渲染元素和组件一次。 This will never change: 特殊属性 key: 有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。 常见v-for结合使用 ref: 用来或取元素的 例子: hello ... this.$refs.p.text // => hello 自定义全局指令和局部指令 注册全局指令 // 注册 (指令函数) Vue.directive('my-directive', function (el, binding) { // 这里将会被 `bind` 和 `update` 调用 }) 使用 Hello Iter 局部指令 Hello Iter export default { name: \"Iter\", directives: { focus:function(el, binding){ el.style=\"color:red\" } } } 过滤器 局部过滤器 export default { name: \"Iter\", filters: { telFormat: function(value) { return \"☎️ \" + value; } } } 全局过滤器 Vue.filter(\"moneyFormat\",function(value){ return \"¥\" + value + \".00\" }) 使用 动画和过渡 略 生命周期 export default { name: \"Iter\", // 元素创建 created () { this.time_a = new Date().getTime() }, // 元素挂载 mounted () { console.log('用时:' + (new Date().getTime()-this.time_a) + \"mm\"); }, } 组件通信 props 用于外部向内部传输数据 内部组件接收并显示数据 姓名: 年龄: export default { name: 'Message', // props: ['name', 'age'], props:{ name: {type:String, default: \"yangb\"}, age: {type: Number, required: true}, home: Object } } 外部组件调用 注意传递对象或数字的时候,需要使用动态绑定, v-bind 自定义事件传递参数 只适用子组件向父组件传递数据 子组件发送数据: this.$emit('welcom',{age:14}) 父组件响应事件 //... methods: { changeT(args) { console.log(args) } }, //... } 或者使用下面的方法接收事件 this.$refs.msg.$on(\"welcom\",this.changeT); PubSub 发布订阅 插件安装 npm install --save pubsub-js 引入 import PubSub from 'pubsub-js' 发布 PubSub.publish('delTodo',\"参数\") 订阅 PubSub.subscribe('delTodo',(msg,token) => {console.log(msg,token)}) 插槽 组件中预留插槽: slot 使用插槽 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-04-28 15:47:07 "},"program/vue/ui-frame.html":{"url":"program/vue/ui-frame.html","title":"UI框架","keywords":"","body":"UI 框架 vant UI 组件库 vant :移动端UI组件库,来自有赞前端团队. https://github.com/youzan/vant 安装 npm i vant -S # 或者 yarn add vant 配置按需加载 安装 npm i babel-plugin-import -D 配置babel.config.js module.exports = { plugins: [ ['import', { libraryName: 'vant', libraryDirectory: 'es', style: true }, 'vant'] ] } 引入组件 最好单独维护 import Vue from 'vue' import { Button } from 'vant'; Vue.use(Button); 使用组件 主要按钮 信息按钮 默认按钮 警告按钮 危险按钮 Element UI PC 端组件库, 来自饿了么团队 https://element.eleme.cn/ 安装 按需加载babel.config.js配置 module.exports = { presets: [ '@vue/app', [\"@babel/preset-env\", { \"modules\": false }] ], \"plugins\": [ [ \"component\", { \"libraryName\": \"element-ui\", \"styleLibraryName\": \"theme-chalk\" } ] ] } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/vue/vue-router.html":{"url":"program/vue/vue-router.html","title":"路由","keywords":"","body":"Vue Router 路由 构建单页面应用 https://router.vuejs.org/ 安装 npm i vue-router --save 基本配置 新建router.js import Vue from 'vue' import Router from 'vue-router' Vue.use(Router) export default new Router({ routes:[ ] }) 在main.js中引入 import Vue from 'vue' import App from './App.vue' import router from './router' new Vue({ router, render: h => h(App), }).$mount('#app') 导航路由和出口路由 路由的配置: export default new Router({ routes:[ {path:'/', redirect:'/home'}, {path:'/home', name:'home', component: Home}, {path:'/about', name:'about', component: About}, ] }) 路由出口: 路由的页面在中展示 导航路由: 路由的导航地址 在App.vue中 首页 关于我们 history 和 hash 模式 hash模式: 地址栏是/#/about, history模式: 传统的url模式,有利于seo优化. 通过mode参数使用: export default new Router({ mode:'history', routes:[...] }) 动态路由 两个参数: name和age通过路由传递 配置: routes:[ {path:'/mine/:name/:age', name:'mine', component:Mine} ] 获取: 在组件中获取参数 created () { console.log(this.$route.params); }, 在props中绑定路由参数 {path:'/mine/:name/:age', name:'mine', component:Mine,props: true} export default { name:'Mine', props:['name','age'] } 嵌套路由 配置: {path:'/home', name:'home', component: Home,children:[ {path:'/home',redirect:'/home/shop'}, {path:'news',name:'news',component: News}, {path:'shop',name:'shop',component: Shop} ]} 路由入口防止在 Home 组件中,并设置路由导航 家 商城 | 新闻 路由守卫 全局路由的前置守卫: 可用于判断权限. let router = new Router({ mode:'history', routes:[ {path:'/', redirect:'/home'}, {path:'/home', name:'home', component: Home,children:[ {path:'/home',redirect:'/home/shop'}, {path:'news',name:'news',component: News}, {path:'shop',name:'shop',component: Shop} ]}, {path:'/about', name:'about', component: About}, {path:'/mine', name:'mine', component:Mine} ] }) // 前置守卫 router.beforeEach((to,from,next)=>{ // 此处可以验证页面的访问权限 console.log(\"进入路由\"); next() //放行 }) // 后置守卫 router.afterEach((to,from)=>{ console.log(\"路由结束\"); }) 常用的路由钩子 导航被触发。 在失活的组件里调用 beforeRouteLeave 守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。 路由懒加载 安装: npm install --save-dev @babel/plugin-syntax-dynamic-import 配置babel.config.js: { \"plugins\": [\"@babel/plugin-syntax-dynamic-import\"] } 有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用 命名 chunk，一个特殊的注释语法来提供 chunk name (需要 Webpack > 2.4)。 //import Foo from './Foo.vue' const Foo = () => import(/* webpackChunkName: \"group-foo\" */ './Foo.vue') const Bar = () => import(/* webpackChunkName: \"group-foo\" */ './Bar.vue') const Baz = () => import(/* webpackChunkName: \"group-foo\" */ './Baz.vue') Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/vue/vuex.html":{"url":"program/vue/vuex.html","title":"vuex","keywords":"","body":"vuex 安装 vue add vuex 配置 创建 store.js 并在main.js引入 store.js import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) export default new Vuex.Store({ state: { count: 0 //初始化数据 }, mutations: { }, actions: { }, modules: { } }) main.js import Vue from 'vue' import App from './App.vue' import store from './store' Vue.config.productionTip = false new Vue({ store, render: h => h(App) }).$mount('#app') 获取 state 的值 在模块中获取state的值 this.$store.state.count Mutations 操作 state 的中的值, 必须同步执行 在 store.js 中定义 mutations 方法,操作state mutations: { INCREMENT(state){ state.count++ }, DECREMENT(state){ state.count-- } } 调用 mutations 中的函数. methods: { // ...mapMutations(['INCREMENT','DECREMENT']), increment() { // this.INCREMENT() this.$store.commit('INCREMENT') }, decrement() { // this.DECREMENT() this.$store.commit('DECREMENT') } }, Action Action 提交给 Mutations, 而不直接变更状态. Action 可以包含任意异步操作. 定义 Action actions: { increment({commit}){ commit('INCREMENT') }, decrement({commit}){ commit('DECREMENT') } }, 调用 Action this.$store.dispatch('increment') Getters state 的计算属性 store.js 中定义 getters getters: { des_count: state => { return state.count + \".00\"; } } 使用 this.$store.getters.des_count Modules 对状态分模块 使用 map 方便取值 import {mapMutations,mapGetters,mapState,mapActions} from 'vuex' export default { name: 'Counter', computed: { //取出 vuex 中的值 ...mapGetters(['des_count']), ...mapState(['count']) }, methods: { //取出 Action 方法 ...mapActions(['increment','decrement']) }, } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/vue/network.html":{"url":"program/vue/network.html","title":"网络请求","keywords":"","body":"网络请求 反向代理 在 vue.config.js 文件中配置, 如果没有该文件, 在根目录创建该文件,将由vue框架自动加载. module.exports = { devServer:{ proxy:{ '/ajax':{ target:'https://m.maoyan.com', changeOrigin:true } } } } axios 安装 npm i axios -S 配置 在src/目录创建 http.js import axios from 'axios' const http = axios.create({ baseURL: 'http://localhost/web/api' }) export default http; 配置在vue的原始类型中方便使用 main.js import Vue from 'vue' import http from '@/http' Vue.prototype.$http = http 使用 this.$http.post('/getSingleJoke?sid=28654780',{name:this.name,username:this.username,password:this.password}).then(resp => { console.log(resp) }) Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/vue/node.html":{"url":"program/vue/node.html","title":"小笔记","keywords":"","body":"小笔记 vm 单位 px 单位是固定像素大小, vm 单位可以随着屏幕尺寸大小而变化 全局进度条插件 NProgress 安装: npm i NProgress -S 使用: // 进度条模块 import NProgress from 'nprogress' import 'nprogress/nprogress.css' axios.interceptors.request.use(config => { NProgress.start() return config }) axios.interceptors.response.use(response =>{ NProgress.done() return response }) Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/mq/":{"url":"program/mq/","title":"消息队列","keywords":"","body":"消息队列 AMQP 和 JMS MQ 的消息通信模型; 实现 MQ 的两种主流方式 AMQP: 是一种协议. 定义网络交换的数据格式 JMS: (Java message service) java消息服务. 消息队列产品 消息队列 实现方式 说明 ActiveMQ JMS ZeroMQ AMQP C语言 RabbitMQ AMQP erlang语言 RocketMQ JMS Alibaba产品 Kafka 类似MQ的产品 分布式消息系统,高吞吐量 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/mq/activemq.html":{"url":"program/mq/activemq.html","title":"Active MQ","keywords":"","body":"ActiveMQ 消息中间件 SpringBoot 项目 pom.xml org.springframework.boot spring-boot-starter-activemq application.yml spring: activemq: broker-url: tcp://47.98.63.50:61616 user: admin password: admin in-memory: true pool: enabled: false packages: # 如果消息体是一个对象，则需要设置对象所在的包为信任。 trusted: com.yangb.rabbitmq.dto # trust-all: true # 信任所有对象 消息队列发送 @Bean public ActiveMQQueue queue(){ return new ActiveMQQueue(\"data.exchange.queue\"); } @Component public class Sender { @Autowired ActiveMQQueue queue; @Autowired JmsTemplate jmsTemplate; public void sendMessage(String message){ jmsTemplate.convertAndSend(queue,new MessageDto(1, message, false)); } } 消息队列接收 @Component public class Recever { @JmsListener(destination = \"data.queue\") public void receveQueue(MessageDto message){ System.out.println(\"收到消息:\"+message.getMessage()); } } 广播发送 @Bean public ActiveMQTopic topic(){ return new ActiveMQTopic(\"data.exchange.topic\"); } @Autowired ActiveMQTopic topic; public void sendTopic(String message){ jmsTemplate.convertAndSend(topic,new MessageDto(1, message, false)); } 广播接收 @JmsListener(destination = \"data.exchange.topic\") public void receveTopic(MessageDto message) { System.out.println(\"收到广播:\" + message.getMessage()); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/mq/rabbitmq.html":{"url":"program/mq/rabbitmq.html","title":"Rabbit MQ","keywords":"","body":"RabbitMQ 使用 erlang 语言开发, 基于 AMQP( Advanced Message Queue ) 协议. 安装及配置 安装 docker-compose 安装 rabbitmq version: '3' services: #服务名称 rabbitmq: #容器名称 container_name: rabbitmq #镜像名称 image: rabbitmq:3.7-rc #总是重启后启动 restart: always #端口映射 ports: - 5672:5672 - 15672:15672 #挂载 volumes: - ./data:/var/lib/rabbitmq #环境变量 environment: - RABBITMQ_DEFAULT_VHOST=my_vhost - RABBITMQ_DEFAULT_USER=admin - RABBITMQ_DEFAULT_PASS=admin 开启管理界面 docker exec 3606dab88713 rabbitmq-plugins enable rabbitmq_management 输入 http://192.168.10.45:15672 登录mq管理界面. 配置 (1) Virtual Host 每个虚拟主机之间是相互独立的. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springboot/":{"url":"program/springboot/","title":"SpringBoot","keywords":"","body":"Spring Boot 项目结构 定位程序主类 默认推荐将启动类放在根目录中，高于其他的类。 @SpringBootApplication 注解放在主类上面，它还隐式的定义基础的所要扫描的包。 如果你不想用@SpringBootApplication， 可以使用@EnableAutoConfiguration 和 @ComponentScan 注解来定义这些。 典型的布局结构 com +- example +- myapplication +- Application.java | +- customer | +- Customer.java | +- CustomerController.java | +- CustomerService.java | +- CustomerRepository.java | +- order +- Order.java +- OrderController.java +- OrderService.java +- OrderRepository.java 配置类 Spring Boot 支持 java类配置和xml同事配置， 在配置类使用一个@Configuration， 通常定义 main 方法的主类很适合使用@Configuration。 导入其他配置类 你不需要将所有的@Configuration放入一个类中， @Import 注解能够用来加入配置类，或者，您可以使用@ComponentScan自动获取所有包括 @Configuration 类的Spring组件 导入XML配置 如果你必须要使用xml配置，我们建议您仍然从@Configuration类开始，你可以使用一个@ImportResource 注解加载xml配置文件。 自动配置 禁用特定的自动配置类 您可以使用@EnableAutoConfiguration的exclude属性禁用它们，如下面的示例所示: import org.springframework.boot.autoconfigure.*; import org.springframework.boot.autoconfigure.jdbc.*; import org.springframework.context.annotation.*; @Configuration @EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class}) public class MyConfiguration { } Spring Bean 和 依赖注入 您可以自由地使用任何标准Spring框架技术来定义bean及其注入的依赖项。为了简单起见，我们经常发现使用@ComponentScan(查找bean)和使用@Autowired(执行构造函数注入)工作得很好。 如果按照上面的建议构造代码(将应用程序类定位在根包中)，可以添加@ComponentScan，而不需要任何参数。所有应用程序组件(@Component、@Service、@Repository、@Controller等)都自动注册为Spring bean。 注意使用构造注入的bean 使用final 防止被更改。 使用@SpringBootApplication注解 使用一个@SpringBootApplication注释来启用这三个特性，即: @EnableAutoConfiguration: enable Spring Boot’s auto-configuration mechanism • @ComponentScan: enable @Component scan on the package where the application is located (see the best practices) • @Configuration: allow to register extra beans in the context or import additional configuration classes @SpringBootApplication还提供别名来定制@EnableAutoConfiguration和@ComponentScan的属性 这些特性都不是强制性的，您可以选择用它支持的任何特性替换这个注释。例如，你可能不想在你的应用程序中使用组件扫描: package com.example.myapplication; import org.springframework.boot.SpringApplication; import org.springframework.context.annotation.ComponentScan import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Import; @Configuration @EnableAutoConfiguration @Import({ MyConfig.class, MyAnotherConfig.class }) public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 开发工具 添加开发依赖 org.springframework.boot spring-boot-devtools true 开发依赖将在打包时关闭，并且用java -jar 运行时认为是生产环境，会自动关闭。 若要手动关闭，请设置Dspring.devtools.restart.enabled=false 属性 自动重启 类路径上的文件发生更改，将会自动重启，静态资源或模板发生更改，不会重启， 触发自动重启的唯一方法是更新类路径， Eclipse 自动更新， ide需要build 排除一些资源变动，不重启 spring.devtools.restart.exclude=static/,public/ 远程开发 需要添加插件 org.springframework.boot spring-boot-maven-plugin false 然后需要设置spring.devtools.remote.secret属性，如下面的示例所示: spring.devtools.remote.secret=mysecret 存在安全风险，不建议用在生产服务器上。 远程开发工具由两部分提供支持，接受连接的服务器端端点和在IDE中运行的客户机应用程序。当设置spring.devtools.remote.secret属性时，服务器组件将自动启用。客户端组件必须手动启动。 jar包部署至远程服务器 在服务器上运行jar包，address=5005 是调试端口 java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 demo-0.0.1-SNAPSHOT.jar IDE 上开启远程调试 只需要输入主机地址和调试端口即可热更新和调试，实现本地开发，远程运行，降低对开发电脑的资源占用。 运行远程客户端程序 远程客户端程序被设计运行在IDE，您需要运行org.springframework.boot.devtools.RemoteSpringApplication，其类路径与您连接到的远程项目相同，应用程序唯一需要的参数是它连接到的远程URL。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springboot/SpringBootDruid.html":{"url":"program/springboot/SpringBootDruid.html","title":"SpringBoot整合Druid","keywords":"","body":"SpringBoot 整合 Druid 引入依赖 在pom文件引入druid依赖 com.alibaba druid-spring-boot-starter 1.1.22 引入数据库连接依赖 mysql mysql-connector-java runtime 配置application.yml spring: datasource: druid: url: jdbc:mysql://ip:port/dbname?useUnicode=true&characterEncoding=utf-8&useSSL=false username: root password: 123456 initial-size: 1 min-idle: 1 max-active: 20 test-on-borrow: true # MySQL 8.x: com.mysql.cj.jdbc.Driver driver-class-name: com.mysql.jdbc.Driver Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springboot/SpringBootTkMybaits.html":{"url":"program/springboot/SpringBootTkMybaits.html","title":"SpringBoot整合tk.mybatis","keywords":"","body":"SpringBoot 整合 tk.mybatis 引入依赖 在pom.xml引入依赖,该依赖会自动引入MyBaits依赖 tk.mybatis mapper-spring-boot-starter 2.0.2 配置 application.yml 配置 MyBatis mybatis: type-aliases-package: 实体类的存放路径，如：com.funtl.hello.spring.boot.entity mapper-locations: classpath:mapper/*.xml 创建一个通用的父级接口 主要作用是让 DAO 层的接口继承该接口，以达到使用 tk.mybatis 的目的 package com.funtl.utils; import tk.mybatis.mapper.common.Mapper; import tk.mybatis.mapper.common.MySqlMapper; /** * 自己的 Mapper * 特别注意，该接口不能被扫描到，否则会出错 * Title: MyMapper * Description: * * @author Lusifer * @version 1.0.0 * @date 2018/5/29 0:57 */ public interface MyMapper extends Mapper, MySqlMapper { } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springboot/SpringBootPageHelper.html":{"url":"program/springboot/SpringBootPageHelper.html","title":"SpringBoot整合PageHelper","keywords":"","body":"SpringBoot 整合 PageHelper 引入依赖 在pom.xml文件中引入pagehelper-spring-boot-starter com.github.pagehelper pagehelper-spring-boot-starter 1.2.5 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springboot/generator.html":{"url":"program/springboot/generator.html","title":"Mybatis Maven插件生成代码","keywords":"","body":"Mybatis Maven插件生成代码 配置插件 在pom.xml文件中增加mybatis-generator-maven-plugin插件 org.mybatis.generator mybatis-generator-maven-plugin 1.3.5 ${basedir}/src/main/resources/generator/generatorConfig.xml true true mysql mysql-connector-java ${mysql.version} tk.mybatis mapper 3.4.4 configurationFile：自动生成所需的配置文件路径 自动生成的配置 在 src/main/resources/generator/ 目录下创建 generatorConfig.xml 配置文件： 配置数据源 在 src/main/resources/generator 目录下创建 jdbc.properties 数据源配置： # MySQL 8.x: com.mysql.cj.jdbc.Driver jdbc.driverClass=com.mysql.jdbc.Driver jdbc.connectionURL=jdbc:mysql://ip:port/dbname?useUnicode=true&characterEncoding=utf-8&useSSL=false jdbc.username=root jdbc.password=123456 插件自动生成命令 mvn mybatis-generator:generate Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springboot/multi-datasource.html":{"url":"program/springboot/multi-datasource.html","title":"多数据源","keywords":"","body":"SpringBoot 多数据源项目 pom.xml com.oracle ojdbc6 11.2.0.3 tk.mybatis mapper-spring-boot-starter 2.0.2 com.github.pagehelper pagehelper-spring-boot-starter 1.2.5 application.yml # 网上办事数据库配置 wsbs: datasource: driver-class-name: oracle.jdbc.driver.OracleDriver url: jdbc:oracle:thin:@47.98.63.50:1521:ORCL username: APL_YGZW_POWER password: APL_YGZW_POWER mapper-location: classpath:mapper/wsbs/*.xml # 政务网数据库配置 zww: datasource: driver-class-name: oracle.jdbc.driver.OracleDriver url: jdbc:oracle:thin:@47.98.63.50:1521:ORCL username: APL_YGZW_ONLINE password: APL_YGZW_ONLINE mapper-location: classpath:mapper/zww/*.xml 启动类 // 关闭默认的数据源配置 @SpringBootApplication(exclude = DataSourceAutoConfiguration.class) public class YgzwDataExchangeApplication { public static void main(String[] args) { SpringApplication.run(YgzwDataExchangeApplication.class, args); } } 配置类 /** * 多数据源配置 * Created by YangBin on 2020/7/21 * Copyright (c) 2020 杨斌 All rights reserved. */ @Configuration public class DataSourceConfig { @Data @Configuration @ConfigurationProperties(\"wsbs.datasource\") @MapperScan(basePackages = \"com.zjapl.ygzw.data.exchange.wsbs.dao\", sqlSessionFactoryRef = \"wsbsSqlSessionFactory\") class WsbsDataSource{ private String driverClassName; private String url; private String username; private String password; private String mapperLocation; @Bean(name = \"wsbsSqlSessionFactory\") public SqlSessionFactory wsbsSqlSessionFactory() throws Exception { return buildSqlSessionFactory(this.driverClassName,this.url,this.username,this.password,this.mapperLocation); } } @Data @Configuration @ConfigurationProperties(\"zww.datasource\") @MapperScan(basePackages = \"com.zjapl.ygzw.data.exchange.zww.dao\", sqlSessionFactoryRef = \"zwwSqlSessionFactory\") public class ZwwDataSourceConfig { private String driverClassName; private String url; private String username; private String password; private String mapperLocation; @Bean(name = \"zwwSqlSessionFactory\") public SqlSessionFactory zwwSqlSessionFactory() throws Exception { return buildSqlSessionFactory(this.driverClassName,this.url,this.username,this.password,this.mapperLocation); } } public SqlSessionFactory buildSqlSessionFactory(String driverClassName,String url,String username,String password,String mapperLocation) throws Exception { DataSourceProperties dataSourceProperties = new DataSourceProperties(); dataSourceProperties.setDriverClassName(driverClassName); dataSourceProperties.setUsername(username); dataSourceProperties.setPassword(password); dataSourceProperties.setUrl(url); HikariDataSource datasource = dataSourceProperties.initializeDataSourceBuilder().type(HikariDataSource.class).build(); SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean(); factoryBean.setDataSource(datasource); factoryBean.setMapperLocations(new PathMatchingResourcePatternResolver() .getResources(mapperLocation)); return factoryBean.getObject(); } } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springboot/SpringDataJPA.html":{"url":"program/springboot/SpringDataJPA.html","title":"SpringDataJPA","keywords":"","body":"Spring Data JPA Repostory @Repository public interface AppUserRepostory extends JpaRepository { } Example 使用 public AppUser loadUserByUsername(String username) throws UsernameNotFoundException { AppUser user = new AppUser(); user.setUsername(username); ExampleMatcher matcher = ExampleMatcher.matching().withIgnoreNullValues() .withMatcher(\"username\", match -> match.contains() ); Example example =Example.of(user,matcher); Optional optional = userRepostory.findOne(example); AppUser appUser = userRepostory.queryByUsername(username); if (!optional.isPresent()) { throw new UsernameNotFoundException(\"用户名不存在\"); } return optional.get(); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springboot/SpringDataJdbc.html":{"url":"program/springboot/SpringDataJdbc.html","title":"SpringDataJDBC","keywords":"","body":"Spring Data Jdbc 添加依赖 org.springframework.boot spring-boot-starter-data-jdbc 创建实体 @Data @Table(\"t_user\") public class UserDto { @Id private String id; private String username; private String password; private String fullname; private String mobile; } 创建Dao @Repository public interface UserDao extends CrudRepository { @Query(\"SELECT * FROM `t_user` where username=:username\") UserDto findByUsername(@Param(\"username\") String username); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springboot/LinuxService.html":{"url":"program/springboot/LinuxService.html","title":"部署为linux服务","keywords":"","body":"Linux 服务化部署 官方文档: https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/html/deployment.html#deployment-install 配置Maven插件 org.springframework.boot spring-boot-maven-plugin true 安装为init.d服务 假设你的SpringBoot程序部署在/var/myapp路径，要将SpringBoot程序作为init.d服务，需要创建一个软链接，如下: $ sudo ln -s /var/myapp/myapp.jar /etc/init.d/myapp 安装后，就可以按系统服务的方式启动和停止。例如，在基于debian的系统上，可以使用以下命令启动它: $ service myapp start 日志在/var/log/myapp.log中可以查看. FQ spring boot 在Linux下服务启动报错Unable to find Java 将java 连接到/sbin 文件夹下 ln -s /usr/local/jdk/bin/java /sbin/java Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springboot/to-war.html":{"url":"program/springboot/to-war.html","title":"打成war包","keywords":"","body":"Spring Boot 打 war 包 修改pom.xml war ... org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-tomcat org.springframework.boot spring-boot-starter-tomcat provided ... org.springframework.boot spring-boot-maven-plugin 修改启动类 @SpringBootApplication public class BlogApplication extends SpringBootServletInitializer { public static void main(String[] args) { SpringApplication.run(BlogApplication.class, args); } @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { return builder.sources(BlogApplication.class); } } 使用maven打包 mvn clean package -Dmaven.test.skip=true Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springcloud/":{"url":"program/springcloud/","title":"SpringCloud","keywords":"","body":"Spring Cloud 千峰播客: https://www.funtl.com/ Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springcloud/stopdesc.html":{"url":"program/springcloud/stopdesc.html","title":"SpringCloud组件状态","keywords":"","body":"Spring Cloud 组件停更说明 参考资料: 见官网 说明: [ ] 停更 [x] 建议使用 服务注册 [ ] Eureka [x] Zookeeper [x] Consul [x] Nacos (Alibaba) 服务调用 [x] Ribbon [x] LoadBalancer 服务调用2 [ ] Feign [x] OpenFeign 服务降级 [ ] Hystrix [x] resilience4j (国外推荐) [x] Sentine (国内推荐- 来自Alibaba组件) 服务网关 [ ] Zuul [ ] Zuul2 (未开发完成) [x] Gateway 服务配置 [ ] Config [x] Apollo (上海携程) [x] Nacos (Alibaba) 服务总线 [ ] Bus [x] Nacos Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springcloud/version..html":{"url":"program/springcloud/version..html","title":"版本选型","keywords":"","body":"版本选型 Spring Boot 版本选型: 19年以后不再使用 1.5 版本, 一定要使用2.x版本 Spring Cloud 版本选型: H版 采用伦敦地铁站来命名. Hoxton.SR3 Spring Boot 和 Spring Cloud 版本匹配对应 Release Train Boot Version Hoxton 2.2.x Greenwich 2.1.x Finchley 2.0.x Edgware 1.5.x Dalston 1.5.x 查看版本匹配关系 https://start.spring.io/actuator/info \"Hoxton.SR3\":\"Spring Boot >=2.2.0.M4 and 或者在Spring官网Spring Cloud Reference Doc点进去可以看到,推荐的匹配版本 Release Train Version: Hoxton.SR3 Supported Boot Version: 2.2.5.RELEASE Spring Cloud 和 Spring Cloud Alibaba版本对应关系 https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E Spring Cloud Version Spring Cloud Alibaba Version Spring Boot Version Spring Cloud Hoxton.SR3 2.2.1.RELEASE 2.2.5.RELEASE Spring Cloud Hoxton.RELEASE 2.2.0.RELEASE 2.2.X.RELEASE Spring Cloud Greenwich 2.1.2.RELEASE 2.1.X.RELEASE Spring Cloud Finchley 2.0.2.RELEASE 2.0.X.RELEASE Spring Cloud Edgware 1.5.1.RELEASE 1.5.X.RELEASE Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springcloud/project.html":{"url":"program/springcloud/project.html","title":"微服务框架","keywords":"","body":"Spring Cloud 工程搭建 源码: https://github.com/yangb92/spring-cloud-yoyo 环境准备 约定 > 配置 > 编码 工程结构 project --module Maven Maven 选择3.5.2以上 开启跳过maven单元测试 skip test 字符编码 settings - Editor - File Encodings: Global Encoding UTF-8 Project Encoding UTF-8 Default encoding for properties files: UTF-8 注解激活生效 setting-build-compiler-Annotation Processors 打钩 Enable annotation processing Java编译版本 setting-build-compiler-Java Compiler 选择java版本8 File Type 过滤 settings - Editor - File Types 添加不需要显示的文件 父工程 (聚合模块) 项目创建 创建标准maven项目, 项目下面只保留pom文件. pom文件 4.0.0 org.springframework.boot spring-boot-starter-parent 2.2.5.RELEASE com.yangb microservice 0.0.1-SNAPSHOT pom microservice 微服务框架 http://book.yangb.xyz 2.2.5.RELEASE Hoxton.SR3 2.2.1.RELEASE UTF-8 1.8 1.8 4.12 1.2.17 1.16.18 5.1.47 1.1.16 1.3.0 org.springframework.boot spring-boot-dependencies ${spring-boot.version} pom import org.springframework.cloud spring-cloud-dependencies ${spring-cloud.version} pom import com.alibaba.cloud spring-cloud-alibaba-dependencies ${spring-cloud-alibaba.version} mysql mysql-connector-java ${mysql.version} com.alibaba druid ${druid.version} org.mybatis.spring.boot mybatis-spring-boot-starter ${mybatis.spring.boot.version} junit junit ${junit.version} log4j log4j ${log4j.version} org.projectlombok lombok ${lombok.version} true org.springframework.boot spring-boot-maven-plugin true true 业务模块 微服务模块步骤: 建model 改POM 写YML 主启动 业务类 例如: 支付模块 pom.xml microservice com.yangb 0.0.1-SNAPSHOT 4.0.0 business-payment jar 业务模块 - 支付 org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-actuator org.mybatis.spring.boot mybatis-spring-boot-starter com.alibaba druid-spring-boot-starter 1.1.10 mysql mysql-connector-java org.springframework.boot spring-boot-starter-jdbc org.springframework.boot spring-boot-devtools runtime true org.projectlombok lombok true org.springframework.boot spring-boot-starter-test test application.yml server: port: 8001 spring: application: name: payment-service datasource: druid: url: jdbc:mysql://localhost:3306/quick_db?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=UTC username: root password: root initial-size: 1 min-idle: 1 max-active: 20 test-on-borrow: true # driver-class-name: com.mysql.jdbc.Driver driver-class-name: com.mysql.cj.jdbc.Driver # MySql8.x mybatis: mapper-locations: classpath:mapper/*.xml type-aliases-package: com.yangb.business.payment.entity 主启动 /** * Created by YangBin on 2020/4/22 * Copyright (c) 2020 杨斌. All rights reserved. */ @SpringBootApplication public class PaymentServer { public static void main(String[] args) { SpringApplication.run(PaymentServer.class, args); } } 整合Spring Boot 单体应用快速开发框架 https://github.com/yangb92/SpringBootQuickDevlop 授权模块我们最后使用OAuth2.0统一认证, 先不进行整合. 可参考本文档SpringBoot章节 模块名称 描述 tk.mybatis 使用tk.mybatis框架,简化数据库操作。 PageHelper 分页插件 generator 自动生成Entity,Mapper和Dao 注册中心 见文档 服务发现 负载均衡 见文档 负载均衡 服务调用 见文档 服务调用 服务降级 参考文档Hystrix 服务网关 参考文档服务网关 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springcloud/Discover.html":{"url":"program/springcloud/Discover.html","title":"服务发现","keywords":"","body":"服务注册与发现 Eureka 服务端 建model 改POM 写YML 主启动 业务类 POM microservice com.yangb 0.0.1-SNAPSHOT 4.0.0 serve-discover jar org.springframework.cloud spring-cloud-starter-netflix-eureka-server org.springframework.boot spring-boot-maven-plugin true true application.yml server: port: 35001 eureka: instance: hostname: localhost client: register-with-eureka: false # 不向注册中心注册自己 fetch-registry: false # 注册中心不需要去检索服务 service-url: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ # 服务地址 主启动类 /** * Created by yangb on 2020/4/22 * Copyright (c) 2020 杨斌 All rights reserved. */ @SpringBootApplication @EnableEurekaServer public class DiscoverServer { public static void main(String[] args) { SpringApplication.run(DiscoverServer.class, args); } } 访问http://localhost:35001/ 客户端 POM org.springframework.cloud spring-cloud-starter-netflix-eureka-client application.yml # 服务注册 eureka: client: service-url: defaultZone: http://localhost:35001/eureka 在最新版本的Eurika,不需要在主启动类添加@EnableEurekaClient注解来开启了, 引入依赖自动注册服务 注册中心集群 互相注册,相互守望 修改系统hosts文件 127.0.0.1 eureka35001.com 127.0.0.1 eureka35002.com 服务端 application.yml 35001 服务 server: port: 35001 eureka: instance: hostname: eureka35001.com client: register-with-eureka: false # 不向注册中心注册自己 fetch-registry: false # 注册中心不需要去检索服务 service-url: defaultZone: http://eureka35002:35002/eureka/ # 服务地址 35002 服务 server: port: 35002 eureka: instance: hostname: eureka35002.com client: register-with-eureka: false # 不向注册中心注册自己 fetch-registry: false # 注册中心不需要去检索服务 service-url: defaultZone: http://eureka35001:35001/eureka/ # 服务地址 客户端 application.yml # 服务注册 eureka: client: service-url: defaultZone: http://eureka35001:35001/eureka,http://eureka35002:35002/eureka # 这里不一定要配置,因为默认提供的已经够用了 instance: instance-id: ${spring.application.name}:${server.port} # 实例信息 prefer-ip-address: true # 带实例IP地址 这里如果不改hosts文件, 所有地址使用默认的localhost也没有问题 Eureka自我保护机制 EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE. 如果我们在Eureka Server看到了这段提示, 说明Eureka进入了保护模式 原因 某时刻一个微服务不可用了,Eureka不会立刻清理,依旧会对该微服务的信息保存. 什么是自我保护 默认情况下, 如果Eureka在一定时间内没有接收到某个微服务实例的心跳, EurekaServer将会注销该实例(默认90s) 属于CAP里面的AP分支设计思想: 好死不如赖活着的设计哲学 关闭自我保护 服务端 eureka: server: enable-self-preservation: false # 关闭自我保护 eviction-interval-timer-in-ms: 3000 # 如果超过3秒收不到心跳,剔除此服务 客户端 eureka: instance: lease-renewal-interval-in-seconds: 30 # Eureka 客户端向服务端发送心跳的时间间隔 lease-expiration-duration-in-seconds: 90 # Eureka服务端在收到最后一次心跳后等待的时间上限, 超时将剔除服务 DiscoverClient @Autowired private DiscoveryClient discoveryClient; String clients = discoveryClient.getServices().stream() .map(item -> discoveryClient.getInstances(item).stream() .map(instance -> instance.getHost() + instance.getPort() + instance.getUri() + instance.getScheme() ).collect(Collectors.joining(\"|\"))) .collect(Collectors.joining(\"/\")); Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springcloud/ServiceCall.html":{"url":"program/springcloud/ServiceCall.html","title":"服务调用","keywords":"","body":"服务调用 OpenFeign 申明式的Web服务客户端, 只需要创建一个接口并在接口上添加注解即可. 本身已经集成了Ribbon支持负载均衡. pom.xml org.springframework.cloud spring-cloud-starter-openfeign 启动类配置 @SpringBootApplication @EnableFeignClients public class OrderServer { ... 远程接口 /** * Created by yangb on 2020/4/23 * Copyright (c) 2020 杨斌 All rights reserved. */ @FeignClient(\"PAYMENT-SERVICE\") public interface PaymentFeignService { @GetMapping(\"/payment/{id}\") ResultVo getPayment(@PathVariable(\"id\") Long id); } 超时控制 Feign 默认只等待1秒钟, 超时报错. 因为使用了ribbon, 所以配置ribbon的连接建立时间 配置超时时间: # feign 连接超时配置 ribbon: ReadTimeout: 5000 # 连接建立后响应时间 ConnectTimeout: 5000 # 建立连接所用的时间 日志功能 日志级别 NONE: 默认,不显示日志 BASIC: 记录请求方法,url,响应状态码和执行时间 HEADERS: 增加请求和响应头 FULL: 增加请求和响应的正文 配置类 /** * Created by yangb on 2020/4/23 * Copyright (c) 2020 杨斌 All rights reserved. */ @Configuration public class FeignConfig { @Bean Logger.Level feignLoggerLevel(){ return Logger.Level.FULL; } } application.yml logging: level: com.yangb.business.order.service.PaymentFeignService: debug # feign日志以什么级别监控哪个接口 断路器 启用feign断路器,会导致令牌中继失败 SecurityContextHolder.getContext().getAuthentication() 为null 启用断路器 # 启用feign熔断器 feign: hystrix: enabled: true 创建FeignClient接口的实现类,用于处理异常情况 @Service public class PaymentFeignServiceFallbackImpl implements PaymentFeignService { @Override public ResultVo error() { return ResultVo.makeFailed(\"服务响应失败\"); } } 配置在fallback属性 @FeignClient(value = \"PAYMENT-SERVICE\",fallback = PaymentFeignServiceFallbackImpl.class) public interface PaymentFeignService { @GetMapping(\"/payment/timeout\") ResultVo error(); } Ribbon + HttpTemplate Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springcloud/gateway.html":{"url":"program/springcloud/gateway.html","title":"服务网关","keywords":"","body":"服务网关 Spring Cloud Gateway Gateway 是 Zull1.x 的替代. 概念 (1) 功能特性 基于异步非阻塞模型上进行开发, 在 Spring Framework 5, Project Reactor 和 Spring Boot 2.0 进行构建. 特性: 动态路由 对路由指定 Predicate (断言) 和 Filter (过滤器). 集成 Hystrix 断路器 集成 Spring Cloud 服务发现 限流 路径重写 (2) 与Zuul的区别 Zuul1.x 基于 Servlet2.5 之上的一个阻塞式处理模型, 在高并发不具优势. Gateway 用的是 Spring WebFlux 是 Spring 5.0 引入新的响应式框架. (3) 核心概念 Route (路由) Predicate (断言) Filter (过滤) (4) 工作流程 Client -> Spring Cloud Gateway -> Gateway Handler Mapping -> Gateway Web Handler -> Filter -> Proxied Service 用法 (1) pom.xml 配置 org.springframework.cloud spring-cloud-starter-gateway org.springframework.cloud spring-cloud-starter-netflix-eureka-client (2) application.yml 配置 server: port: 35002 spring: application: name: gateway-serve cloud: gateway: routes: - id: payment-service # 路由的id, 要求唯一 uri: http://localhost:8001 # 匹配后提供服务的路由地址 predicates: - Path=/payment/** # 断言,路径匹配进行路由 - id: order-service uri: http://localhost:8002 predicates: - Path=/order/** eureka: instance: hostname: gateway-serve client: service-url: defaultZone: http://localhost:35001/eureka (3) 编码方式配置路由 参考官方文档. Tip: 你会发现还是通过yml配置路由简单一点. (4) 动态路由配置 application.yml ... spring: application: name: gateway-serve cloud: gateway: discovery: locator: enabled: true # 开启从注册中心动态创建路由的功能 routes: - id: payment-service uri: lb://PAYMENT-SERVICE # 注册中心服务地址 predicates: - Path=/payment/** ... lb://... 说明: lb 指 loadbalance (5) 断言 Predicate 官方文档 断言列表: After Route Predicate 在指定日期时间之后请求 predicates: - After=2017-01-20T17:42:47.789-07:00[America/Denver] Before Route Predicate 在指定日期时间之前请求 predicates: - Before=2017-01-20T17:42:47.789-07:00[America/Denver] Between Route Predicate 在指定日期时间之间请求 predicates: - Between=2017-01-20T17:42:47.789-07:00[America/Denver], 2017-01-21T17:42:47.789-07:00[America/Denver] Cookie Route Predicate 匹配具有给定名称且其值与正则表达式匹配的 cookie predicates: - Cookie=chocolate, ch.p Header Cookie Route Predicate 名称且其值与正则表达式匹配的 head 匹配 predicates: - Header=X-Request-Id, \\d+ Host Route Predicate 主机名匹配 predicates: - Host=**.somehost.org,**.anotherhost.org Method Route Predicate 方法匹配 predicates: - Method=GET,POST Path Route Predicate 路径匹配 predicates: - Path=/red/{segment},/blue/{segment} Query Route Predicate 参数匹配, 参数名称和参数值得正则表达式 predicates: - Query=red, gree. RemoteAddr Route Predicate IP地址匹配 ip地址/子网掩码 predicates: - RemoteAddr=192.168.1.1/24 Weight Route Predicate 配置权重, 组名称和权重值,权重是按组计算的,将20%的流量转发到这个路由 predicates: - Weight=group1, 2 (6) 过滤器 Filter 官方文档 官方自带30个过滤器网关过滤器和10个全局过滤器. 自定义过滤器 @Component @Slf4j public class AuthorizationFilter implements GlobalFilter, Ordered { @Override public Mono filter(ServerWebExchange exchange, GatewayFilterChain chain) { log.info(\"*** Coming to AuthorizationFilter\"); String uname = exchange.getRequest().getQueryParams().getFirst(\"uname\"); if (uname == null) { log.info(\"*** 用户名为Null,非法用户!\"); exchange.getResponse() .setStatusCode(HttpStatus.NON_AUTHORITATIVE_INFORMATION); return exchange.getResponse().setComplete(); } return chain.filter(exchange); } @Override public int getOrder() { // 过滤器顺序.数字越小,优先级越高 return 0; } } Spring Cloud Netflix Zuul ( 已停用 ) Zuul 1.x 版本已停用, Zuul2.0 还在开发中. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springcloud/hystrix.html":{"url":"program/springcloud/hystrix.html","title":"服务降级/熔断/限流","keywords":"","body":"服务降级/熔断/限流 概念解释 服务雪崩 \"扇出效应\": 服务A -> 服务B, 服务C; B和C又调用其他微服务. \"雪崩效应\": 如果链路上某个服务调用的时间过长或者不可用, 对服务A的调用就会占用越来越多的系统资源.进而服务崩溃. 服务熔断/服务隔离 (Fallback) 顾名思义，它是指将系统按照一定的原则划分为若干个服务模块，各个模块之间相对独立，无强依赖。当有故障发生时，能将问题和影响隔离在某个模块内部，而不扩散风险，不波及其它模块，不影响整体的系统服务。 分布式系统中,许多依赖不可避免的会调用失败, Hystrix能保证在一个依赖出问题的情况下, 不会导致整体服务失败,避免级联故障,提高分布式系统弹性. \"断路器\" 本身是一种开关装置, 某个服务单元发生故障时,向调用方返回一个预期的.可处理的备选响应(fullback) 这样就可以保证服务调用方的线程不会被长时间占用 服务降级 (Break) 什么是服务降级？当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。 服务限流 (Flowlimit) 限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。 Hystrix 项目构建 pom.xml org.springframework.cloud spring-cloud-starter-hystrix 启动类添加@EnableCircuitBreaker 启用断路器注解 @SpringBootApplication @EnableCircuitBreaker public class PaymentServer { public static void main(String[] args) { SpringApplication.run(PaymentServer.class, args); } } 降级处理 服务异常或者超时,都将执行timeoutHandler中的方法. @Override @HystrixCommand(fallbackMethod = \"timeoutHandler\",commandProperties = { @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\", value = \"5000\")}) public String errrMethod(Integer id){ try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } return \"服务超时演示!\"; } public String timeoutHandler(Integer id){ return \"服务超时\" + id; } 全局服务降级 添加全局@DefaultProperties服务降级属性 @Service @DefaultProperties(defaultFallback = \"globalFallbackMethod\") public class PaymentServiceImpl implements PaymentService { @HystrixCommand public String errrMethod(Integer id){ int x = 1/0; try { TimeUnit.SECONDS.sleep(8); } catch (InterruptedException e) { e.printStackTrace(); } return \"服务演示!\"; } public String globalFallbackMethod(){ return \"调用异常,这是全局降级方案!\"; } } 哪些情况会导致降级 程序运行异常 超时 服务熔断处罚降级 线程池/信号量 打满也会导致服务降级 熔断机制 当扇出链路的某个微服务出错不可用或者响应时间太长时, 进而熔断该节点的微服务调用,快速返回错误信息. 当检测到该节点微服务调用响应正常后,恢复调用链路. 熔断注解@HystrixCommand 半开效果, 断路器打开时,会尝试调用远程服务,如果远程服务可用, 断路器会自动关闭. HystrixCommandProperties.class 包含了熔断的默认配置属性. 隔离策略 THREAD 线程池隔离, SEMAPHORE 信号池隔离, 如果采用线程池隔离,令牌中继的时候获取登录的Authorization为空, 所以无法进行令牌传递. hystrix: command: default: #default全局有效，service id指定应用有效 execution: isolation: strategy: SEMAPHORE # 隔离策略: THREAD 线程池隔离, SEMAPHORE 信号池隔离, 如果采用线程池隔离,令牌中继的时候无法获取Authorization thread: timeoutInMilliseconds: 3000 #断路器超时时间，默认1000ms Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springcloud/config.html":{"url":"program/springcloud/config.html","title":"配置服务","keywords":"","body":"配置中心 Spring Cloud Config 配置服务器为各个不同的微服务应用的所有环境提供了一个中心化的外部配置. 本地配置 (1) 创建配置服务模块 创建 seve-config 项目 pom.xml org.springframework.cloud spring-cloud-config-server application.yml server: port: 35002 spring: application: name: serve-config cloud: config: server: native: search-locations: - 'classpath:/config-files' profiles: active: - native 配置文件保存在 resource/config-files 目录下 (2) 创建serve-oauth2客户端项目 pom.xml org.springframework.cloud spring-cloud-starter-config bootstrap.yml spring: application: name: serve-oauth2 cloud: config: uri: - http://serve-config:35002 # 配置服务地址 fail-fast: true # 如果没有读取成功，则执行快速失败(fail-fast) 这里我们为什么使用的是 bootstrap.yml，而不是 application.yml 文件，因为 bootstrap.yml 文件相对于application.yml 具有优先的执行顺序。这里我们指定了程序名为config-client.并且向Url地址为http://serve-config:35002 的 Config Server 读取配置文件。如果没有读取成功，则执行快速失败(fail-fast)。那么这个客户端是如何找到 Config Server 服务端给它提供的指定 的配置文件的呢？这个主要是默认拼接 bootstrap.yml 中的两个属性变量：${spring.application.name}, ${spring.profiles.active}，两者以“-”相连,这样就构成了Config Server中读取的文件名了. bootstrap.yml 优先级高于 application.yml, 他们可以同时存在. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springcloud/seata.html":{"url":"program/springcloud/seata.html","title":"分布式事务Seata","keywords":"","body":"分布式事务 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springcloud/springcloud-alibaba/":{"url":"program/springcloud/springcloud-alibaba/","title":"SpringCloud-Alibaba","keywords":"","body":"Spring Cloud Alibaba 资料: https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md 功能 服务限流降级：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。 服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。 分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。 消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。 分布式事务：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。。 阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。 分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。 阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。 组件 Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。 Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。 Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。 Alibaba Cloud ACM：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。 Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。 Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。 Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。 更多组件请参考 Roadmap。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springcloud/springcloud-alibaba/nacos.html":{"url":"program/springcloud/springcloud-alibaba/nacos.html","title":"服务注册/配置中心Nacos","keywords":"","body":"Nacos 服务注册和配置中心 一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 Nacos = Eureka + Config + Bus 官网: https://nacos.io/zh-cn/ 安装 下载: https://github.com/alibaba/nacos/releases 下载releases版本 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springsecurity/":{"url":"program/springsecurity/","title":"SpringSecurity","keywords":"","body":"Spring Security Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springsecurity/AuthenticationProvider.html":{"url":"program/springsecurity/AuthenticationProvider.html","title":"自定义认证对象","keywords":"","body":"自定义认证方式 自定义认证提供者 @Component public class DaoAuthenticationProvider implements AuthenticationProvider { @Autowired private AppUserMapper appUserMapper; @Autowired private AppPermissionMapper permissionMapper; @Autowired private PasswordEncoder passwordEncoder; @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException { String username = authentication.getName(); String password = authentication.getCredentials().toString(); AppUser user = appUserMapper.queryByUsername(username); if(user == null){ throw new UsernameNotFoundException(\"用户未找到\"); } if(!passwordEncoder.matches(password,user.getPassword())){ throw new BadCredentialsException(\"密码错误\"); } List permissions = permissionMapper.queryByUserid(user.getId()); return new UsernamePasswordAuthenticationToken(user,password, AuthorityUtils.createAuthorityList(permissions.stream().map(item -> item.getCode()).toArray(String[]::new))); } @Override public boolean supports(Class authentication) { return (UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication)); } } 在WebSecurityConfig中注入 /** * @author Created by yangb on 2020/4/14 */ @Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled = true) public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Resource private DaoAuthenticationProvider daoAuthenticationProvider; @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.authenticationProvider(daoAuthenticationProvider); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\").hasAuthority(\"ADMIN\") .anyRequest().authenticated() .and() .formLogin() .loginProcessingUrl(\"/login\") .successHandler((request, response, authentication) -> { //登陆陈宫返回json数据 response.setContentType(\"application/json;charset=utf-8\"); PrintWriter out = response.getWriter(); out.write(JSON.toJSONString(ResultVo.makeSuccess(\"登陆成功\"))); out.flush(); out.close(); }) .failureHandler((request, response, exception) -> { //登陆失败返回json数据 response.setContentType(\"application/json;charset=utf-8\"); PrintWriter out = response.getWriter(); ResultVo result = ResultVo.makeFailed(exception.getMessage()); out.write(JSON.toJSONString(result)); out.flush(); out.close(); }) .permitAll() .and() .csrf().disable() .exceptionHandling().authenticationEntryPoint((request, response, authException) -> { //访问未授权的资源返回数据 response.setContentType(\"application/json;charset=utf-8\"); PrintWriter out = response.getWriter(); out.write(JSON.toJSONString(ResultVo.makeFailed(\"请登录后访问\"))); out.flush(); out.close(); }); } } 验证码校验 前端提交验证码 public class CustomWebAuthenticationDetails extends WebAuthenticationDetails { @Getter // 设置getter方法，以便拿到验证码 private final String validateCode; public CustomWebAuthenticationDetails(HttpServletRequest request) { super(request); // 拿页面传来的验证码 validateCode = request.getParameter(\"validateCode\"); } } 配置认证对象 @Component public class CustomAuthenticationDetailsSource implements AuthenticationDetailsSource { @Override public WebAuthenticationDetails buildDetails(HttpServletRequest httpRequest) { return new CustomWebAuthenticationDetails(httpRequest); } } spring security 配置 @EnableWebSecurity public class WebSecurityConfig extends WebSecurityConfigurerAdapter { // 省略其他 @Autowired private AuthenticationDetailsSource authenticationDetailsSource; @Override protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(\"/get-validate-code\").permitAll() .anyRequest().authenticated() .and() .formLogin() .loginPage(\"/user-login\").permitAll() .loginProcessingUrl(\"/my-login\") .authenticationDetailsSource(authenticationDetailsSource); http.csrf().disable(); } } 自定义认证提供者 @Component public class CustomAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider { @Autowired private CustomUserDetailsService userDetailsService; @Autowired private PasswordEncoder passwordEncoder; @Override protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException { // 获取登录提交的用户名和密码 String inputPassword = (String) authentication.getCredentials(); // 获取登录提交的验证码 CustomWebAuthenticationDetails details = (CustomWebAuthenticationDetails) authentication.getDetails(); String validateCode = details.getValidateCode(); //校验验证码, 如果错误抛出自定义异常ValidateCodeException // 验证用户名 if (!passwordEncoder.matches(inputPassword, userDetails.getPassword())) { throw new BadCredentialsException(\"密码错误\"); } } @Override protected UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken) throws AuthenticationException { return userDetailsService.loadUserByUsername(username); } } 自定义异常 class ValidateCodeException extends AuthenticationException { ValidateCodeException(String message) { super(message); } } 方法二: 增加过滤器, 判断验证码 @Component public class SmsCodeFilter extends OncePerRequestFilter { @Autowired private AuthenticationFailureHandler authenticationFailureHandler; private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy(); @Override protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException { if (StringUtils.equalsIgnoreCase(\"/login/mobile\", httpServletRequest.getRequestURI()) && StringUtils.equalsIgnoreCase(httpServletRequest.getMethod(), \"post\")) { try { // 判断验证码的正确性 validateCode(new ServletWebRequest(httpServletRequest)); } catch (ValidateCodeException e) { authenticationFailureHandler.onAuthenticationFailure(httpServletRequest, httpServletResponse, e); return; } } filterChain.doFilter(httpServletRequest, httpServletResponse); } } 配置过滤器 @Configuration public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter { @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(HttpSecurity http) throws Exception { http. .addFilterBefore(smsCodeFilter, UsernamePasswordAuthenticationFilter.class) // 添加短信验证码校验过滤器 } } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springsecurity/SpringSecurity.html":{"url":"program/springsecurity/SpringSecurity.html","title":"SpringSecurity单体应用","keywords":"","body":"Spring Security 基础概念 认证 会话 授权 授权的数据模型 主体 资源 权限 角色 角色和权限关系 主体和角色关系 通常企业开发中将资源和权限表合并为一张表. 数据模型如下: 用户 - 用户角色关系 -> 角色 - 角色权限关系 -> 权限 RBAC 业界的授权方案 基于角色的访问控制 Role-Base Access Control 基于资源的访问控制 Resource-Based Access Control 基于Session的认证方式 Spring Security WebSecurityConfig 用户信息 密码编码器 安全拦截机制 结构总览 解决用户的 安全访问控制, Spring Security 对web资源的保护是靠Filter实现的. SpringSecurityFilterChain 是一个 Servlet 过滤器 实现了 javax.servlet.Filter. 过滤外部请求. FilterChainProxy代理了多个Filter, 形成Filter链表. AuthenticationManager 负责授权, AccessDecisionManager 负责认证, 自定义UserDetailService @Service public class SpringDataUserDetailService implements UserDetailsService PasswordEncoder 使用BCryptPasswordEncoder加密 @Bean public PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } BCrypt 加密,每次加密结果都不一样,但是校验可以通过,增加了安全性 // 加密原始密码 String hashpw = BCrypt.hashpw(\"123\", BCrypt.gensalt()); System.out.println(hashpw); //校验密码一致性 boolean checkpw = BCrypt.checkpw(\"123\", \"$2a$10$e/Vgw1zKQDdyxd/DvyNSMeeT0TQhaDB9KbUoN8jC2f8MV9lGUobcy\"); System.out.println(checkpw); boolean checkpw1 = BCrypt.checkpw(\"123\", \"$2a$10$jIueZHE5S7WJjnZrD//HDugBxKsdLdYfuarmXC.R8S6rJqCv3ifEu\"); System.out.println(checkpw1); 安全拦截 @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/r/r1\").hasAuthority(\"p1\") .antMatchers(\"/r/r2\").hasAuthority(\"p2\") .antMatchers(\"/r\").authenticated() .anyRequest().permitAll() .and() .formLogin(); } 自定义登录页面 增加登录页面 @GetMapping(\"/login-view\") public String login(){ return \"login\"; } 自定义登录页面 login.html 用户名: 密码: 配置http安全设置 @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() ... .formLogin() .loginPage(\"/login-view\") // 登录页面 .loginProcessingUrl(\"/login\") //登录路径 .successForwardUrl(\"/r\") //登录成功跳转路径 .permitAll() .and() .csrf().disable(); // 关闭csrf安全验证 连接数据库认证 添加数据库依赖 org.springframework.boot spring-boot-starter-data-jdbc mysql mysql-connector-java 5.1.48 配置数据库 spring: datasource: username: root password: root url: jdbc:mysql://localhost:3306/user_db driver-class-name: com.mysql.jdbc.Driver 实体DTO @Data @Table(\"t_user\") public class UserDto { @Id private String id; private String username; private String password; private String fullname; private String mobile; } Dao @Repository public interface UserDao extends CrudRepository { @Query(\"SELECT * FROM `t_user` where username=:username\") UserDto findByUsername(@Param(\"username\") String username); } UserDetailService @Autowired private UserDao userDao; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { UserDto userDto = userDao.findByUsername(username); if(userDto == null){ // 如果用户查不到, 返回null, 由provider抛出异常 return null; } UserDetails details = User.withUsername(userDto.getUsername()).password(userDto.getPassword()).authorities(\"p1\").build(); return details; } 会话管理 获取用户身份 //获取当前用户信息 private String getUsername(){ Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); Object principal = authentication.getPrincipal(); if(principal == null){ return \"匿名用户\"; } if (principal instanceof UserDetails){ UserDetails userDetails = (UserDetails) principal; return userDetails.getUsername(); }else { return principal.toString(); } } 会话控制 机制 描述 always 如果没有session存在就创建一个 ifRequired 如果需要就创建一个Session(默认)登录时 never SpringSecurity将不会创建Session,但是如果应用中其他地方创建了Session,那么SpringSecurity将使用它 stateless 绝对不会创建和使用 配置方式 @Override protected void configure(HttpSecurity http) throws Exception { http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED); 自定义退出 .logout() .logoutUrl(\"/logout\") //退出地址 .logoutSuccessUrl(\"/index\"); //退出页面 Web的授权 使用资源授权, 更灵活. http.authorizeRequests() .antMatchers(\"/r/r1\").hasAuthority(\"p1\") .antMatchers(\"/r/r2\").hasAuthority(\"p2\") .antMatchers(\"/r/r3\").hasAnyAuthority(\"p1\",\"p2\") .antMatchers(\"/r/r4\").access(\"hasAuthority('p1') and hasAuthority('p2')\") .antMatchers(\"/r/**\").authenticated() .anyRequest().permitAll() 方法授权 建议基于Controller进行拦截 开启方法拦截 @EnableGlobalMethodSecurity(prePostEnabled = true) //开启方法授权 public class WebSecurityConfig extends WebSecurityConfigurerAdapter{ @PreAuthorize 在方法上加注解 p1 权限才能访问 @RequestMapping(\"/r/r1\") @PreAuthorize(\"hasAuthority('p1')\") public String r1(ModelMap map){ map.put(\"name\", \"权限1页面\"); return \"index\"; } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springsecurity/SpringSecurityOAuth2.html":{"url":"program/springsecurity/SpringSecurityOAuth2.html","title":"SpringSecurityOAuth2.0认证中心","keywords":"","body":"分布式系统认证方案 基于Token的认证方式更适合分布式认证. 项目搭建 https://github.com/yangb92/SpringAuthorization/tree/spring-cloud-security-oauth2 配置授权服务 创建配置类,开启认证服务 @Configuration @EnableAuthorizationServer public class AuthorizationServer extends AuthorizationServerConfigurerAdapter { 配置客户端详细信息 clentId: (必须) 客户id标识 secret: 客户端安全码 scope: 客户端权限 authorizedGrantTypes: 客户端授权类型,默认为空 authorities: 此客户端可以使用的授权类型,默认为空 内存方式配置客户端 @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient(\"c1\") .secret(new BCryptPasswordEncoder().encode(\"secret\")) //客户端秘钥 .resourceIds(\"res1\", \"res2\") //可访问资源列表 .authorizedGrantTypes(\"authorization_code\", \"password\", \"client_credentials\", \"implicit\", \"refresh_token\") //运行授权的类型 .scopes(\"all\") //允许授权的范围 .autoApprove(false) // false 跳转到授权页面 .redirectUris(\"http://www.baidu.com\") //授权回调地址 .and() .withClient ... } 配置令牌访问的端点和令牌服务 令牌服务 TokenStore: 令牌存储策略 InMemoryTokenStore: 存储在内存 工作在单服务器 JdbcTokenStore: 存储在数据库 可以在多个服务器共享 JwtTokenStore: 不需要后端存储 配置存储方式令牌 存在内存 @Configuration public class TokenConfig { @Bean public TokenStore tokenStore() { return new InMemoryTokenStore(); } } 配置令牌管理服务 @Autowired private TokenStore tokenStore; @Autowired private ClientDetailsService clientDetailsService; // 令牌管理服务 @Bean public AuthorizationServerTokenServices tokenServices() { DefaultTokenServices services = new DefaultTokenServices(); services.setClientDetailsService(clientDetailsService); // 客户端详情服务 services.setSupportRefreshToken(true); // 支持令牌刷新 services.setTokenStore(tokenStore); // 令牌存储策略 services.setAccessTokenValiditySeconds(7200); // 令牌有效期2小时 services.setRefreshTokenValiditySeconds(259200); // 刷新令牌默认有效期3天 return services; } 令牌访问端点配置 AuthorizationServerEndpointsConfigurer 通过设定以下属性决定支持的授权类型(Grant Types) authenticationManager: 认证管理器,password授权类型.用于密码模式需要配置 UserDetailService: 用于密码模式需要配置 authorizationCodeServices: 设置授权码服务的,用于authorization_code授权类型 implicitGrantService: 用于设置隐式授权模式. tokenGranter: 当设置了即TokenGranter接口实现, 授权将由自己掌控, 这个一般用来做扩展用途. 配置授权端点的URL(Endpoint URLs) AuthorizationServerEndpointsConfiguration 这个配置对象有一个叫做pathMapping()的方法用来配置端点的URL连接 第一个参数:默认连接, 第二个参数:你需要替换的连接 框架默认的连接如下: /oauth/authorize: 授权端点 /oauth/token: 令牌端点 /oauth/confirm_access: 用户确认授权端点 /oauth/error: 授权服务错误信息端点 /oauth/check_token: 用于资源服务访问的令牌解析端点 /oauth/token_key: 提供公有密匙的端点, 如果使用JWT令牌的话 WebSecurity配置 @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) @Configuration public class WebSecurityConfig extends WebSecurityConfigurerAdapter { // 认证管理器 @Bean @Override protected AuthenticationManager authenticationManager() throws Exception { return super.authenticationManager(); } // 密码编码器 @Bean public PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } // 安全拦截机制 @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/r/r1\").hasAuthority(\"p1\") .antMatchers(\"/login**\").permitAll() .anyRequest().authenticated() .and() .formLogin(); } } 配置令牌访问端点和授权码服务 @Configuration @EnableAuthorizationServer public class AuthorizationServer extends AuthorizationServerConfigurerAdapter { @Autowired private TokenStore tokenStore; @Autowired private ClientDetailsService clientDetailsService; @Autowired private AuthorizationCodeServices authorizationCodeServices; @Autowired private AuthenticationManager authenticationManager; @Autowired private AuthorizationServerTokenServices tokenServices; // 令牌访问端点 @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints.authenticationManager(authenticationManager) //认证管理器 .authorizationCodeServices(authorizationCodeServices) // 授权码服务 .tokenServices(tokenServices) // 令牌管理服务 .allowedTokenEndpointRequestMethods(HttpMethod.POST); } // 配置授权码服务 @Bean public AuthorizationCodeServices authorizationCodeServices() { // 设置授权码模式的授权码如何存取,暂时采用内存方式 return new InMemoryAuthorizationCodeServices(); } ... 配置令牌端点的安全约束 // 令牌访问安全约束 @Override public void configure(AuthorizationServerSecurityConfigurer security) throws Exception { security .tokenKeyAccess(\"permitAll()\") //oauth/token_key 是公开 .checkTokenAccess(\"permitAll()\") //oauth/check_token 公开 .allowFormAuthenticationForClients(); //表单认证 } 授权码模式 最为安全 资源拥有者打开客户端,客户端要求资源拥有者给予授权,它将被浏览器重定向到服务器,重定向时会附加客户端身份信息./uaa/oauth/authorize?client_id=c1&response_type=code&scope=all&redirect_url=http://www.baidu.com/ 参数: client_id: 客户端标识 response_type: 授权码模式固定位code scope:客户端权限 redirect: 跳转url,授权码申请成功后跳转到此地址,并在后面带上code参数(授权码) 和配置客户端跳转url一致 浏览器重定向授权服务器授权页面,之后用户将同意授权 授权服务器授权码(AuthorizationCode)带到url参数上发送给client(通过redirect_uri) 客户端拿着授权码向授权服务器索要访问access_token/uaa/oauth/token?client_id=c1&client_secret=secret&grant_type=authorization_code&code=5pgxfcD&redirect_uri=http://www.baidu.com/ 参数: cilent_id: 客户端标识 secret: 客户端密匙 grant_type: 授权类型 code: 授权码, 注意:授权码只使用一次就无效了. redirect_uri: 和配置客户端跳转url一致 服务器返回授权码 { \"access_token\": \"6b94c4c1-1803-484e-b5da-943b96266ff1\", \"token_type\": \"bearer\", \"refresh_token\": \"8b4a2631-ef09-4145-9f32-f96b0904e5d8\", \"expires_in\": 43199, \"scope\": \"all\" } 简化模式 资源拥有者打开客户端,要求资源拥有者给与授权,它将被浏览器重定向到授权服务器, 重定向时会附加客户端信息. /uaa/oauth/authorize?client_id=c1&response_type=token&scope=all&redirect_uri=http://www.baidu.com response_type=token 说明是简化模式 浏览器重定向到授权服务器页面,用户同意授权 授权服务器将令牌,以Hash的形式存放在重定向uri的fragment发送给浏览器.https://www.baidu.com/#access_token=6b94c4c1-1803-484e-b5da-943b96266ff1&token_type=bearer&expires_in=42776 注: fragment http://example.com#L18 这个L18就是fragment的值. 一般来说,简化模式用于没有服务端的第三方单页面应用. 密码模式 资源拥有者将用户名,密码发送给客户端. 客户端拿着用户名和密码向授权服务器请求令牌/uaa/oauth/token?client_id=c1&client_secret=secret&grant_type=password&username=lisi&password=123 授权服务器将令牌发送给client] 这种模式十分简单,意味着直接将用户敏感信息泄露给了client, 因此这种模式只适用于我们自己的系统 客户端模式 客户端向授权服务器发送自己的身份信息,并请求令牌 确认客户端身份无误后,将令牌发送给clien /uaa/oauth/token?client_id=c1&client_secret=secret&grant_type=client_credentials 资源服务器配置 资源服务配置 测试: GET http://localhost:53021/order/r1 首先申请Token,将Token放在请求头中,访问资源服务接口 Authorization:Bearer 6b94c4c1-1803-484e-b5da-943b96266ff1 JWT 令牌 介绍 JWT令牌本身存储了用户信息.不需要进行存储. 优点: 基于json 自定义内容,易扩展. 非对称加密,防篡改,安全 资源服务使用JWT不依赖认证服务. 缺点: 令牌过长, 占用空间大. JWT令牌结构 Header Payload Signture UAA 认证端配置 配置: JWT TockenStore private String SIGN_KEY = \"123\"; @Bean public TokenStore tokenStore() { // JWT 令牌存储方案 return new JwtTokenStore(accessTokenConverter()); } // 令牌转换器 @Bean public JwtAccessTokenConverter accessTokenConverter() { JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); converter.setSigningKey(SIGN_KEY); // 对称密匙 return converter; } 配置令牌管理服务 // 令牌管理服务 @Bean @DependsOn({\"tokenStore\",\"accessTokenConverter\"}) public AuthorizationServerTokenServices tokenServices(ClientDetailsService clientDetailsService) { DefaultTokenServices services = new DefaultTokenServices(); services.setClientDetailsService(clientDetailsService); // 客户端详情服务 services.setSupportRefreshToken(true); // 支持令牌刷新 services.setTokenStore(tokenStore); // 令牌存储策略 // 令牌增强 TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain(); tokenEnhancerChain.setTokenEnhancers(Arrays.asList(accessTokenConverter)); services.setTokenEnhancer(tokenEnhancerChain); services.setAccessTokenValiditySeconds(7200); // 令牌有效期2小时 services.setRefreshTokenValiditySeconds(259200); // 刷新令牌默认有效期3天 return services; } 资源服务配置 TokenConfig @Configuration public class TokenConfig { private String SIGN_KEY = \"123\"; @Bean public TokenStore tokenStore() { // JWT 令牌存储方案 return new JwtTokenStore(accessTokenConverter()); } // 令牌转换器 @Bean public JwtAccessTokenConverter accessTokenConverter() { JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); converter.setSigningKey(SIGN_KEY); // 对称密匙 return converter; } } 资源服务配置 @Override public void configure(ResourceServerSecurityConfigurer resources) throws Exception { resources.resourceId(RESOURCE_ID) // .tokenServices(tokenServices) //验证令牌的服务 .tokenStore(tokenStore) .stateless(true); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springsecurity/ContextRepository.html":{"url":"program/springsecurity/ContextRepository.html","title":"Redis会话共享","keywords":"","body":"定制 Security 上下文存储 使用Redis管理会话 Docker Redis安装 在目录/usr/local/docker/redis创建docker-compose.yml配置文件 docker-compose.yml version: '3' services: redis: image: redis:5 container_name: redis restart: always ports: - '6379:6379' volumes: - ./data:/data 运行 docker-compose up -d 加入Redis依赖 org.springframework.boot spring-boot-starter-data-redis application.yml配置文件 spring: redis: host: 192.168.10.45 timeout: 3000 配置RedisConfig.java配置文件 /** * Created by yangb on 2020/4/17 */ @Configuration public class RedisConfig { @Bean public RedisTemplate securityContextRedisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); template.setValueSerializer(new SecurityContextSerializer()); return template; } /** * SecurityContext 序列化 */ private class SecurityContextSerializer implements RedisSerializer{ @Override public byte[] serialize(SecurityContext securityContext) throws SerializationException { if (securityContext == null) { return null; } String s = JSON.toJSONString(securityContext); return s.getBytes(Charset.forName(\"UTF-8\")); } @Override public SecurityContext deserialize(byte[] bytes) throws SerializationException { SecurityContextImpl securityContext = new SecurityContextImpl(); if (bytes == null) { return securityContext; } String json = new String(bytes, Charset.forName(\"UTF-8\")); final JSONObject jb = JSON.parseObject(json); JSONObject authentication = jb.getJSONObject(\"authentication\"); if(authentication == null) { return securityContext; } AppUser user = authentication.getObject(\"principal\", AppUser.class); JSONArray authorities = authentication.getJSONArray(\"authorities\"); String [] authoritiesArray = new String[authorities.size()]; for (int i = 0; i 配置RedisSecurityContextRepository.java上下文仓库 /** * Created by yangb on 2020/4/17 */ @Component public class RedisSecurityContextRepository implements SecurityContextRepository { @Resource private RedisTemplate securityContextRedisTemplate; @Override public SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder) { String requestedSessionId = requestResponseHolder.getRequest().getRequestedSessionId(); return securityContextRedisTemplate.opsForValue().get(requestedSessionId); } @Override public void saveContext(SecurityContext context, HttpServletRequest request, HttpServletResponse response) { String requestedSessionId = request.getRequestedSessionId(); securityContextRedisTemplate.opsForValue().set(requestedSessionId,context,30, TimeUnit.MINUTES); } @Override public boolean containsContext(HttpServletRequest request) { return securityContextRedisTemplate.hasKey(request.getRequestedSessionId()); } /** * 清除Redis上下文 */ public boolean cleanContext(HttpServletRequest request){ return securityContextRedisTemplate.delete(request.getRequestedSessionId()); } } 配置上下文仓库 和 退出时执行清除Redis中上下环境, @Override protected void configure(HttpSecurity http) throws Exception { http .securityContext() .securityContextRepository(redisSecurityContextRepository); .logout() .logoutSuccessHandler((request, response, authentication) -> { redisSecurityContextRepository.cleanContext(request); //清除缓存会话 }) ... Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springmvc/":{"url":"program/springmvc/","title":"SpringMVC","keywords":"","body":"Spring MVC Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/springmvc/HandlerMethodArgumentResolver.html":{"url":"program/springmvc/HandlerMethodArgumentResolver.html","title":"自定义参数解析器","keywords":"","body":"自定义参数解析器 HandlerMethodArgumentResolver 定义注解 /** * 标记当前用户注解, 由MVC参数解析器注入 * @author Created by yangb on 2020/4/14 */ @Target({ElementType.PARAMETER}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface CurrentUser { } 定义参数解析器UserHandlerMethodArgumentResolver.java /** * 自定义参数解析器 * @author Created by yangb on 2020/4/14 */ public class UserHandlerMethodArgumentResolver implements HandlerMethodArgumentResolver { @Override public boolean supportsParameter(MethodParameter methodParameter) { //判断是否需要解析参数, 如果方法参数有CurrentUser注解,需要解析返回true return methodParameter.hasParameterAnnotation(CurrentUser.class); } @Override public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception { // 解析参数,返回参数对象 Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal(); if(principal instanceof AppUser){ return (AppUser) principal; } return null; } } 在MVC中配置该参数解析器 @Configuration public class WebMvcConfig implements WebMvcConfigurer { /** * 添加参数解析器 * @param resolvers */ @Override public void addArgumentResolvers(List resolvers) { resolvers.add(new UserHandlerMethodArgumentResolver()); } } 在Controller中使用 @RequestMapping(\"/admin\") public ResultVo admin(@CurrentUser AppUser user) { return ResultVo.makeSuccess(user); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/docker/":{"url":"program/docker/","title":"Docker","keywords":"","body":"Docker Docker 文档: https://www.funtl.com/zh/docs-docker/ 小技巧 查看容器日志 方法一 docker-compose logs --tail=10 方法二 docker attach apl_server 退出: 推荐使用 CTRL + p CTRL + q 方法退出, ctrl + c 会关闭容器. Dockerfile ADD和COPY的区别 ADD 命令对压缩文件在添加到容器的时候执行解压缩操作 COPY指令和ADD指令功能和使用方式类似。只是COPY指令不会做自动解压工作。 访问宿主机网络 宿主机IP: 172.17.0.1 标题 说明 镜像(Images) Docker 镜像是用于创建 Docker 容器的模板。 容器(Container) 容器是独立运行的一个或一组应用。 客户端(Client) Docker 客户端通过命令行或者其他工具使用 Docker API (https://docs.docker.com/reference/api/docker_remote_api) 与 Docker 的守护进程通信。 主机(Host) 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。 仓库(Registry) Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。 Docker Machine Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/docker/install.html":{"url":"program/docker/install.html","title":"Docker 安装","keywords":"","body":"Docker安装 CentOS 安装 脚本自动安装 $ curl -fsSL get.docker.com -o get-docker.sh $ sudo sh get-docker.sh --mirror Aliyun 启动Docker $ sudo systemctl enable docker $ sudo systemctl start docker Ubuntu 安装 脚本自动安装: curl -fsSL get.docker.com -o get-docker.sh sh get-docker.sh --mirror Aliyun 检测Docker是否安装成功 docker version 配置阿里云Docker镜像加速器 下载镜像 docker pull 镜像名称 启动镜像 docker run -p 80:8080 tomcat 建立 docker 用户组 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 建立 docker 组： $ sudo groupadd docker 将当前用户加入 docker 组： $ sudo usermod -aG docker $USER 退出当前终端并重新登录，进行如下测试 测试 Docker 是否安装正确 $ docker run hello-world Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world ca4f61b1923c: Pull complete Digest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905c Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://cloud.docker.com/ For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ 若能正常输出以上信息，则说明安装成功。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/docker/docker-sever.html":{"url":"program/docker/docker-sever.html","title":"Docker 伺服","keywords":"","body":"Docker 伺服 有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。 安装运行 docker-registry $ docker run -d -p 5000:5000 --restart=always --name registry registry 这将使用官方的 registry 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 /var/lib/registry 目录下。你可以通过 -v 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 /opt/data/registry 目录。 $ docker run -d \\ -p 5000:5000 \\ -v /opt/data/registry:/var/lib/registry \\ registry 在私有仓库上传、搜索、下载镜像 使用 docker push 上传标记的镜像。 $ docker push 127.0.0.1:5000/ubuntu:latest The push refers to repository [127.0.0.1:5000/ubuntu] 373a30c24545: Pushed a9148f5200b0: Pushed cdd3de0940ab: Pushed fc56279bbb33: Pushed b38367233d37: Pushed 2aebd096e0e2: Pushed latest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568 用 curl 查看仓库中的镜像。 $ curl 127.0.0.1:5000/v2/_catalog {\"repositories\":[\"ubuntu\"]} 先删除已有镜像，再尝试从私有仓库中下载这个镜像 $ docker image rm 127.0.0.1:5000/ubuntu:latest $ docker pull 127.0.0.1:5000/ubuntu:latest Pulling repository 127.0.0.1:5000/ubuntu:latest ba5877dc9bec: Download complete 511136ea3c5a: Download complete 9bad880da3d2: Download complete 25f11f5fb0cb: Download complete ebc34468f71d: Download complete 2318d26665ef: Download complete $ docker image ls REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE 127.0.0.1:5000/ubuntu:latest latest ba5877dc9bec 6 weeks ago 192.7 MB 注意事项 如果你不想使用 127.0.0.1:5000 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 192.168.199.100:5000 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。 这是因为 Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 HTTPS 访问的私有仓库。 Ubuntu 14.04, Debian 7 Wheezy 对于使用 upstart 的系统而言，编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS 中增加如下内容： DOCKER_OPTS=\"--registry-mirror=https://registry.docker-cn.com --insecure-registries=192.168.199.100:5000\" 重新启动服务。 $ sudo service docker restart Ubuntu 16.04+, Debian 8+, centos 7 对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件） { \"registry-mirrors\": [ \"https://registry.docker-cn.com\" ], \"insecure-registries\": [ \"192.168.199.100:5000\" ] } 其他 对于 Docker for Windows 、 Docker for Mac 在设置中编辑 daemon.json 增加和上边一样的字符串即可。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/docker/Compose.html":{"url":"program/docker/Compose.html","title":"Docker-Compose安装卸载","keywords":"","body":"Docker Compose 学习地址https://www.funtl.com/zh/docker-compose/ Docker 三剑客之一, 必会. 负责实现对Docker集群的快速编排. 安装 Compose 支持 Linux、macOS、Windows 10 三大平台。Compose 可以通过 Python 的包管理工具 pip 进行安装 二进制包 $ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose $ sudo chmod +x /usr/local/bin/docker-compose PIP 安装 $ sudo pip install -U docker-compose 测试 docker-compose version bash 补全命令 $ curl -L https://raw.githubusercontent.com/docker/compose/1.8.0/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose 容器中执行 Compose 既然是一个 Python 应用，自然也可以直接用容器来执行它。 $ curl -L https://github.com/docker/compose/releases/download/1.8.0/run.sh > /usr/local/bin/docker-compose $ chmod +x /usr/local/bin/docker-compose 卸载 如果是二进制包方式安装的，删除二进制文件即可。 $ sudo rm /usr/local/bin/docker-compose 如果是通过 pip 安装的，则执行如下命令即可删除。 $ sudo pip uninstall docker-compose 基本使用 编写docker-compose.yml 这个是Compose使用的主模板文件 version: '3' services: tomcat: restart: always image: tomcat container_name: tomcat ports: - 80:8080 运行compose项目 docker-compose up [--build] [-d] --build: 重新构建Dockerfile -d: 后台运行 关闭docker项目 docker-compose down [--rmi all] 关闭并移除构建的镜像 Docker-compose 环境变量 设置环境变量默认值 ${SERVER-PORT:-12580} 使用文件设置环境变量 web: env_file: - web-variables.env compose file 中为容器设置环境变量： web: environment: DEBUG: 1 .env 文件为 docker-compose.yml 文件引用的所有环境变量设置默认值！ # define env var default value. IMAGETAG=defaultwebimage APPNAME=default app name AUTHOR=default author name VERSION=default version is 1.0 使用.env中的环境变量 version: '3' services: web: image: ${IMAGETAG} Docker 环境变量 shell 写法 docker run -e DEBUG=1 shell写法: docker run --env-file=web-variables.env Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/docker/ComposeCommand.html":{"url":"program/docker/ComposeCommand.html","title":"Docker-Compose命令说明","keywords":"","body":"Docker-Compose 命令说明 命令对象与格式 对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。 执行 docker-compose [COMMAND] --help 或者 docker-compose help [COMMAND] 可以查看具体某个命令的使用格式。 docker-compose 命令的基本的使用格式是 docker-compose [-f=...] [options] [COMMAND] [ARGS...] 命令选项 -f, --file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。 -p, --project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。 --x-networking 使用 Docker 的可拔插网络后端特性 --x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge --verbose 输出更多调试信息。 -v, --version 打印版本并退出。 build 格式为 docker-compose build [options] [SERVICE...]。 构建（重新构建）项目中的服务容器。 服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。 可以随时在项目目录下运行 docker-compose build 来重新构建服务。 选项包括： --force-rm 删除构建过程中的临时容器。 --no-cache 构建镜像过程中不使用 cache（这将加长构建过程）。 --pull 始终尝试通过 pull 来获取更新版本的镜像。 #config 验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。 #down 此命令将会停止 up 命令所启动的容器，并移除网络 #exec 进入指定的容器。 #help 获得一个命令的帮助。 #images 列出 Compose 文件中包含的镜像。 #kill 格式为 docker-compose kill [options] [SERVICE...]。 通过发送 SIGKILL 信号来强制停止服务容器。 支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。 $ docker-compose kill -s SIGINT 1 #logs 格式为 docker-compose logs [options] [SERVICE...]。 查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 --no-color 来关闭颜色。 该命令在调试问题的时候十分有用。 #pause 格式为 docker-compose pause [SERVICE...]。 暂停一个服务容器。 #port 格式为 docker-compose port [options] SERVICE PRIVATE_PORT。 打印某个容器端口所映射的公共端口。 选项： --protocol=proto 指定端口协议，tcp（默认值）或者 udp。 --index=index 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。 #ps 格式为 docker-compose ps [options] [SERVICE...]。 列出项目中目前的所有容器。 选项： -q 只打印容器的 ID 信息。 #pull 格式为 docker-compose pull [options] [SERVICE...]。 拉取服务依赖的镜像。 选项： --ignore-pull-failures 忽略拉取镜像过程中的错误。 #push 推送服务依赖的镜像到 Docker 镜像仓库。 #restart 格式为 docker-compose restart [options] [SERVICE...]。 重启项目中的服务。 选项： -t, --timeout TIMEOUT 指定重启前停止容器的超时（默认为 10 秒）。 #rm 格式为 docker-compose rm [options] [SERVICE...]。 删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。 选项： -f, --force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。 -v 删除容器所挂载的数据卷。 #run 格式为 docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]。 在指定服务上执行一个命令。 例如： $ docker-compose run ubuntu ping docker.com 1 将会启动一个 ubuntu 服务容器，并执行 ping docker.com 命令。 默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。 该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。 两个不同点： 给定命令将会覆盖原有的自动运行命令； 不会自动创建端口，以避免冲突。 如果不希望自动启动关联的容器，可以使用 --no-deps 选项，例如 $ docker-compose run --no-deps web python manage.py shell 1 将不会启动 web 容器所关联的其它容器。 选项： -d 后台运行容器。 --name NAME 为容器指定一个名字。 --entrypoint CMD 覆盖默认的容器启动指令。 -e KEY=VAL 设置环境变量值，可多次使用选项来设置多个环境变量。 -u, --user=\"\" 指定运行容器的用户名或者 uid。 --no-deps 不自动启动关联的服务容器。 --rm 运行命令后自动删除容器，d 模式下将忽略。 -p, --publish=[] 映射容器端口到本地主机。 --service-ports 配置服务端口并映射到本地主机。 -T 不分配伪 tty，意味着依赖 tty 的指令将无法运行。 #scale 格式为 docker-compose scale [options] [SERVICE=NUM...]。 设置指定服务运行的容器个数。 通过 service=num 的参数来设置数量。例如： $ docker-compose scale web=3 db=2 1 将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。 一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。 选项： -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 #start 格式为 docker-compose start [SERVICE...]。 启动已经存在的服务容器。 #stop 格式为 docker-compose stop [options] [SERVICE...]。 停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。 选项： -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 #top 查看各个服务容器内运行的进程。 #unpause 格式为 docker-compose unpause [SERVICE...]。 恢复处于暂停状态中的服务。 #up 格式为 docker-compose up [options] [SERVICE...]。 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。 链接的服务都将会被自动启动，除非已经处于运行状态。 可以说，大部分时候都可以直接通过该命令来启动一个项目。 默认情况，docker-compose up 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。 当通过 Ctrl-C 停止命令时，所有容器将会停止。 如果使用 docker-compose up -d，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。 默认情况，如果服务容器已经存在，docker-compose up 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 docker-compose up --no-recreate。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 docker-compose up --no-deps -d 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。 选项： -d 在后台运行服务容器。 --no-color 不使用颜色来区分不同的服务的控制台输出。 --no-deps 不启动服务所链接的容器。 --force-recreate 强制重新创建容器，不能与 --no-recreate 同时使用。 --no-recreate 如果容器已经存在了，则不重新创建，不能与 --force-recreate 同时使用。 --no-build 不自动构建缺失的服务镜像。 -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 #version 格式为 docker-compose version。 打印版本信息。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/docker/ComposeTemplate.html":{"url":"program/docker/ComposeTemplate.html","title":"Docker-Compose模板文件","keywords":"","body":"Docker Compose 模板文件 模板文件是使用 Compose 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 docker run 相关参数的含义都是类似的。 默认的模板文件名称为 docker-compose.yml，格式为 YAML 格式。 version: \"3\" services: webapp: image: examples/web ports: - \"80:80\" volumes: - \"/data\" 注意每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）等来自动构建生成镜像。 如果使用 build 指令，在 Dockerfile 中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在 docker-compose.yml 中再次设置。 下面分别介绍各个指令的用法。 build 指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。 version: '3' services: webapp: build: ./dir 你也可以使用 context 指令指定 Dockerfile 所在文件夹的路径。 使用 dockerfile 指令指定 Dockerfile 文件名。 使用 arg 指令指定构建镜像时的变量。 version: '3' services: webapp: build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 使用 cache_from 指定构建镜像的缓存 build: context: . cache_from: - alpine:latest - corp/web_app:3.14 cap_add, cap_drop 指定容器的内核能力（capacity）分配。 例如，让容器拥有所有能力可以指定为： cap_add: - ALL 去掉 NET_ADMIN 能力可以指定为： cap_drop: - NET_ADMIN command 覆盖容器启动后默认执行的命令。 command: echo \"hello world\" configs 仅用于 Swarm mode cgroup_parent 指定父 cgroup 组，意味着将继承该组的资源限制。 例如，创建了一个 cgroup 组名称为 cgroups_1。 cgroup_parent: cgroups_1 container_name 指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式。 container_name: docker-web-container 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。 deploy 仅用于 Swarm mode devices 指定设备映射关系。 devices: - \"/dev/ttyUSB1:/dev/ttyUSB0\" #depends_on 解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web version: '3' services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres 注意：web 服务不会等待 redis db 「完全启动」之后才启动。 #dns 自定义 DNS 服务器。可以是一个值，也可以是一个列表。 dns: 8.8.8.8 dns: - 8.8.8.8 - 114.114.114.114 #dns_search 配置 DNS 搜索域。可以是一个值，也可以是一个列表。 dns_search: example.com dns_search: - domain1.example.com - domain2.example.com #tmpfs 挂载一个 tmpfs 文件系统到容器。 tmpfs: /run tmpfs: - /run - /tmp #env_file 从文件中获取环境变量，可以为单独的文件路径或列表。 如果通过 docker-compose -f FILE 方式来指定 Compose 模板文件，则 env_file 中变量的路径会基于模板文件路径。 如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准。 env_file: .env env_file: - ./common.env - ./apps/web.env - /opt/secrets.env 环境变量文件中每一行必须符合格式，支持 # 开头的注释行。 # common.env: Set development environment PROG_ENV=development #environment 设置环境变量。你可以使用数组或字典两种格式。 只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。 environment: RACK_ENV: development SESSION_SECRET: environment: - RACK_ENV=development - SESSION_SECRET 如果变量名称或者值中用到 true|false，yes|no 等表达 布尔 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括 y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF #expose 暴露端口，但不映射到宿主机，只被连接的服务访问。 仅可以指定内部端口为参数 expose: - \"3000\" - \"8000\" #external_links 注意：不建议使用该指令。 链接到 docker-compose.yml 外部的容器，甚至并非 Compose 管理的外部容器。 external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql #extra_hosts 类似 Docker 中的 --add-host 参数，指定额外的 host 名称映射信息。 extra_hosts: - \"googledns:8.8.8.8\" - \"dockerhub:52.1.157.61\" 会在启动后的服务容器中 /etc/hosts 文件中添加如下两条条目。 8.8.8.8 googledns 52.1.157.61 dockerhub #healthcheck 通过命令检查容器是否健康运行。 healthcheck: test: [\"CMD\", \"curl\", \"-f\", \"http://localhost\"] interval: 1m30s timeout: 10s retries: 3 #image 指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。 image: ubuntu image: orchardup/postgresql image: a4bc65fd #labels 为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。 labels: com.startupteam.description: \"webapp for a startup team\" com.startupteam.department: \"devops department\" com.startupteam.release: \"rc3 for v1.0\" #links 注意：不推荐使用该指令。 #logging 配置日志选项。 logging: driver: syslog options: syslog-address: \"tcp://192.168.0.42:123\" 目前支持三种日志驱动类型。 driver: \"json-file\" driver: \"syslog\" driver: \"none\" options 配置日志驱动的相关参数。 options: max-size: \"200k\" max-file: \"10\" #network_mode 设置网络模式。使用和 docker run 的 --network 参数一样的值。 network_mode: \"bridge\" network_mode: \"host\" network_mode: \"none\" network_mode: \"service:[service name]\" network_mode: \"container:[container name/id]\" #networks 配置容器连接的网络。 version: \"3\" services: some-service: networks: - some-network - other-network networks: some-network: other-network: #pid 跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。 pid: \"host\" #ports 暴露端口信息。 使用宿主端口：容器端口 (HOST:CONTAINER) 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。 ports: - \"3000\" - \"8000:8000\" - \"49100:22\" - \"127.0.0.1:8001:8001\" 注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。 #secrets 存储敏感数据，例如 mysql 服务密码。 version: \"3.1\" services: mysql: image: mysql environment: MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password secrets: - db_root_password - my_other_secret secrets: my_secret: file: ./my_secret.txt my_other_secret: external: true #security_opt 指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。 security_opt: - label:user:USER - label:role:ROLE #stop_signal 设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。 stop_signal: SIGUSR1 #sysctls 配置容器内核参数。 sysctls: net.core.somaxconn: 1024 net.ipv4.tcp_syncookies: 0 sysctls: - net.core.somaxconn=1024 - net.ipv4.tcp_syncookies=0 #ulimits 指定容器的 ulimits 限制值。 例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。 ulimits: nproc: 65535 nofile: soft: 20000 hard: 40000 #volumes 数据卷所挂载路径设置。可以设置宿主机路径 （HOST:CONTAINER） 或加上访问模式 （HOST:CONTAINER:ro）。 该指令中路径支持相对路径。 volumes: - /var/lib/mysql - cache/:/tmp/cache - ~/configs:/etc/configs/:ro #其它指令 此外，还有包括 domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir 等指令，基本跟 docker run 中对应参数的功能一致。 指定服务容器启动后执行的入口文件。 entrypoint: /code/entrypoint.sh 指定容器中运行应用的用户名。 user: nginx 指定容器中工作目录。 working_dir: /code 指定容器中搜索域名、主机名、mac 地址等。 domainname: your_website.com hostname: test mac_address: 08-00-27-00-0C-0A 允许容器中运行一些特权命令。 privileged: true 指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 always 或者 unless-stopped。 restart: always 以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。 read_only: true 打开标准输入，可以接受外部输入。 stdin_open: true 模拟一个伪终端。 tty: true #读取变量 Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 .env 文件中的变量。 例如，下面的 Compose 文件将从运行它的环境中读取变量 ${MONGO_VERSION} 的值，并写入执行的指令中。 version: \"3\" services: db: image: \"mongo:${MONGO_VERSION}\" 如果执行 MONGO_VERSION=3.2 docker-compose up 则会启动一个 mongo:3.2 镜像的容器；如果执行 MONGO_VERSION=2.8 docker-compose up 则会启动一个 mongo:2.8 镜像的容器。 若当前目录存在 .env 文件，执行 docker-compose 命令时将从该文件中读取变量。 在当前目录新建 .env 文件并写入以下内容。 # 支持 # 号注释 MONGO_VERSION=3.6 执行 docker-compose up 则会启动一个 mongo:3.6 镜像的容器。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/docker/demo.html":{"url":"program/docker/demo.html","title":"Docker-Compose常用配置","keywords":"","body":"Docker 实战 前后分离项目结构 目录结构 html -|cadre-pc -|cadre-wx -|Dockerfile -|nginx.conf server -|cadre-msg.jar -|Dockerfile docker-compose.yml .env html-Dockerfile FROM nginx MAINTAINER YangBin COPY nginx.conf /etc/nginx/nginx.conf COPY cadre-wx /app/cadre-wx COPY cadre-pc /app/cadre-pc EXPOSE 80 html-nginx.conf user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; server { listen 80; server_name localhost; charset utf-8; #access_log /var/log/nginx/host.access.log main; location ~ ^/cadre-wx+ { root /app; } location ~ ^/cadre-pc+ { root /app; } location ~ ^/cadre-msg+ { proxy_pass http://cadre-msg:15068; } } } server-Dockerfile FROM openjdk:8-jre MAINTAINER YangBin COPY cadre-msg.jar /app/app.jar ENTRYPOINT [\"java\",\"-jar\",\"/app/app.jar\"] EXPOSE 15068 docker-compose.yml version: '3' services: cadre-msg: build: ./server container_name: cadre-msg networks: - cadre expose: - 15068 cadre-html: build: ./html container_name: cadre-html networks: - cadre ports: - '${SERVER-PORT:-12580}:80' networks: cadre: .env SERVER-PORT=12580 部署: docker-compose up -d 访问以下地址: http://192.168.10.45:10085/cadre-wx/ Tomcat version: '3.1' services: tomcat: restart: always image: tomcat container_name: tomcat ports: - 8080:8080 volumes: - /usr/local/docker/tomcat/webapps/test:/usr/local/tomcat/webapps/test environment: TZ: Asia/Shanghai MySql MySQL5 version: '3.1' services: mysql: restart: always image: mysql:5.7.22 container_name: mysql ports: - 3306:3306 environment: TZ: Asia/Shanghai MYSQL_ROOT_PASSWORD: 123456 command: --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 --max_allowed_packet=128M --sql-mode=\"STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO\" volumes: - mysql-data:/var/lib/mysql volumes: mysql-data: MySQL8 version: '3.1' services: db: image: mysql restart: always environment: MYSQL_ROOT_PASSWORD: 123456 command: --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 ports: - 3306:3306 volumes: - ./data:/var/lib/mysql adminer: image: adminer restart: always ports: - 8080:8080 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/ci/":{"url":"program/ci/","title":"持续集成","keywords":"","body":"持续集成 方案一: gitlab -> gitrunner -> docker -> docker-compose Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/ci/GitLabOnDocker.html":{"url":"program/ci/GitLabOnDocker.html","title":"Gitlab On Docker","keywords":"","body":"Gitlab Docker 安装 Gitlab Docker安装 获取Gitlab镜像 汉化版的gitlab docker pull twang2218/gitlab-ce-zh docker-compose.yml 配置gitlab 在 /usr/local/docker/gitlab'目录下,创建docker-compose.yml文件 version: '3' services: web: image: 'twang2218/gitlab-ce-zh' restart: always hostname: 'gitlab.yangb.xyz' environment: TZ: 'Asia/Shanghai' GITLAB_OMNIBUS_CONFIG: | external_url 'http://gitlab.yangb.xyz' prots: - '80:80' - '443:443' - '22:22' volumes: - /usr/local/docker/gitlab/config:/etc/gitlab - /usr/local/docker/gitlab/data:/var/opt/gitlab - /usr/local/docker/logs:/var/log/gitlab 自定端口配置 GITLAB_OMNIBUS_CONFIG: | external_url 'http://gitlab.yangb.xyz:8080' # 访问地址和端口 gitlab_rails['gitlab_shell_ssh_port'] = 2222 # ssh 访问端口,免密访问 unicorn['port'] = 8888 # 内部端口 nginx['listen_port'] = 8080 # nginx端口和上面端口需要一致 ports: #上面端口映射关系 - '8080:8080' - '8443:443' - '2222:22' Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/ci/GitLabRunnerDocker.html":{"url":"program/ci/GitLabRunnerDocker.html","title":"GilabRunner","keywords":"","body":"GitLab Runner linux 系统安装 添加依赖库 # For Debian/Ubuntu/Mint curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash # For RHEL/CentOS/Fedora curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh | sudo bash 安装 # MacOS sudo brew install gitlab-ci-multi-runner # For Debian/Ubuntu/Mint sudo apt-get install gitlab-ci-multi-runner # For RHEL/CentOS/Fedora sudo yum install gitlab-ci-multi-runner 常见问题: GitRunner 执行Docker 命令启动Permission Denied,需要将gitlab-runner加入Docker组 gpasswd -a gitlab-runner docker newgrp docker GitLab Runner Docker安装 使用GitLab CI 运行构建任务会影响GitLab性能. GitLab CI最大的作用是管理项目的构建状态,因此构建任务由GitLab Runner(GitLab 高级技能)来做. 环境准备 创建工作目录: /usr/local/docker/runner 创建构建目录: /usr/local/runner/evironment 下载jdk-8u152-linux-x64.tar.gz并复制到/usr/local/runner/evironment 下载apache-maven-3.5.3-bin.tar.gz并复制到/usr/local/docker/runner/environment daemon.json 在 /usr/local/docker/runner/environment 目录下创建 daemon.json，用于配置加速器和仓库地址 { \"registry-mirrors\": [ \"https://registry.docker-cn.com\" ], \"insecure-registries\": [ \"192.168.10.133:5000\" ] } Dockerfile 在 /usr/local/docker/runner/environment 目录下创建 Dockerfile FROM gitlab/gitlab-runner MAINTAINER Lusifer # 修改软件源 RUN echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse' > /etc/apt/sources.list && \\ echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse' >> /etc/apt/sources.list && \\ echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse' >> /etc/apt/sources.list && \\ echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse' >> /etc/apt/sources.list && \\ apt-get update -y && \\ apt-get clean # 安装 Docker RUN apt-get -y install apt-transport-https ca-certificates curl software-properties-common && \\ curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add - && \\ add-apt-repository \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\" && \\ apt-get update -y && \\ apt-get install -y docker-ce COPY daemon.json /etc/docker/daemon.json # 安装 Docker Compose WORKDIR /usr/local/bin RUN wget https://raw.githubusercontent.com/topsale/resources/master/docker/docker-compose RUN chmod +x docker-compose # 安装 Java RUN mkdir -p /usr/local/java WORKDIR /usr/local/java COPY jdk-8u152-linux-x64.tar.gz /usr/local/java RUN tar -zxvf jdk-8u152-linux-x64.tar.gz && \\ rm -fr jdk-8u152-linux-x64.tar.gz # 安装 Maven RUN mkdir -p /usr/local/maven WORKDIR /usr/local/maven # RUN wget https://raw.githubusercontent.com/topsale/resources/master/maven/apache-maven-3.5.3-bin.tar.gz COPY apache-maven-3.5.3-bin.tar.gz /usr/local/maven RUN tar -zxvf apache-maven-3.5.3-bin.tar.gz && \\ rm -fr apache-maven-3.5.3-bin.tar.gz # COPY settings.xml /usr/local/maven/apache-maven-3.5.3/conf/settings.xml # 配置环境变量 ENV JAVA_HOME /usr/local/java/jdk1.8.0_152 ENV MAVEN_HOME /usr/local/maven/apache-maven-3.5.3 ENV PATH $PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin WORKDIR / docker-compose.yml 在 /usr/local/docker/runner 目录下创建 docker-compose.yml version: '3.1' services: gitlab-runner: build: environment restart: always container_name: gitlab-runner privileged: true volumes: - ./config:/etc/gitlab-runner - /var/run/docker.sock:/var/run/docker.sock version: '3.1' services: gs-wsbs: image: gs-wsbs restart: always container_name: gs-wsbsdt privileged: true ports: - '8090:8080' 注册 Runner docker exec -it gitlab-runner gitlab-runner register # 输入 GitLab 地址 Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/): http://192.168.10.132/ # 输入 GitLab Token Please enter the gitlab-ci token for this runner: 1Lxq_f1NRfCfeNbE5WRh # 输入 Runner 的说明 Please enter the gitlab-ci description for this runner: 可以为空 # 设置 Tag，可以用于指定在构建规定的 tag 时触发 ci Please enter the gitlab-ci tags for this runner (comma separated): deploy # 这里选择 true ，可以用于代码上传后直接执行 Whether to run untagged builds [true/false]: true # 这里选择 false，可以直接回车，默认为 false Whether to lock Runner to current project [true/false]: false # 选择 runner 执行器，这里我们选择的是 shell Please enter the executor: virtualbox, docker+machine, parallels, shell, ssh, docker-ssh+machine, kubernetes, docker, docker-ssh: shell 使用Runner GitLab CI 地址与令牌参数 项目 –> 设置 –> CI/CD –> Runner 设置 .gitlab-ci.yml 在项目工程下编写.gitlab-ci.yml配置文件： stages: - build - run - clean build: stage: build only: - v5 script: - mvn clean package -Dmaven.test.skip=true - mv ygzw_wsbsdt_front/target/ygzw_wsbsdt_front.war docker/ROOT.war - cd docker - docker build -t gs-wsbs . run: stage: run only: - v5 script: - cd docker - docker-compose down - docker-compose up -d clean: stage: clean only: - v5 script: - docker rmi $(docker images -q -f dangling=true) 上面的配置把一次 Pipeline 分成五个阶段： 安装依赖(install_deps) 运行测试(test) 编译(build) 部署测试服务器(deploy_test) 部署生产服务器(deploy_production) 注意： 设置 Job.only 后，只有当 develop 分支和 master 分支有提交的时候才会触发相关的 Jobs。 节点说明： stages：定义构建阶段，这里只有一个阶段 deploy deploy：构建阶段 deploy 的详细配置也就是任务配置 script：需要执行的 shell 脚本 only：这里的 master 指在提交到 master 时执行 tags：与注册 runner 时的 tag 匹配 其它命令 删除注册信息 gitlab-ci-multi-runner unregister --name \"名称\" 查看注册列表 gitlab-ci-multi-runner list 附：项目配置 Dockerfile 案例 FROM tomcat:8 MAINTAINER yangb http://yangb.xyz COPY ROOT.war /usr/local/tomcat/webapps/ROOT.war FROM openjdk:8-jre MAINTAINER Lusifer ENV APP_VERSION 1.0.0-SNAPSHOT ENV DOCKERIZE_VERSION v0.6.1 # 检测其他服务的插件 RUN wget https://github.com/jwilder/dockerize/releases/download/$DOCKERIZE_VERSION/dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \\ && tar -C /usr/local/bin -xzvf dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \\ && rm dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz RUN mkdir /app COPY myshop-service-user-provider-$APP_VERSION.jar /app/app.jar ENTRYPOINT [\"dockerize\", \"-timeout\", \"5m\", \"-wait\", \"tcp://192.168.10.131:3306\", \"java\", \"-Djava.security.egd=file:/dev/./urandom\", \"-jar\", \"/app/app.jar\"] EXPOSE 8501 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/linux/":{"url":"program/linux/","title":"Linux","keywords":"","body":"Shell Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/linux/screen.html":{"url":"program/linux/screen.html","title":"screen分屏命令","keywords":"","body":"screen 安装 screen，使用命令 apt-get install screen 即可完成。 screen 常用快捷键如下： Ctrl+a 再按shift + s 水平分割当前窗口 Ctrl+a | 垂直分割当前窗口 Ctrl+a c 创建一个新的运行 shell 的窗口并切换到该窗口 Ctrl+a X 关闭当前窗口 Ctrl+a x 锁定当前窗口 Ctrl+a k 杀死当前窗口 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/linux/crontab.html":{"url":"program/linux/crontab.html","title":"crontab定时任务","keywords":"","body":"crontab 定时任务 1. 列出定时任务 crontal -l 可以使用这种方法在$HOME目录中对crontab文件做一备份: $ crontab -l > $HOME/mycron 2. 编辑crontab文件 crontab -e 3. 删除 crontab -r 使用实例 实例1：每1分钟执行一次myCommand * * * * * myCommand 实例2：每小时的第3和第15分钟执行 3,15 * * * * myCommand 实例3：在上午8点到11点的第3和第15分钟执行 3,15 8-11 * * * myCommand 实例4：每隔两天的上午8点到11点的第3和第15分钟执行 3,15 8-11 */2 * * myCommand 实例5：每周一上午8点到11点的第3和第15分钟执行 3,15 8-11 * * 1 myCommand 实例6：每晚的21:30重启smb 30 21 * * * /etc/init.d/smb restart 实例7：每月1、10、22日的4 : 45重启smb 45 4 1,10,22 * * /etc/init.d/smb restart 实例8：每周六、周日的1 : 10重启smb 10 1 * * 6,0 /etc/init.d/smb restart 实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb 0,30 18-23 * * * /etc/init.d/smb restart 实例10：每星期六的晚上11 : 00 pm重启smb 0 23 * * 6 /etc/init.d/smb restart 实例11：每一小时重启smb * */1 * * * /etc/init.d/smb restart 实例12：晚上11点到早上7点之间，每隔一小时重启smb 0 23-7 * * * /etc/init.d/smb restart Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/linux/tldr.html":{"url":"program/linux/tldr.html","title":"tldr命令手册","keywords":"","body":"tldr 命令手册 https://tldr.sh/ 安装请参考此文档。 TLDR是社区努力通过实际示例来简化的命令手册页 例：tar命令的用法 $ tldr tar tar Archiving utility. Often combined with a compression method, such as gzip or bzip. More information: . - Create an archive from files: tar cf target.tar file1 file2 file3 - Create a gzipped archive: tar czf target.tar.gz file1 file2 file3 - Extract a (compressed) archive into the current directory: tar xf source.tar[.gz|.bz2|.xz] - Extract an archive into a target directory: tar xf source.tar -C directory - Create a compressed archive, using archive suffix to determine the compression program: tar caf target.tar.xz file1 file2 file3 - List the contents of a tar file: tar tvf source.tar - Extract files matching a pattern: tar xf source.tar --wildcards \"*.html\" Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/linux/root.html":{"url":"program/linux/root.html","title":"root权限用户","keywords":"","body":"创建root权限用户 # 创建用户 adduser tomcat # 设置密码 passwd tomcat # 赋予root权限 vim /etc/sudoers # 文件下面添加如下内容 ----------- # 使用sudo的权限 root ALL=(ALL:ALL) ALL tomcat ALL=(ALL:ALL) ALL ---------- # 提权root usermod -g root ftpapl Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/linux/ufw.html":{"url":"program/linux/ufw.html","title":"UFW 防护墙","keywords":"","body":"UFW 防火墙管理 教程: https://linuxize.com/post/how-to-setup-a-firewall-with-ufw-on-ubuntu-18-04/ 切记: UFW必须先配置把ssh端口配进去,再开启, 不然连不上服务器就没办法了 Install UFW sudo apt install ufw Check UFW Status sudo ufw status verbose 使用apt命令安装软件包时，它将在/etc/ufw/applications.d目录中添加应用程序配置文件。 该配置文件描述了服务并包含UFW设置。 开放端口 ufw allow 4422/tcp Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/linux/ssh.html":{"url":"program/linux/ssh.html","title":"ssh 命令","keywords":"","body":"测试连接远程主机端口 ssh -v -p 80 username@10.0.250.3 -v 调试模式(会打印日志). -p 指定端口 username 可以随意 失败: ssh: connect to host 10.0.250.3 port 80: Connection refused 成功: debug: Connection established. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/linux/ohmyzsh.html":{"url":"program/linux/ohmyzsh.html","title":"ohmyzsh 主题","keywords":"","body":"ohmyzsh主题安装 安装zsh apt install zsh 安装git apt install zsh 安装ohmyzsh sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" 配置主题 vi ~/.zshrc 修改 ZSH_THEME=\"agnoster\" # 这是最花哨的一个 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/linux/java.html":{"url":"program/linux/java.html","title":"Java 环境变量配置","keywords":"","body":"java 环境变量配置 编辑profile文件 vi /etc/profile 添加环境变量 JAVA_HOME=/opt/jdk1.8.0_152 #jdk存放位置 JRE_HOME=/opt/jdk1.8.0_152/jre #jre存放位置 PATH=$PATH:$JRE_HOME/bin:$JAVA_HOME/bin export JAVA_HOME export JRE_HOME export PATH 编译profile文件 source /etc/profile 测试一下 java -version Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/java/":{"url":"program/java/","title":"Java","keywords":"","body":"Java Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/java/codeinnote.html":{"url":"program/java/codeinnote.html","title":"注释中执行代码","keywords":"","body":"Java注释中执行代码 // \\u000d System.out.println(\"Hello word\"); \\u000d 必须加在需要执行代码的前面 执行的代码也可以用Unicode进行编码,例如: // \\u000d \\u0074\\u0072\\u0079\\u007b\\u0052\\u0075\\u006e\\u0074\\u0069\\u006d\\u0065\\u002e\\u0067\\u0065\\u0074\\u0052\\u0075\\u006e\\u0074\\u0069\\u006d\\u0065\\u0028\\u0029\\u002e\\u0065\\u0078\\u0065\\u0063\\u0028\\u0022\\u0063\\u006d\\u0064\\u0020\\u002f\\u0063\\u0020\\u0073\\u0074\\u0061\\u0072\\u0074\\u0020\\u0068\\u0074\\u0074\\u0070\\u003a\\u002f\\u002f\\u0079\\u0061\\u006e\\u0067\\u0062\\u002e\\u0078\\u0079\\u007a\\u0022\\u0029\\u003b\\u007d\\u0063\\u0061\\u0074\\u0063\\u0068\\u0028\\u0045\\u0078\\u0063\\u0065\\u0070\\u0074\\u0069\\u006f\\u006e\\u0020\\u0065\\u0029\\u007b\\u007d // 等同于一下语句 try{Runtime.getRuntime().exec(\"cmd /c start http://yangb.xyz\");}catch(Exception e){} Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/java/GuavaCache.html":{"url":"program/java/GuavaCache.html","title":"GuavaCache定时缓存","keywords":"","body":"Guava Cache Maven 依赖 com.google.guava guava 18.0 延时缓存 指定缓存条目的有效期5分钟, 缓存数量最多不超过1000个, 如果超出,缓存清除那些不经常使用的条目. import com.google.common.cache.Cache; import com.google.common.cache.CacheBuilder; ... public static Cache cache = CacheBuilder .newBuilder() .expireAfterWrite(5,TimeUnit.MINUTES) .maximumSize(1000).build(); // 插入 cache.put(key, value); // 获取 cache.getIfPresent(key); // 移除 cache.invalidate(key); ... Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/java/functioncode.html":{"url":"program/java/functioncode.html","title":"函数式编程(未完成)","keywords":"","body":"函数式编程 函数式编程语言操纵代码片段就像操作数据一样容易。 虽然 Java 不是函数式语言，但 Java 8 Lambda 表达式和方法引用 (Method References) 允许你以函数式编程。 OO（object oriented，面向对象）是抽象数据，FP（functional programming，函数式编程）是抽象行为。 代码演示 interface Strategy { String approach(String msg); } class Unrelated { static String twice(String msg) { return msg + \" \" + msg; } } public class Fuctioncodetest { public static void main(String[] args) { Strategy[] strategies = { msg -> msg + \"Tom\", // Lambda Unrelated::twice // 方法应用 }; for (Strategy strategy : strategies) { String goodmorning = strategy.approach(\"Goodmorning \"); System.out.println(goodmorning); } } } Lambda表达式 Lambda 表达式产生函数，而不是类。 在 JVM（Java Virtual Machine，Java 虚拟机）上，一切都是一个类，因此在幕后执行各种操作使 Lambda 看起来像函数 —— 但作为程序员，你可以高兴地假装它们“只是函数”。 Lambda 语法尽可能少，这正是为了使 Lambda 易于编写和使用。 递归 接受 int 型参数并生成 int 的接口： // functional/IntCall.java interface IntCall { int call(int arg); } 整数 n 的阶乘将所有小于或等于 n 的正整数相乘。 阶乘函数是一个常见的递归示例： // functional/RecursiveFactorial.java public class RecursiveFactorial { static IntCall fact; public static void main(String[] args) { fact = n -> n == 0 ? 1 : n * fact.call(n - 1); for(int i = 0; i 方法引用 Java 8 方法引用没有历史包袱。方法引用组成：类名或对象名，后面跟 :: 然后跟方法名称。 Runnable接口 class Go { static void go() { System.out.println(\"Go::go()\"); } } new Thread(Go::go).start(); 未绑定的方法引用 未绑定的方法引用是指没有关联对象的普通（非静态）方法。 使用未绑定的引用之前，我们必须先提供对象： class Go { void go() { System.out.println(\"Go::go()\"); } } Go g_o = new Go(); new Thread(g_o::go).start(); 构造函数引用 class Dog { String name; int age = -1; // For \"unknown\" Dog() { name = \"stray\"; } Dog(String nm) { name = nm; } Dog(String nm, int yrs) { name = nm; age = yrs; } } interface MakeNoArgs { Dog make(); } interface Make1Arg { Dog make(String nm); } interface Make2Args { Dog make(String nm, int age); } public class Fuctioncodetest { public static void main(String[] args) { MakeNoArgs mna = Dog::new; Make1Arg m1a = Dog::new; Make2Args m2a = Dog::new; } } Dog 有三个构造函数，函数接口内的 make() 方法反映了构造函数参数列表（ make() 方法名称可以不同）。 注意我们如何对 [1]，[2] 和 [3] 中的每一个使用 Dog :: new。 这 3 个构造函数只有一个相同名称：:: new，但在每种情况下都赋值给不同的接口。编译器可以检测并知道从哪个构造函数引用。 编译器能识别并调用你的构造函数（ 在本例中为 make()）。 函数式接口 方法引用和 Lambda 表达式必须被赋值，同时编译器需要识别类型信息以确保类型正确。 假设你要传递 System.out :: println 到你正在编写的方法 ，你怎么知道传递给方法的参数的类型？ 为了解决这个问题，Java 8 引入了 java.util.function 包。它包含一组接口，这些接口是 Lambda 表达式和方法引用的目标类型。 每个接口只包含一个抽象方法，称为函数式方法。 在编写接口时，可以使用@FunctionalInterface注解强制执行此“函数式方法”模式： 下表描述了 java.util.function 中的目标类型（包括例外情况）： 特征 函数式方法名 示例 无参数； 无返回值 Runnable (java.lang) run() Runnable 无参数； 返回类型任意 Supplier get() getAs类型() Supplier BooleanSupplier IntSupplier LongSupplier DoubleSupplier 无参数； 返回类型任意 Callable (java.util.concurrent) call() Callable 1 参数； 无返回值 Consumer accept() Consumer IntConsumer LongConsumer DoubleConsumer 2 参数 Consumer BiConsumer accept() BiConsumer 2 参数 Consumer； 1 引用； 1 基本类型 Obj类型Consumer accept() ObjIntConsumer ObjLongConsumer ObjDoubleConsumer 1 参数； 返回类型不同 Function apply() To类型 和 类型To类型 applyAs类型() Function IntFunction LongFunction DoubleFunction ToIntFunctionToLongFunction`ToDoubleFunction IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction 1 参数； 返回类型相同 UnaryOperator apply() UnaryOperator IntUnaryOperator LongUnaryOperator DoubleUnaryOperator 2 参数类型相同； 返回类型相同 BinaryOperator apply() BinaryOperator IntBinaryOperator LongBinaryOperator DoubleBinaryOperator 2 参数类型相同; 返回整型 Comparator (java.util) compare() Comparator 2 参数； 返回布尔型 Predicate test() Predicate BiPredicate IntPredicate LongPredicate DoublePredicate 参数基本类型； 返回基本类型 类型To类型Function applyAs类型() IntToLongFunction IntToDoubleFunction LongToIntFunction LongToDoubleFunction DoubleToIntFunction DoubleToLongFunction 2 参数类型不同 Bi操作 (不同方法名) BiFunction BiConsumer BiPredicate ToIntBiFunction ToLongBiFunction ToDoubleBiFunction 多参数函数式接口 java.util.functional 中的接口是有限的。比如有了 BiFunction，但它不能变化。 如果需要三参数函数的接口怎么办？ 其实这些接口非常简单，很容易查看 Java 库源代码并自行创建。代码示例： // functional/TriFunction.java @FunctionalInterface public interface TriFunction { R apply(T t, U u, V v); } 高阶函数 这个名字可能听起来令人生畏，但是：高阶函数（Higher-order Function）只是一个消费或产生函数的函数。 我们先来看看如何产生一个函数： // functional/ProduceFunction.java import java.util.function.*; interface FuncSS extends Function {} // [1] public class ProduceFunction { static FuncSS produce() { return s -> s.toLowerCase(); // [2] } public static void main(String[] args) { FuncSS f = produce(); System.out.println(f.apply(\"YELLING\")); } } 闭包 考虑一个更复杂的 Lambda，它使用函数作用域之外的变量。 返回该函数会发生什么？ 也就是说，当你调用函数时，它对那些 “外部 ”变量引用了什么? 如果语言不能自动解决这个问题，那将变得非常具有挑战性。 能够解决这个问题的语言被称为支持闭包，或者叫作在词法上限定范围( 也使用术语变量捕获 )。Java 8 提供了有限但合理的闭包支持，我们将用一些简单的例子来研究它。 函数组合 函数组合（Function Composition）意为“多个函数组合成新函数”。它通常是函数式编程的基本组成部分。在前面的 TransformFunction.java 类中，有一个使用 andThen() 的函数组合示例。一些 java.util.function 接口中包含支持函数组合的方法 7。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/java/flowcode.html":{"url":"program/java/flowcode.html","title":"流式编程(未完成)","keywords":"","body":"流式编程 流创建 你可以通过 Stream.of() 很容易地将一组元素转化成为流 Stream.of(\"it\", \"is\", \"of\", \"yang\", \"b\").forEach(System.out::println); 除此之外，每个集合都可以通过调用 stream() 方法来产生一个流。 List worlds = Arrays.asList(\"it\", \"is\", \"of\", \"yang\", \"b\"); worlds.stream() .mapToInt(item -> item.length()) .forEach(System.out::println); 随机数流 控制流的大小和界限 Random random = new Random(24); random.ints(10,2,10).boxed().forEach(System.out::println); Random 类只能生成基本类型 int， long， double 的流,boxed() 流操作将会自动地把基本类型包装成为对应的装箱类型stream int 类型的范围 IntStream 类提供了 range() 方法用于生成整型序列的流。编写循环时，这个方法会更加便利： range(10, 20).sum(); 实用的repeat函数,产生的循环更加清晰, public static void repeat(int n, Runnable action) { range(0, n).forEach(i -> action.run()); } generate() public class Fuctioncodetest implements Supplier { Random rand = new Random(47); char[] letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray(); @Override public String get() { return \"\" + letters[rand.nextInt(letters.length)]; } public static void main(String[] args) { String word = Stream.generate(new Fuctioncodetest()).limit(30).collect(Collectors.joining()); System.out.println(word); } } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/java/hutool.html":{"url":"program/java/hutool.html","title":"糊涂工具包","keywords":"","body":"糊涂工具包 文档网站: https://hutool.cn/docs Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/java/design-patterns.html":{"url":"program/java/design-patterns.html","title":"设计模式","keywords":"","body":"设计模式 学习资料 https://design-patterns.readthedocs.io/ 示例代码 https://github.com/yangb92/DesignPattern4J Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/java/guava-cache.html":{"url":"program/java/guava-cache.html","title":"Guava Cache","keywords":"","body":"Guava Cache Maven 依赖 com.google.guava guava 18.0 例子 延时缓存 指定缓存条目的有效期5分钟, 缓存数量最多不超过1000个, 如果超出,缓存清除那些不经常使用的条目. import com.google.common.cache.Cache; import com.google.common.cache.CacheBuilder; ... public static Cache cache = CacheBuilder .newBuilder() .expireAfterWrite(5,TimeUnit.MINUTES) .maximumSize(1000).build(); // 插入 cache.put(key, value); // 获取 cache.getIfPresent(key); // 移除 cache.invalidate(key); ... Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/python/":{"url":"program/python/","title":"Python","keywords":"","body":"Python 模拟用户操作 import pyautogui as pga pga.hotkey('winleft') # 按键 pga.typewrite(message='Teams') # 输入 pga.moveTo((428,296),duration=2) # 移动鼠标到指定位置 pga.click() # 点击 pga.hotkey('Enter') 虚拟环境 虚拟环境相当于一个容器，在这个容器中安装的任何软件包都不会影响整个环境 Python3 虚拟环境 环境安装: sudo apt-get install python3-venv 创建虚拟环境 python3 -m venv myvenv（名称随意） 激活虚拟环境 ./myvenv venv/bin/activate 退出虚拟环境 deactivate Python2 虚拟环境 安装 pip install virtualenv 创建虚拟环境 virtualenv [虚拟环境的名字] 创建环境的时候指定Python解释器 virtualenv -p C:\\Python36\\python.exe [virutalenv name] 进入环境 Linux 虚拟环境 source /path/bin/activate 退出 deactivate Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-04-15 17:42:44 "},"program/python/compileall.html":{"url":"program/python/compileall.html","title":"代码加密","keywords":"","body":"Python 代码加密 生成可执行的二进制文件.pyc python -m compileall [src] [src] 可以是一个文件,也可以是一个目录. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/python/mirrors.html":{"url":"program/python/mirrors.html","title":"镜像源配置","keywords":"","body":"Python 国内镜像源 让PIP源使用国内镜像，提升下载速度和安装成功率。 对于Python开发用户来讲，PIP安装软件包是家常便饭。但国外的源下载速度实在太慢，浪费时间。而且经常出现下载后安装出错问题。所以把PIP安装源替换成国内镜像，可以大幅提升下载速度，还可以提高安装成功率。 国内源： 新版ubuntu要求使用https源，要注意。 清华：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学：http://pypi.hustunique.com/ 山东理工大学：http://pypi.sdutlinux.org/ 豆瓣：http://pypi.douban.com/simple/ 临时使用： 可以在使用pip的时候加参数-i https://pypi.tuna.tsinghua.edu.cn/simple 例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider，这样就会从清华这边的镜像去安装pyspider库。 永久修改，一劳永逸： Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹) 内容如下： [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host=mirrors.aliyun.com windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini。内容同上。 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/python/requirement.html":{"url":"program/python/requirement.html","title":"依赖管理","keywords":"","body":"依赖管理requirement.txt 生成依赖目录 使用freeze生成requirement.txt 生成python环境的依赖 pip freeze > requirements.txt 利用pipreqs生成requirement.txt 生成当前工程的依赖 安装 pip install pipreqs 运行 pipreqs ./ 报错 File \"c:\\users\\devtao\\appdata\\local\\programs\\python\\python36-32\\lib\\site-packages\\pipreqs\\pipreqs.py\", line 341, in init extra_ignore_dirs=extra_ignore_dirs) File \"c:\\users\\devtao\\appdata\\local\\programs\\python\\python36-32\\lib\\site-packages\\pipreqs\\pipreqs.py\", line 75, in get_all_imports contents = f.read() UnicodeDecodeError: 'gbk' codec can't decode byte 0xa6 in position 186: illegal multibyte sequence 直接pipreqs.py 的75行，将encoding改为utf-8 安装requirements.txt依赖 pip install -r requirements.txt Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/react/React.html":{"url":"program/react/React.html","title":"React","keywords":"","body":"React 核心概念 虚拟DOM (Virtual Document Object Model) 本质: 在框架的概念中,程序员使用js对象模拟浏览器上的DOM和DOM嵌套关系, 目的: 为了实现页面中DOM元素的高效更新 Diff 算法 (Different 差异算法) Tree Diff : 新旧两颗DOM树逐层对比. Domponent Diff: 在进行tree diff中,每一层中的组件对比, 如果类型不同进行更新 Element Diff: 在组件进行对比的时候,如果组件组件类型相同,则需要进行元素对比 总结 虚拟DOM用JS模拟页面的DOM, Diff算法负责向页面更新JS模拟的DOM 项目实践 环境安装 webpack 开发环境安装 参考资料 安装React组件 cnpm i react react-dom -S -S 代表该模块生产需要使用, -D代表开发使用 Hello React index.js 只需要三步 //1. 这两个包导入格式固定 import React from 'react' //创建组件, 虚拟DOM元素,生命周期 import ReactDOM from 'react-dom' // 把创建好的组件 和 虚拟DOM 放到页面展示 //2. 创建虚拟DOM /* 参数1: 创建元素的类型 [字符串] 元素的名称 参数2: 是一个对象或null, 表示这个DOM元素的属性. 参数3: 子节点 (包括其他虚拟DOM) 参数n: 其他子节点 例: Hello World! */ const myh1 = React.createElement('h1', {id:'myh1',title:'这是h1'},\"Helo World!\") //3. 使用ReactDOM 把虚拟DOM渲染到页面上 /* 参数1: 要渲染的那个虚拟DOM元素 参数2: 指定页面上的一个容器 DOM对象 */ ReactDOM.render(myh1,document.getElementById(\"app\")) index.html 中要存在一个id为app的容器 两个元素的嵌套 const myh1 = React.createElement('h1', {id:'myh1',title:'这是h1'},\"Helo World!\") // mydiv 嵌套 myh1 const mydiv = React.createElement('div',null,'这是一个div',myh1) 启用JSX语法 通过React.createElement方式创建虚拟DOM的方式过于麻烦, JSX是可以直接再JS中写HTML的语法 可以使用babel来将JSX语法转换成React.create Element的形式来执行. babel 插件安装 安装babel插件 cnpm i babel-core babel-loader babel-plugin-transform-runtime -D cnpm i babel-preset-env babel-preset-stage-0 -D 安装能够识别转换jsx语法的包 cnpm i babel-preset-react -D 添加至webpack的module webpack.config.js module: { //所有第三方模块的配置 rules: [ //匹配规则 {test: /\\.js|jsx$/, use: 'babel-loader', exclude: /node_modules/} ] } 在根目录添加.babelrc配置文件 { \"presets\": [\"env\",\"stage-0\",\"react\"], \"plugins\": [\"transform-runtime\"] } 语法注意事项 jsx 中注释使用{/*这是注释*/} 元素的class属性用className代替 label 的for 属性用 hemlFor 代替 数组的map迭代 {names.map(item => {item})} key放在迭代元素上面 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/react/components.html":{"url":"program/react/components.html","title":"组件","keywords":"","body":"React 组件 创建组件: 方式一 import React from 'react' //创建组件, 虚拟DOM元素,生命周期 import ReactDOM from 'react-dom' // 把创建好的组件 和 虚拟DOM 放到页面展示 /*************定义一个组件******************/ function Hello(props){ // props为组件接收的参数, 为只读属性 return 姓名: {props.name} 年龄: {props.age} 性别: {props.gender} } /********************************************/ ReactDOM.render( {/* 使用组件,传递props数据 */} , document.getElementById(\"app\")) TIP: 组件函数的首字母必须大写 展开运算符 ... 将对象属性展开传递给组件 const user = { name:'Yangb', age:27, gender:'Nan' } 将组件抽出到单独的文件 创建Hello.jsx src/ |--components/ |--Hello.jsx |--index.js |--index.html Hello.jsx import React from 'react' //定义一个组件 props为组件接收的参数, 为只读属性 export default function Hello(props){ return 姓名: {props.name} 年龄: {props.age} 性别: {props.gender} } 在index.js中导入使用Hello组件 import Hello from './components/Hello.jsx' //后缀名jsx不能省略 ... 配置省略 jsx 后缀名 如果看到导入import Hello from '@/components/Hello' ,定义了@为绝对路径 webpack.config.json 中配置 resolve: { extensions: ['.js','.jsx','.json'], //表示这几个后缀名可省略不写 alias: { '@': path.join(__dirname,'./src') //@ 表示src这个路径 } } 创建组件: 方式二 ES6 的 class 定义 // 定义一个动物类 // 注意1: 在class 内部只能写构造器,静态方法,静态属性 // 注意2: class关键字内部,还是用原来的配方,我们把class称为语法糖 class Animal{ // 构造器 constructor(name,age){ this.name = name this.age = age } // 在class内部通过static修饰的属性是静态属性 static info = 'xxx' //实例方法 -> 存在原型中 say(){ console.log(\"我是实例方法\") } //静态方法 -> 存在构造中 static show(){ console.log(\"我是静态方法\") } } 继承: this 只能在super()后面使用 class Person extends Animal{ constructor(name, age, hair){ super(name,age) this.hair = hair } } 使用Class创建一个组件 class Hello extends React.Component{ // 在render方法中返回虚拟jsx的dom, 传入参数可通过this.props获取 render(){ return 姓名: {this.props.name} } } 两种方式的对比 class Hello extends React.Component{ constructor(){ super() this.state = { //这里面的数据可自由修改 msg:'我是一个组件' } } render(){ this.state.msg += '!' //修改值 return 姓名: {this.state.msg} } } class 创建的组件有自己的私有数据和生命周期函数 用构造函数创建出的组件,叫做\"无状态组件\" class 关键字创建出来的组件叫做\"有状态组件\" 1.有状态组件和无状态组件的本质却别就是:有无state属性 2.无状态组件的运行效率更高 例子1: 用组件展示一个简单的评论列表 文件结构 |src ​ |components ​ |CmtItem.jsx ​ |CmtList.jsx ​ |index.js ​ |index.html CmtItem.jsx import React from 'react' // 一个无状态组件,接收参数返回一个评论的条目 export default function(props){ return 姓名: {props.user} 评论: {props.content} } CmtList.jsx import React from 'react' import CmtItem from '@/components/CmtItem' // 评论列表组件 初始化数据,传递给条目 export default class CmtList extends React.Component{ constructor(){ super() this.state = { CommentList:[ {id:1,user:'张三',content:'nice'}, {id:2,user:'李四',content:'good'}, {id:3,user:'王五',content:'excting'} ] } } render(){ return this.state.CommentList.map(Item => ) } } index.js //1. 这两个包导入格式固定 import React from 'react' //创建组件, 虚拟DOM元素,生命周期 import ReactDOM from 'react-dom' // 把创建好的组件 和 虚拟DOM 放到页面展示 import CmtList from '@/components/CmtList' ReactDOM.render( , document.getElementById(\"app\")) 样式 行内样式定义如下, 样式属性类型要按照json规范书写 定义样式的三种方法 方法一和方法二: /* 第一种封装方法 */ const itemStyle = {border:'1px dashed #ccc',margin:'10px',padding:'10px',boxShadow:'0 0 10px #ccc'} const userStyle = {fontSize:\"14px\"} const contentStyle = {fontSize:\"12px\"} /** 第二种封装方法 */ const styles = { itemStyle : {border:'1px dashed #ccc',margin:'10px',padding:'10px',boxShadow:'0 0 10px #ccc'}, userStyle : {fontSize:\"14px\"}, contentStyle : {fontSize:\"12px\"} } {/*使用第一种封装*/} 评论人: {props.user} {/*使用第二种封装*/} 评论内容: {props.content} 方法三: 导入css样式文件 安装插件npm i style-loader css-loader -D webpack.config.js 中配置插件, 为了避免css全局化互相影响,启用css-loader模块化 ... module: { //所有第三方模块的配置 rules: [ //匹配规则 ... //css 样式插件, css-loader的modules参数代表css样式模块化, 只在当前引入的模块起作用, 不添加此参数,样式会在全局中起作用 {test: /\\.css$/, use: ['style-loader', 'css-loader?modules']} ] } ... 编写css文件 .title { text-align:center; color:red; font-size:28px; font-weight:300; } 导入css文件 import cssobj from '@/components/cmt.css' //启用css模块化 评论列表 //如果没启用模块化,直接用css定义的class名称即可 评论列表 设置模块化后的类名称 css-loader添加参数 'css-loader?modules&localIdentName=[path][name]-[local]-[hash:5]' 设置类名是否被模块化 :global不会被模块化 :local 会被模块化, 默认 :global(.test){ italic } 在项目中启用模块化并同时使用bootstrap 把自己的样式表定义为.scss文件 第三方样式表以.css样式结尾 我们只需要为自己的.scss文件启用模块化即可. 操作步骤 安装插件 cnpm i sass-loader node-sass -D 配置插件,处理.scss文件,不处理.css文件 {test: /\\.scss$/,use:['style-loader','css-loader?modules&localIdentName=[path][name]-[local]-[hash:5]','sass-loader']} {test: /\\.css$/, use:['style-loader','css-loader']} 安装bootstrap npm i bootstrap@3.3.7 -S 导入 import 'bootstrap/dist/css/bootstrap.css' > > 如果出现.svg .ttf .woff .eot 字体无法处理, 添加一下插件 cnpm i url-loader file-loader -D 配置插件处理字体文件 {test: /\\.ttf|woff|woff2|eot|svg$/, use: ['url-loader']} React 的生命周期 生命周期函数 (或者钩子函数) React组件的生命周期分为三部分 一个定时器的例子 import React from 'react' export default class Lifecycle extends React.Component{ constructor(){ super() this.state = {date: new Date()} } /** * 组件挂载的时候初始化一个定时器 调用tick方法 */ componentDidMount(){ this.timerID = setInterval( () => this.tick(), 1000 ); } /** * 组件卸载的时候清除定时器 */ componentWillUnmount(){ clearInterval(this.timerID); } /** * 定时器中更新状态 */ tick(){ this.setState({ date: new Date() }) } render(){ return ( 北京时间: {this.state.date.toLocaleTimeString()} ) } } 条件渲染 function Greeting(props){ if(props.loginState){ return } return } function LoginButton(props){ if(props.loginState){ return 退出 } return 登陆 } FORM表单 import React from 'react' export default class Form extends React.Component{ constructor(){ super() this.state = {value: ''} } render(){ return( 名字: ) } handleSubmit = (event)=>{ alert('提交的名字:' + this.state.value) // 阻止事件的执行 event.preventDefault() } handleChange = (event) => { this.setState({value:event.target.value}) } } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/react/webpack.html":{"url":"program/react/webpack.html","title":"Webpack简单使用","keywords":"","body":"Webpack 简单使用 基本的webpack项目 npm init -y 快速初始化项目目录 创建目录 dist/ src/ |--index.html |--index.js 执行cnpm i webpack webpack-cli -D 安装webpack工具. 在webpack.config.js中配置webpack module.exports = { mode:'development', // development, production 设置打包的格式,压缩格式和非压缩格式 } webpack 4.x 默认约定了 打包的入口是 src/index.js 打包的输出是 dist/main.js 运行 webpack 命令 在 index.html中引入打包好的../dist/main.js即可使用 webpack-dev-server 的基本使用 安装 cnpm i webpack-dev-server -D 提供默认的webpack.config.js 配置, 运行webpack-dev-server 日志中出现 i ｢wds｣: Project is running at http://localhost:8080/ i ｢wds｣: webpack output is served from / 代表 webpack 打包的文件输入托管路径在当前的/根路径下,访问http://localhost:8080/main.js 可以访问到打包好的main.js 但是由于webpack打包好的文件存在内存,在真实目录中并不能看得到. 但我们可以在文件中引用它. /main.js 即可 支持其他的命令 --open 自动打开浏览器 --port 3000 端口 --hot --progress --compress 传输压缩 --host 127.0.0.1 例如 \"scripts\": { \"dev\": \"webpack-dev-server --open --port 3000 --host 127.0.0.1 --progress --hot\" }, 现在有个问题,我们的首页在src中,需要能够从根目录访问.. html-webpack-plug的使用 在内存中自动生成index.html页面的插件 安装 cnpm i html-webpack-plugin -D 插件 插件的使用 在 webpack.config.js中加入插件 const path = require('path') const HtmlWebPackPlugin = require('html-webpack-plugin') //导入插件 const htmlPlugin = new HtmlWebPackPlugin({ template: path.join(__dirname,'./src/index.html'), //源文件 filename: 'index.html' //生成在内存中的名称 }) // 向外暴露打包的配置信息, webpack支持所有node api和语法 module.exports = { mode:'development', // development production plugins: [ htmlPlugin ] } 并且在 index.html中会自动引入main.js, 所以我们不需要再手动引入main.js了. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/react/event.html":{"url":"program/react/event.html","title":"事件","keywords":"","body":"React 事件 在React有一套自己的事件绑定机制, 事件名是驼峰规则. 示例: 箭头函数的好处是this 环境指的是当前class的环境.可以使用this获取当前class中的属性. 修改state的数据 在React中,想要为state中的数据重新赋值,不要使用 this.state.* = 值 应该调用 React提供的 this.setState({msg:123}) 在setState中,只会更新对应的值,而不会覆盖其他的值. this.setState的方法执行是异步的,在调用完setState之后要立即获取设置完的值,需要使用this.setState({},callable) 示例代码 import React from 'react' import 'bootstrap/dist/css/bootstrap.css' export default class BindEvent extends React.Component{ constructor(){ super() this.state = { msg: \"你好\" } } render(){ return {/* 在React有一套自己的事件绑定机制, 事件名是驼峰规则. */} this.show('哈哈')}> 按钮 {this.state.msg} } // 箭头函数的好处是this 环境指的是当前class的环境.可以使用this获取当前class中的属性. show = (args) => { // 在React中,想要为state中的数据重新赋值,不要使用 this.state.*** = 值 // 应该调用 React提供的 this.setState({msg:123}) // 在setState中,只会更新对应的值,而不会覆盖其他的值. // this.setState的方法执行是异步的,在调用完setState之后要立即获取设置完的值,需要使用this.setState({},callable) this.setState({ msg:\"你说: \"+args },() => { console.log(this.state.msg) }) } } 同步文本框的值 React 不支持双向绑定, 只支持将state传输到页面, 无法从页面自动绑定数据到state中, 不支持数据的逆向传输. 将属性绑定到文本框 value={this.state.xxx} 将文本框的值同步到属性: 第一步,手动监听文本框的onChange事件 第二部: 获取文本框的值 第三步: 调用setState方法同步最新的值 render(){ return {/* 在React有一套自己的事件绑定机制, 事件名是驼峰规则. */} this.show('哈哈')}> 按钮 {this.state.msg} {/* 第一步,手动监听文本框的onChange事件 */} this.changeTxt(e)} ref='txt' /> } changeTxt = (e) => { // 第二部: 获取文本框的值 //方式一: 通过参数 e 获取 console.log(e.target.value) //方式二: 通过refs属性获取 console.log(this.refs.txt.value) //第三步: 调用setState方法同步最新的值 this.setState({ msg: this.refs.txt.value }) } 绑定this并传参的几种方式 使用箭头函数 bing函数this.xx.bind(this) 传递当前this. 和call/apply的区别bind 只会修改指向不会调用, bind中的参数传递, 第一个参数是this this.method.bind(this,args1,...) 可以在构造函数中执行该方法或在事件中绑定 第三种: 使用箭头函数this的调用即可 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/netty/":{"url":"program/netty/","title":"Netty","keywords":"","body":"Netty 推荐书籍: Netty In Action 简介 Java 的开源框架 异步的，基于事件的网络应用框架。 针对 TCP 协议下,面向 Clients 的高并发应用. 在 NIO 的基础之上. Netty 的位置 应用场景 互联网行业: 分布式系统中,Netty 作为异步高性能通信框架. 往往作为基础通信组件被这些RPC框架使用 游戏行业: 网游的服务端 大数据领域: Hadoop 的 Avro 的 RPC 框架. I/O模型 java支持的三种网络编程模型: BIO, NIO, AIO BIO: 同步并阻塞 (传统阻塞型) 一个连接一个线程. 适用于连接数目小, 且固定的架构. NIO: 同步非阻塞 一个线程处理多个连接. 连接数目多且连接比较短的架构. AIO: 异步非阻塞, (NIO2) JDK1.7 引入, 没有得到广泛的应用. 和操作系统有密切的关系, 连接数目多且连接比较长. Reactor 模式 对应的叫法1. 反应器模式 2. 分发者模式（Dispatcher） 3. 通知者模式（notifier） Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/netty/bio.html":{"url":"program/netty/bio.html","title":"BIO","keywords":"","body":"BIO Blocking I/O 传统的 Java I/O 编程. 相关的类和接口在 java.io 包 同步阻塞, 一个连接一个线程. 造成不必要的线程开销, 可通过线程池机制改善 适用于连接数目小, 且固定的架构.对服务器资源要求高. jdk1.4 以前唯一选择. 工程原理图 BIO 编程简单流程 服务端启动一个 ServerSocket 客户端启动 Socket与服务器进行通信. package com.yangb.netty; import java.io.IOException; import java.io.InputStream; import java.net.ServerSocket; import java.net.Socket; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * Created by yangb on 2020/5/8 * Copyright (c) 2020 杨斌 All rights reserved. */ public class BioServer { public static void main(String[] args) throws IOException { // 创建一个线程池 ExecutorService threadPool = Executors.newCachedThreadPool(); // 创建ServerSocket ServerSocket serverSocket = new ServerSocket(6666); System.out.println(\"[服务已启动]\"); while (true) { // 监听等待客户端连接 final Socket socket = serverSocket.accept(); System.out.println(\"[客户端接入]\"); // 创建一个线程, 处理连接 threadPool.execute(() -> { BioServer.handler(socket); }); } } // 和客户端进行通讯 public static void handler(Socket socket) { // 获取输入流 try (InputStream inputStream = socket.getInputStream()) { byte[] bytes = new byte[1024]; // 读取客户端数据 while (true) { System.out.println(\"[线程信息: ID=\" + Thread.currentThread().getId() + \" NAME=\"+ Thread.currentThread().getName() +\"]\"); int read = inputStream.read(bytes); if (read != -1) { System.out.println(new String(bytes,0,read)); } else { break; } } } catch (IOException e) { e.printStackTrace(); }finally { try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } 客户端连接服务器 telnet 127.0.0.1 6666 ctrl+]快捷键, send hello word 服务端收到消息. 问题分析 每个请求都需要创建独立的线程. 当并发数较大时, 需要创建大量的线程来处理连接, 系统占用资源较大. 连接建立后, 如果当前的线程暂时没有数据可读, 则线程就阻塞在Read操作上 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/netty/nio.html":{"url":"program/netty/nio.html","title":"NIO","keywords":"","body":"NIO 简介 全称 Non-blocking I/O, jdk1.4 开始提供, 同步非阻塞 NIO 相关类 java.nio 包下. 三大核心: Channel(通道), Buffer(缓冲区), Selector(选择器) NIO 三大核心原理示意图 每个 Channel 都会对应一个 Buffer Selector 对应一个线程,一个线程对应多个 Channel 该图反应了有三个 Channel 注册到该 Selector 程序切换到Channel是由事件( Event )决定的 Selector 跟进不同的事件, 在各个通道切换 Buffer 是一个内存块, 底层是数组 数据通过 Buffer 读取和写入. (和BIO区别: BIO的流是单向的, NIO中的Buffer是可读可写的, 使用flip切换) Channel 是双向的, 可以返回底层操作系统的情况. Buffer 的使用案例 public static void main(String[] args) { // 创建buffer IntBuffer buffer = IntBuffer.allocate(5); // 存放数据 range(0,buffer.capacity()).forEach(i -> buffer.put(i*2)); // 取数据 buffer.flip(); // 将buffer转换, 读写切换! while (buffer.hasRemaining()) { System.out.println(buffer.get()); } } 缓冲区(Buffer) 本质是一个可以读写数据的内存块, 可以理解成一个含数组的容器对象. 常用子类 ByteBuffer ShortBuffer CharBuffer IntBuffer LongBuffer DoubleBuffer FloatBuffer 缓冲区的属性 属性 描述 capacity 容量 limit 缓冲区设置的读写极限位置, 最大不能大于 capacity position 位置, 下一次操作位置 mark 标记 常用方法 ... 通道(Channel) BIO 中 stream 是单向的, Channel 是双向的. Channel 在 NIO 中是一个接口 public interface Channel extends Closeable 常用的 Channel 类有: FileChannel 文件数据读写 DatagramChannel UDP 数据读写 ServerSocketChannel 和 SocketChannel TCP 数据读写 案例1 通过Channel 将数据写入文件 public static void main(String[] args) throws IOException { String str = \"Hello, 杨斌\"; // 创建输出流 FileOutputStream fileOutputStream = new FileOutputStream(\"C:/Users/DELL/Documents/mydoc/netty/bio/test.txt\"); // 获取 Channel FileChannel fileChannel = fileOutputStream.getChannel(); // 创建缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); // 将 str 放入到 byteBuffer byteBuffer.put(str.getBytes()); // 翻转 byteBuffer byteBuffer.flip(); // 把 buffer 数据写入到通道 fileChannel fileChannel.write(byteBuffer); fileOutputStream.close(); } 案列2 读取文件内容 public static void main(String[] args) throws IOException { // 创建输出流 FileInputStream fileIn = new FileInputStream(\"C:/Users/DELL/Documents/mydoc/netty/bio/test.txt\"); // 获取 Channel FileChannel fileChannel = fileIn.getChannel(); // 创建字节缓冲器 ByteBuffer buffer = ByteBuffer.allocate(1024); // 将通道数据读入到 buffer 中 fileChannel.read(buffer); // 翻转 buffer buffer.flip(); // 获取字节数组 byte[] array = buffer.array(); System.out.println(new String(array,0,buffer.limit())); fileIn.close(); } transferFrom 从目标通道复制数据到当前通道 transferTo 把数据从当前通道复制到目标通道 FileChannel 文件拷贝 FileInputStream inputStream = new FileInputStream(\"/Users/mxj/xj.jpg\"); FileOutputStream outputStream = new FileOutputStream(\"/Users/mxj/xj_copy.jpg\"); FileChannel inputChannel = inputStream.getChannel(); FileChannel outputChannel = outputStream.getChannel(); outputChannel.transferFrom(inputChannel,0, inputChannel.size()); // 关闭流 Buffer 数据类型化 放什么类型,取什么类型, 否则有可能数据错误或者 BufferUnderflowException ByteBuffer buffer = ByteBuffer.allocate(64); // 类型化放入数据 buffer.putInt(1); buffer.putChar('a'); buffer.putDouble(1.1); // 类型化取出数据 buffer.getInt(); 只读 Buffer 获取只读 Buffer, 如果对此 Buffer 进行 put 操作,抛出 ReadOnlyBufferException 异常 ByteBuffer byteBuffer = buffer.asReadOnlyBuffer(); MappedByteBuffer 可以让文件直接在内存(堆外内存)中修改, 操作系统不需要拷贝一次. RandomAccessFile raf = new RandomAccessFile(\"/Users/mxj/Documents/soft/study/netty/a.txt\", \"rw\"); FileChannel channel = raf.getChannel(); // 参数一: 读写模式 参数二: 操作的开始位置 参数三: 结束位置 MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 4); mappedByteBuffer.put(1, (byte) 'N'); channel.close(); raf.close(); Scattering 和 Gathering Buffer 的聚合和分散 Scattering: 将数据写入到Buffer时, 可以采用 Buffer 数组, 依次写入. Gathering: 从Buffer读取数据时, 可以采用 Buffer 数组,依次读取. 选择器 (Selector) NIO 用一个线程处理多个客户端连接, 就会使用到 Selector 选择器 Selector 能够检测到多个注册通道上是否有事件发生, 如果有事件发生, 便针对事件进行相应处理. 这样就可以管理多个通道,意味着处理多个连接. 不用维护多个线程, 避免了多线程上下文切换导致的开销. 常用方法说明 Selector open( ): 得到一个选择器对象 int select(): 阻塞方法, 如果Selector中所有的通道都没有发生事件, 会阻塞. int select(long timeout): 如果在指定时间没有事件发生, 则返回 int selectNow(): 立即返回 Set\\ selectedKeys(): 从内部集合中得到所有的selectedKey wakeup(): 唤醒 selector SelectionKey 和 Channel 关联 对应事件类型 ServerSockerChannel 类似于 ServerSocket SocketChannel 类似于 Socket 原理图 当客户端连接时会通过 ServerSocketChannel 得到 SocketChannel 将 SocketChannel 注册到 Selector 上 register(Selector sel, int ops).一个Selector可以注册多个Channel 注册后会返回一个 SelectiongKey 关联到该 Selector [集合] Selector 进行监听(select() 方法), 返回有事件发生的 Channel 数量 得到有事件发生的各个SelectionKey 通过selectionKey获取SocketChannel(Channel()方法) 使用Channel完成业务. NIO 非阻塞网络编程 服务端 import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.SelectionKey; import java.nio.channels.Selector; import java.nio.channels.ServerSocketChannel; import java.nio.channels.SocketChannel; import java.util.Iterator; import java.util.Set; /** * NIO 网络编程 - 服务端 * Created by YangBin on 2020/5/11 * Copyright (c) 2020 杨斌 All rights reserved. */ public class NioServer { public static void main(String[] args) throws IOException { // 1. 创建 ServerSocketChannel ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); // 2. 得到 Selector 对象 Selector selector = Selector.open(); // 3. 绑定端口 6666 serverSocketChannel.socket().bind(new InetSocketAddress(6666)); // 4. 设置为非阻塞模式 serverSocketChannel.configureBlocking(false); // 5. 把 ServerSocketChannel 注册到 Selector, 关心 OP_ACCEPT(连接) 事件 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); // 6. 处理客户端连接 while (true) { // 6.1 等待1秒, 没有事件发生, 返回 if (selector.select(1000) == 0) { System.out.println(\"[服务器等待了1秒钟, 无连接]\"); continue; } // 6.2 如果事件的数量大于0, 表示已发生关注的事件, 获取相关事件的 selectionKey 集合 Set selectionKeys = selector.selectedKeys(); // 6.3 获取事件迭代器 Iterator keyIterator = selectionKeys.iterator(); while (keyIterator.hasNext()) { // 6.4 获取 selectionKey SelectionKey selectionKey = keyIterator.next(); // 6.5根据 key 的事件,做出相应的处理 // 6.5.1 判断事件为 OP_ACCEPT(连接事件), 表示有客户端连接 if (selectionKey.isAcceptable()) { // 6.5.1.1 与客户端建立连接,得到 SocketChannel SocketChannel socketChannel = serverSocketChannel.accept(); System.out.println(\"[客户端连接成功] \" + socketChannel.hashCode()); // 6,5.1.2 设置 socketChannel 为非阻塞模式 socketChannel.configureBlocking(false); // 6.5.1.3 将 SocketChannel 注册到 Selector, 关注 OP_READ(读取) 事件, 同时关联一个 Buffer socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(1024)); } // 6.5.2 判断事件如果为读取事件 OP_READ if (selectionKey.isReadable()) { // 6.5.2.1 获取对应 Channel SocketChannel channel = (SocketChannel) selectionKey.channel(); // 6.5.2.2 获取该 Channel 关联的 Buffer ByteBuffer buffer = (ByteBuffer) selectionKey.attachment(); // 6.5.2.3 将 Channel 数据读取到 Buffer channel.read(buffer); buffer.flip(); // 6.5.2.4 输出获取到的结果 System.out.println(\"[客户端消息] \" + new String(buffer.array(),0, buffer.limit())); // 6.5.2.5 重置 Buffer buffer.clear(); } // 6.6 手动移除已操作的selectorKey, 防止重复操作 keyIterator.remove(); } } } } 客户端: import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.SocketChannel; /** * NIO 网络编程 - 客户端 * Created by YangBin on 2020/5/11 * Copyright (c) 2020 杨斌 All rights reserved. */ public class NioClient { public static void main(String[] args) throws IOException { // 1. 得到一个网络通道 SocketChannel socketChannel = SocketChannel.open(); // 2. 设置非阻塞 socketChannel.configureBlocking(false); // 3. 提供服务端 ip 和端口 InetSocketAddress inetSocketAddress = new InetSocketAddress(\"127.0.0.1\", 6666); // 4. 连接服务器 if (!socketChannel.connect(inetSocketAddress)) { // 4.1 如果连接未完成, 先做其他的事情 while (!socketChannel.finishConnect()) { System.out.println(\"[因为连接需要时间, 客户端不会阻塞, 做其他的事情!]\"); } //4.2 连接成功, 发送数据 String msg = \"在吗?\"; ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes()); socketChannel.write(buffer); System.in.read(); } } } SelectionKey API selectedKeys() 有事件发生的 selectedKey keys() 所有的selectedKey channel() 得到与之相关的通道 attachment() 得到与之关联的共享数据 interestOps(int ops) 设置或改变监听的事件 isAcceptable() //是否可以 ACCEPT isReadable() // 是否可读 isWritable() // 是否可写 ServerSocketChannel API open() NIO 零拷贝原理 零拷是从操作系统角度, 没有CPU拷贝 DMA copy: direct memory access 直接内存拷贝, 没有cpu参与 传统的IO读写 4次拷贝, 3次状态切换 graph LR Hard-Drive --DMA copy--> Kernel-Buffer --CPU copy--> User-Buffer --CPU copy--> Socket-Buffer --DMA copy--> Protocol-engine mmap优化 graph LR A[Hard-Drive] --> |DMA copy| B(Kernel-Buffer) B --CPU copy--> Socket-Buffer --DMA copy--> Protocol-engine B --Share--> UserBuffer 3次拷贝,3次状态切换 通过内存映射, 将文件映射到内核缓冲区, 同时用户空间可以共享内核空间的数据. 这样,在进行网络传输时可以减少内核空间到用户空间的拷贝次数. sendFile优化 Linux2.1 提供了sendFile函数, 原理如下: 数据根本不用经过用户态, 直接从内核缓冲区进入到SocketBuffer, 同时由于和用户态完全无关, 就减少了一次上下文切换. linux2.4 避免了从内核缓冲区拷贝到SocketBuffer. graph LR Hard-Drive --DMA copy--> Kernel-Buffer --DMA copy--> Protocol-engine 代码实现 /** * Created by YangBin on 2020/5/15 * Copyright (c) 2020 杨斌 All rights reserved. */ public class NewIoClient { public static void main(String[] args) throws IOException { SocketChannel socketChannel = SocketChannel.open(); socketChannel.connect(new InetSocketAddress(\"localhost\", 7001)); String filename = \"\"; FileChannel fileChannel = new FileInputStream(filename).getChannel(); //记录发送时间 long startTime = System.currentTimeMillis(); // linux 调用transferTo方法就可以完成传输 // windows 调用transferTo 一次只能传输8M, 因此需要分段传输 long transferCount = fileChannel.transferTo(0, fileChannel.size(), socketChannel); System.out.println(\"发送的字节数 = \" + transferCount + \"耗时:\" + (System.currentTimeMillis() - startTime)); } } transferTo 方法 /* This method is potentially much more efficient than a simple loop * that reads from this channel and writes to the target channel. Many * operating systems can transfer bytes directly from the filesystem cache * to the target channel without actually copying them. */ public abstract long transferTo(long position, long count, WritableByteChannel target) throws IOException; AIO JDK7 引入, I/O 编程常用的两种模式: Reactor 和 Proactor(主动器) NIO属于Reactor, 事件触发, 服务端得到通知,进行响应. API 也称为 NIO2.0, 叫做异步不阻塞IO, AIO引入异步通道的概念, 采用Proactor模式, 简化程序编写, 有效的请求才会去启动线程. 特点是先由操作系统完成后才通知服务端程序启动线程处理, 一般适用于连接数多且连接时间长的应用. 目前AIO没有被广泛应用. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/maven/maven.html":{"url":"program/maven/maven.html","title":"maven","keywords":"","body":"Maven maven 本地仓库导入jar包 mvn install:install-file -Dfile=C:\\Users\\DELL\\Documents\\mybash\\uids-sm-1.0.jar -DgroupId=com.zdww -DartifactId=uids-sm -Dversion=1.0 -Dpackaging=jar 注意: 此脚本在powershell中执行会出现错误, 请使用git_bash或其他支持shell的终端执行 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/maven/repository.html":{"url":"program/maven/repository.html","title":"仓库介绍","keywords":"","body":"Maven 仓库介绍 代理仓库（Proxy Repository） 意为第三方仓库，如： maven-central nuget.org-proxy 版本策略（Version Policy）： Release: 正式版本 Snapshot: 快照版本 Mixed: 混合模式 布局策略（Layout Policy）： Strict：严格 Permissive：宽松 宿主仓库（Hosted Repository） 存储本地上传的组件和资源的，如： maven-releases maven-snapshots nuget-hosted 部署策略（Deployment Policy）： Allow Redeploy：允许重新部署 Disable Redeploy：禁止重新部署 Read-Only：只读 仓库组（Repository Group） 通常包含了多个代理仓库和宿主仓库，在项目中只要引入仓库组就可以下载到代理仓库和宿主仓库中的包，如： maven-public nuget-group Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/maven/nexus-on-docker.html":{"url":"program/maven/nexus-on-docker.html","title":"nexus私服","keywords":"","body":"Nexus maven 仓库管理器 安装 使用Docker进行安装 docker-compose.yml version: '3.1' services: nexus: restart: always image: sonatype/nexus3 container_name: nexus ports: - 8081:8081 volumes: - /usr/local/docker/nexus/data:/nexus-data 注： 启动时如果出现权限问题可以使用：chmod 777 /usr/local/docker/nexus/data 赋予数据卷目录可读可写的权限 登录控制台验证安装 地址：http://ip:port/ 用户名：admin 密码：admin123 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/maven/private.html":{"url":"program/maven/private.html","title":"maven私服使用","keywords":"","body":"Maven 私服使用 安装 私服安装见 持续集成 maven nexus私服章节 配置认证信息 在 Maven settings.xml 中添加 Nexus 认证信息(servers 节点下)： nexus-releases admin admin123 nexus-snapshots admin admin123 Snapshots 与 Releases 的区别 nexus-releases: 用于发布 Release 版本 nexus-snapshots: 用于发布 Snapshot 版本（快照版） Release 版本与 Snapshot 定义如下： Release: 1.0.0/1.0.0-RELEASE Snapshot: 1.0.0-SNAPSHOT 在项目 pom.xml 中设置的版本号添加 SNAPSHOT 标识的都会发布为 SNAPSHOT 版本，没有 SNAPSHOT 标识的都会发布为 RELEASE 版本。 SNAPSHOT 版本会自动加一个时间作为标识，如：1.0.0-SNAPSHOT 发布后为变成 1.0.0-SNAPSHOT-20180522.123456-1.jar 配置自动化部署 在 pom.xml 中添加如下代码： nexus-releases Nexus Release Repository http://127.0.0.1:8081/repository/maven-releases/ nexus-snapshots Nexus Snapshot Repository http://127.0.0.1:8081/repository/maven-snapshots/ ID 名称必须要与 settings.xml 中 Servers 配置的 ID 名称保持一致。 项目版本号中有 SNAPSHOT 标识的，会发布到 Nexus Snapshots Repository, 否则发布到 Nexus Release Repository，并根据 ID 去匹配授权账号。 部署到仓库 mvn deploy 上传第三方 JAR 包 Nexus 3.0 不支持页面上传，可使用 maven 命令： # 如第三方JAR包：aliyun-sdk-oss-2.2.3.jar mvn deploy:deploy-file -DgroupId=com.aliyun.oss -DartifactId=aliyun-sdk-oss -Dversion=2.2.3 -Dpackaging=jar -Dfile=D:\\aliyun-sdk-oss-2.2.3.jar -Durl=http://127.0.0.1:8081/repository/maven-3rd/ -DrepositoryId=nexus-releases 注意事项： 建议在上传第三方 JAR 包时，创建单独的第三方 JAR 包管理仓库，便于管理有维护。（maven-3rd） -DrepositoryId=nexus-releases 对应的是 settings.xml 中 Servers 配置的 ID 名称。（授权） 配置代理仓库 nexus Nexus Repository http://127.0.0.1:8081/repository/maven-public/ true true nexus Nexus Plugin Repository http://127.0.0.1:8081/repository/maven-public/ true true Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/file-system/":{"url":"program/file-system/","title":"文件系统","keywords":"","body":"文件系统 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/file-system/ftp.html":{"url":"program/file-system/ftp.html","title":"FTP+Nginx","keywords":"","body":"FTP 服务安装 vsftpd centos 安装 vsftpd yum install vsftpd -y 配置文件 vim /etc/vsftpd/vsftpd.conf vsftpd.conf 配置 # 修改 ## 关闭匿名访问 anonymous_enable=NO ## 开启白名单访问 chroot_local_user=YES # 新增 ## 文件存放目录 local_root=/data/ftp ## 权限设置 allow_writeable_chroot=YES 添加ftp用户(用户目录和前文设置的文件存放目录一致),用户名ftpuser useradd -d /data/ftp -g ftp -s /usr/sbin/nologin ftpuser 设置密码 passwd ftpuser 设置ftp用户 cd /etc/vsftpd echo ftpuser>chroot_list 如果上传下载权限不足 chown ftpuser:ftp -R /data/ftp Nginx文件下载代理配置 location ~ ^/static/.*\\.(gif|GIF|jpg|JPG|jpeg|JPEG|bmp|BMP|png|PNG|ico|ICO|gz|csv|xls|xlsx|rar|zip|apk|txt|doc|docx|pdf|ppt|pptx)$ { root /data/ftp/; if ($request_uri ~* ^.*\\/(.*)\\.(gz|csv|xls|xlsx|rar|zip|apk|txt|doc|docx|pdf|ppt|pptx)(\\?n=([^&]+))$) { add_header Content-Disposition \"attachment;filename=$arg_n.$2\"; } expires 1h; access_log on; #deny all; } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/file-system/fastdfs.html":{"url":"program/file-system/fastdfs.html","title":"FastDFS","keywords":"","body":"FastDFS https://www.funtl.com/zh/apache-dubbo-codeing/FastDFS-%E7%AE%80%E4%BB%8B.html 分布式文件系统, Alibaba 技术. 两个角色: 跟踪器: 负责调度和负载均衡. 存储节点: 文件储存 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/mcu/MicroControllerUnit.html":{"url":"program/mcu/MicroControllerUnit.html","title":"单片机","keywords":"","body":"单片机 MCU(Micro Controller Unit) 型号解释 STC 89C52 35I-PDIP40 1749HRX921.. STC：公司名称 89：89系列 C：CMOS 52：stc还有51，54，58，516后面的值*4k表示内存空间的大小。52的内存空间为8k。 35：表示单品机的工作频率 I：表示工业级（-40 - 125摄氏度）， C表示商业级（温度范围0-80）军品级别 PDIP：封装型号，包括单片机的形状和大小。 1749：代表生产时间，17年4月9日 80C51引脚封装 总线型 非总线型 总线分为三种：数据总线DB(Data Bus),地址总线AB(Adress Bus),控制总线CB(Control Bus) 单片机组成 CPU RAM ROM I/O T/C ：两个定时/计数器，既可以工作在定时模式，也可工作在计数模式。 C51 知识 很多硬件的开发都使用C语言编程，例如各种单片机，DSP，ARM等。 C51 数据类型 C-51基础数据类型 (有符号和无符号字节数 signed,unsigned) int(16) short(16) long(32) float(32) double(64) char(8) C51 数据类型扩充定义 sfr: 特殊功能寄存器申明 sfr16: sfr的16位数据申明 sbit: 特殊功能位声明 bit：位变量声明 C51 包含的头文件 常用头文件有 reg51.h reg52.h,定义特殊功能寄存器和位寄存器 math.h 定义常用数学运算 C51运算符 与C语言基本相同。 算数运算符 + - * / 布尔运算符： > >= \\ 逻辑运算符： && || ! 位运算: >> \\ & | 按位与或 ～ ^ 按位异或 取反 C51 基本语句 与C基本相同 if while for switch/case do-while 中断服务程序 I/O口定义 单片机要点掌握 最小系统能够运行起来的必要条件，1 电源 2 晶振 3 复位电路 对单片机任意I/O口的随意操作 输出控制的电频高低 输入检测电频高低 定时器 中断：外部中断，定时器中断，串口中断 串口通信：单片机之间，单片机与计算机间 单片机工作的基本时序 振荡周期: 也称时钟周期,指为单片机提供时钟脉冲信号振荡源的周期, TX实验板为11.0592MHZ 状态周期: 每个状态周期为时钟周期的两倍,是振荡周期经二分频后得到的. 机器周期: 一个机器周期包含6个状态周期,也就是12个时钟周期,在一个机器周期内,CPU可以完成一个独立的操作, 指令周期: 它指CPU完成一条操作所需的全部时间,每条指令执行时间都是有一个或几个机器周期组成 MCS-51系统中,有单周期指令,双周期指令和四周期指令. 80C51引脚封装 80C51/89C51 最大4k程序. 管脚: RST/Vpd: 复位/备用电源的输入端, P3.0/RXD, P3.1/TXD,P3.2/INTO ... P3.7/RD: 串口,程序下载命令,中断,定时器,计数器,外部数据存储器. XTAL2 XTAL1: 外部晶振输入端. ALE 中断 中断的概念: CPU 在处理某一事件A, 发生了另一事件B请求CPU迅速去处理(中断发生) CPU暂时中断当前的工作,转去处理事件B(中断响应和中断服务) 待CPU将事件B处理完毕后,再回到原来事件A被中断的地方继续处理事件A(中断返回),这一过程称为中断 中断的嵌套 在中断服务中再次发生中断 中断的优先级 中断源的响应优先级及中端服务入口程序表 中断源 中断标志 中断服务程序入口 优先级顺序 外部中断 0 (INT0) IE0 0003H 高 定时/计数器 0 (T0) TF0 000BH ⬇ 外部中断 1 (INT1) IE1 0013H ⬇ 定时/计数器 1(T1) TF1 001BH ⬇ 串行口 RI或T1 0023H 低 中断响应条件 中断源有中断请求 此中断源的中断允许位为1 CPU开中断 即 EA=1 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/mcu/chip.html":{"url":"program/mcu/chip.html","title":"芯片","keywords":"","body":"芯片 74HC595 芯片 74HC595 是一个 8 位串行输入、并行输出的位移缓存器，其中并行输出为三态输出（即高电平、低电平和高阻抗） 串行写入代码: #include #include typedef unsigned int u16; typedef unsigned char u8; sbit SRCLK = P3^6; sbit RCLK = P3^5; sbit SER = p3^4; /** 发送8位数据 */ void Hc595SendByte(u8 dat){ u8 i; SRCLK = 1; RCLK = 1; for(i=0;i> 7; dat Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/android/adb.html":{"url":"program/android/adb.html","title":"Andorid-常用adb命令","keywords":"","body":"ADB adb速查 https://www.wanandroid.com/blog/show/2310 最全ADB github: https://github.com/mzlogin/awesome-adb adb 常用命令 查看当前连接设备： adb devices 如果发现多个设备： adb -s 设备号 其他指令 查看日志： adb logcat 安装apk文件： adb install xxx.apk 此安装方式，如果已经存在，无法安装； 推荐使用覆盖安装： adb install -r xxx.apk 卸载App: adb uninstall com.zhy.app 1 如果想要保留数据，则： adb uninstall -k com.zhy.app 往手机SDCard传递文件： adb push 文件名 手机端SDCard路径 从手机端下载文件： adb pull /sdcard/xxx.txt 查看手机端安装的所有app包名: adb shell pm list packages 启动Activity: adb shell am start 包名/完整Activity路径 启动服务： adb shell am startservice \"com.zhy.aaa/com.zhy.aaa.MyService\" 屏幕截图： adb shell screencap /sdcard/screen.png 录制视频： adb shell screenrecord /sdcard/demo.mp4 清除APP数据： adb shell pm clear com.example.packagename 查看所有App的名称：该命令可以查看手机上的APP名称。可以在后面加上 -f ，这样还能显示该APP的路径。 即： adb shell pm list packages -f 使用adb shell input命令向屏幕输入一些信息， adb shell input text \"insert%stext%shere\" 注意：%s表示空格。 模拟屏幕点击事件 adb shell input tap 500 1450 1 表示在屏幕上（500，1450）的坐标点上进行一次点击。 模拟手势滑动事件，例如： adb shell input swipe 100 500 100 1450 100 用上面的命令还可以模拟”长按（long press）操作，也就是2个坐标点相同，耗时超过500ms. adb shell input swipe 100 500 100 500 500 模拟点按实体按钮的命令，例如： adb shell input keyevent 25 该命令表示调低音量。数字25是在AOSP源码中的KeyEvent类里定义的一个事件常量。该类定义了将近300个事件常量。 上面这个命令会启动浏览器打开谷歌网址页面。 adb shell am start -a \"android.intent.action.VIEW\" -d \"https://www.google.com\" am 也能发送广播和启动服务。比如启动一个广播，一般要添加一个-a： adb shell am broadcast -a \"our.specified.action\" 使用下面的命令可以直接让手机重启： adb shell am broadcast -a android.intent.action.BOOT_COMPILETED 启动一个服务也是类似，例如: adb shell am startservice \"com.example.crime/com.example.crime.MyService\" adb shell ps命令查看进程信息。可以在该命令后加包名，来查看某个应用程序的进程信息。 adb shell top 命令来查看系统CPU使用情况 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/database/db.html":{"url":"program/database/db.html","title":"数据库","keywords":"","body":"数据库 Mysql 使用root创建用户和数据库 # 从服务器登陆数据库 mysql -u root -p use mysql; # 创建新用户,允许外网访问 create user 'yangb'@'%' identified by '123456'; # 刷新授权 flush privileges; # 创建数据库 create database devlop default charset utf-8mb4 collate utf8mb4_general_ci; # 授予用户通过外网IP对于该数据库的全部权限 grant all privileges on `devlop`.* to 'yangb'@'%' identified by '123456'; # 授予用户在本地服务器对该数据库的全部权限 grant all privileges on `devlop`.* to 'yangb'@'localhost' identified by '123456'; # 刷新权限 flush privileges; # 退书 exit Mysql 忘记root密码 # 在[mysqld]下添加skip-grant-tables，然后保存并退出 $ vi /etc/my.cnf [mysqld] skip-grant-tables # 重启mysql $ service mysqld restart # 进入mysql $ mysql -u root MySQL> UPDATE mysql.user SET Password=PASSWORD('新密码') where USER='root'; MySQL> flush privileges; MySQL> exit # 最后把/etc/my.cnf中的skip-grant-tables注释掉，然后重启mysql $ vi /etc/my.cnf [mysqld] # skip-grant-tables $ service mysqld restart PostgresSql 数据库 管理员登陆 su postgres psql \\l 查看数据库 Oracle 数据库表数据闪回 找回删除的数据或者表 闪回查询 查询过去某个时间段的数据库状态 select * from dept as of timestamp to_timestamp('2016-09-10 11:00:00','yyyy-mm-dd hh24:mi:ss'); 闪回表 启用表闪回首先要在表上支持行移动 闪回表操作 alter table dept enable row movement; flashback table dept to timestamp to_timestamp('2016-09-10 11:00:00','yyyy-mm-dd hh24:mi:ss'); 闪回表可能会失败，有可能有以下几种情况： 违反了数据库约束，比如用户不小心删除了子表中的数据，现在想利用闪回表技术进行回退，恰好在这中间，父表中与该数据对应的那条记录也被删除了，在这种情况下，由于违反了外键约束，导致闪回表操作失败了； 撤销数据失效，比如用于支撑闪回操作的撤销数据被覆盖了，这种情况闪回表操作自然会失败； 闪回不能跨越DDL，即在闪回点和当前点之间，表结构有过变更，这种情况闪回操作也会失败。 如果表和数据库被删除了，也可以闪回，请参考 https://www.cnblogs.com/chengxiao/p/5860823.html Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/nginx/backups.html":{"url":"program/nginx/backups.html","title":"Nginx-主从热备","keywords":"","body":"Nginx Nginx 的主从热备 场景: Nginx代理主服务器对外提供服务, 主服务器失去连接后 Nginx 代理转向从服务器为外界提供服务. 当主服务器恢复时, 自动切换至主服务器继续为外界提供服务. Nginx 配置: http { upstream backend { server localhost:9090; server localhost:9999 backup; } server { listen 80; location / { proxy_pass http://backend; } } } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"program/websocket/":{"url":"program/websocket/","title":"WebSocket","keywords":"","body":"WebSocket 服务端 Spring Boot pom.xml org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-websocket org.springframework.boot spring-boot-devtools runtime true org.projectlombok lombok true cn.hutool hutool-all 5.3.7 启动类 import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.Bean; import org.springframework.web.socket.server.standard.ServerEndpointExporter; @SpringBootApplication public class ServerApplication { public static void main(String[] args) { SpringApplication.run(ServerApplication.class, args); } @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } } 实体类 @Data public class Message { private String from; private String to; private String message; } WebSocket类 @ServerEndpoint(\"/imserver/{user}\") @Slf4j @Component public class ImServer { private static ConcurrentHashMap sessionMap = new ConcurrentHashMap<>(); private String user; @OnOpen public void open(Session session,@PathParam(\"user\") String user){ log.info(user+\"已连接\"); sessionMap.put(user, session); this.user = user; } @OnClose public void close(){ log.info(user + \"退出聊天室！\"); } @OnMessage public void message(String message, Session session){ log.info(message); if(StrUtil.isNotBlank(message)){ Message msg = new Message(); msg.setMessage(message); msg.setFrom(user); msg.setTo(\"all\"); sendAll(msg); } } @OnError public void onError(Session session, Throwable error) { log.error(\"用户错误:\"+this.user+\",原因:\"+error.getMessage()); error.printStackTrace(); } /** * 群发消息 */ public static void sendAll(Message message){ sessionMap.values().forEach(session -> { if(session.isOpen()){ session.getAsyncRemote().sendText(JSONUtil.toJsonStr(message)); } }); } } 客户端 WebSocket .show {display: inline;} .hiden {display: none;} #talk {width: 500px;height: 200px;} #receive,#send {width: 100%;height: 100%;} #talk>button {width: 100%;} 开始聊天 发送 var socket; function openSocket() { var url = \"ws://localhost:8080/imserver/\" + $('#user').val() socket = new WebSocket(url) //打开链接事件 socket.onopen = function () { console.log('聊天室已连接') $('#accept').attr('disabled', true); $('#talk').attr('class', 'show'); } //获得消息事件 socket.onmessage = function (msg) { console.log(msg) data = JSON.parse(msg.data) $('#receive').append(data.from + \"说：\" + data.message + \"\\n\"); } //关闭事件 socket.onclose = function () { console.log(\"websocket已关闭\"); }; //发生了错误事件 socket.onerror = function () { console.log(\"websocket发生了错误\"); } } //发送消息 function sendMsg() { socket.send($('#send').val()) $('#send').val(''); } Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"security/security.html":{"url":"security/security.html","title":"网络安全","keywords":"","body":"Security 网络安全 科学上网服务建设 使用V2Ray https://github.com/233boy/v2ray/wiki/V2Ray%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC v2ray url 可生成 vmess URL 链接 国外VPS服务器 https://bwh88.net/ 境外服务器不易受到监管 家用智能设备攻击思路 破解家用路由器或者控制一台肉鸡, 在内网扫描支持UPnP协议的只能设备, 使用UPnP利用工具miranda进行扫描和利用 UPnP 协议 UPnP为即插即用的缩写（Universal Plug and Play）是一套网络协议。适用于家庭网络，用于设备间的发现和连接。希望实现任何设备只要一接入网络就能被网络中的所有其它设备发现，做到完全的即插即用。 miranda Miranda是Kali提供的一款基于Python语言的UPNP客户端工具。它可以用来发现、查询和操作UPNP设备，尤其是网关设置。 pcap：被动发现设备通过嗅探设备接入网络时发送的NOTIFY消息获取设备信息。 msearch:通过主动发送M-serach消息来发现设备。（一般使用msearch比较快） 发现设备后可用host命令来查看详细信息。 host list：查看发现的设备列表 host get ：获取信息（查询summary之前需执行） host info ：显示查询到的信息 host summary 0 ：显示xml文件的摘要信息 （n为设备在列表中的编号） 获取设备列表 host info 0 deviceList 获取设备支持的命令/服务信息（命令很长使用Tab键补齐很方便 ） host info 0 deviceList WANConnectionDevice services WANIPConnection actions TCP 三次握手 SYN: synchronous 同步 ACK: acknowledgement 确认 client --SYN--> server server --ACK+SYN--> client client --ACK--> server Nmap 常用指令 主机发现: -sn Tcp ping扫描 -Pn 跳过主机发现 -PS/PA/PU/PY[portlist]: SYN/ACK/UDP/SCTP -n: 不做反向DNS查询 --dns-servers 8.8.8.8 : 指定dns服务器 -p-: 扫描所有端口 快速扫描主机的详细信息 nmap -sT -sV -Pn -v xxx.xxx.xxx.xxx 扫描所有的端口开放情况 nmap -sS -p 1-65535 -v 192.168.1.254 扫描网段主机(ping扫描) nmap -sn 192.168.16.100-150 深度扫描网络主机信息 nmap -A -T4 192.168.10.1 半开扫描(TCP SYN扫描) - 隐秘且速度快，比较常用 nmap -sS host Robots 扫描工具 parsero 扫描robots目录的地址 parsero -u url -o 只显示连接成功的 -sb 使用bing搜索引擎查找robots文件. Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"security/demo.html":{"url":"security/demo.html","title":"漏洞利用","keywords":"","body":"漏洞利用 Shiro RememberMe 反序列化漏洞 Apache Shiro 在 Java 的权限及安全验证框架中占用重要的一席之地，在它编号为550的 issue 中爆出严重的 Java 反序列化漏洞。 影响版本: Shiro 1.2.4 参考文章: https://paper.seebug.org/shiro-rememberme-1-2-4/ https://blog.knownsec.com/2016/08/apache-shiro-java/ Tomcat AJP 任意文件读取 CVE-2020-1938 漏洞说明 该漏洞是由于Tomcat AJP协议存在缺陷而导致，攻击者利用该漏洞可通过构造特定参数，读取服务器webapp下的任意文件。若目标服务器同时存在文件上传功能，攻击者可进一步实现远程代码执行。目前，厂商已发布新版本完成漏洞修复。 受影响版本 Apache Tomcat 6 Apache Tomcat 7 Apache Tomcat 8 Apache Tomcat 9 不受影响版本 Apache Tomcat = 7.0.100 Apache Tomcat = 8.5.51 Apache Tomcat = 9.0.31 PoC github: https://github.com/yangb92/AJPy ThinkPhp 5.x 漏洞 POC: https://github.com/SkyBlueEternal/thinkphp-RCE-POC-Collection FastJson 反序列化漏洞 Payload: https://github.com/OneSourceCat/BcelPayloadGenerator Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"security/kali.html":{"url":"security/kali.html","title":"Kali","keywords":"","body":"Kali Linux 中文乱码问题 确定locales已经安装，用”apt-get install locales”命令；之后可用”locale -a”查看当前系统支持的字符集。 在命令行输入”dpkg-reconfigure locales”。进入图形化界面之后，（空格是选择，Tab是切换，*是选中），选中en_US.UTF-8和zh_CN.UTF-8，确定后，将en_US.UTF-8选为默认。 安装中文字体，”apt-get install xfonts-intl-chinese “和” apt-get install ttf-wqy-microhei”，这时发现网页不乱码，系统也不乱码。 重启 。 DDOS 洪水攻击 hping3 -c 1000 -d 120 -S -w 64 -p80 --flood --rand-source baidu.com -c: 发送包的数量 -d: 发送的每个数据包的大小,单位字节 -S: 只发送SYN数据包 -w: tcp窗口大小 -p: 目标端口 -flood: 尽可能快的发送数据包,不考虑显示入站回复 --rand-source: 随机性源头IP, 这里伪造的IP只是在局域网伪造,外网出口会还原 主动收集 netdiscover netdiscover 是一个主动/被动侦察工具. 可以扫描IP地址,检查在线主机或搜索为它们发送ARP请求 主动模式: 主动探测发现网络主机,但这种方式往往会引起网络管理员注意. netdiscover -i eth0 -r 192.168.1.0/24 被动模式: netdiscover -p scapy 启动 scapy ARP().display() # 查看ARP函数的用法 ###[ ARP ]### hwsrc: 源MAC地址 psrc: 源IP地址 hwdst: 目标MAC地址 pdst: 目的IP地址 sr1 函数发送请求sr1(ARP(pdst='192.168.1.1')) # 发送ARP请求 使用IP()和ICMP()生成ping包. 思路: 修改IP包头的dst(目的地址) 拼接ICMP的数据包类型 使用sr1进行发送数据包并接收数据包 sr1(IP(dst='192.168.1.1')/ICMP(),timeout=1) 构造TCP协议数据包 构造UDP协议数据包 僵尸扫描 nmap 扫描网络中的哪些机器可以被当成僵尸主机 被动收集 域名IP查询 dig (选项) 域名 @DNS服务地址: 指定域名进行解析 any: 显示所有类型域名记录.默认只显示A记录 dig yangb.xyz dig @114.114.114.114 yangb.xyz dig @114.114.114.114 yangb.xyz any -x ip:反查域名 子域名信息收集 使用搜索引擎: site:顶级域名 例如: site:qq.com Maltego 收集子域名(更加专业强大) 学习视频: http://www.shodan.io/ 超强搜索引擎, 可以搜索未经授权的站点, 包括网络摄像头. Kali 网络配置 实用Kali虚拟机需要开启桥接模式。 修改/etc/network/interfaces文件 dhcp 自动获取ip地址 auto eth0 iface eth0 dhcp 手动IP设置 auto eth0 iface eth0 inet static address 192.168.10.188 netmask 255.255.255.0 gateway 192.168.10.1 重启网络服务 /etc/init.d/networking restart 网络中图片嗅探 driftnet [options] [filter code] 主要参数： -b 捕获到新的图片时发出嘟嘟声 -i interface 选择监听接口 -f file 读取一个指定pcap数据包中的图片 -p 不让所监听的接口使用混杂模式 -a 后台模式：将捕获的图片保存到目录中（不会显示在屏幕上） -m number 指定保存图片数的数目 -d directory 指定保存图片的路径 -x prefix 指定保存图片的前缀名 使用举例： 1.实时监听： driftnet -i wlan0 2.读取一个指定pcap数据包中的图片： driftnet -f /home/linger/backup/ap.pcapng -a -d /root/drifnet/ Installing the Metasploit Framework on Linux curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb > msfinstall && chmod 755 msfinstall && ./msfinstall 如果安装失败 apt-get update 如果update出现key错误,先添加key apt-key adv --recv-keys --keyserver keyserver.ubuntu.com CDFB5FA52007B954 msfvenom 使用 https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom 查看能生成木马文件的格式类型,编码类型等等,都可以用-l参数来显示 msfvenom -l formats Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"security/google.html":{"url":"security/google.html","title":"谷歌黑客语法","keywords":"","body":"谷歌黑客语法 site：可以限制你搜索范围的域名. inurl：用于搜索网页上包含的URL，这个语法对寻找网页上的搜索，帮助之类的很有用. intext: 只搜索网页部分中包含的文字(也就是忽略了标题、URL等的文字) intitle: 查包含关键词的页面，一般用于社工别人的webshell密码 filetype：搜索文件的后缀或者扩展名 intitle：限制你搜索的网页标题. link: 可以得到一个所有包含了某个指定URL的页面列表. 查找后台地址：site:域名 inurl:login|admin|manage|member|admin_login|login_admin|system|login|user|main|cms 查找文本内容：site:域名 intext:管理|后台|登陆|用户名|密码|验证码|系统|帐号|admin|login|sys|managetem|password|username 查找可注入点：site:域名 inurl:aspx|jsp|php|asp 查找上传漏洞：site:域名 inurl:file|load|editor|Files 找eweb编辑器：site:域名 inurl:ewebeditor|editor|uploadfile|eweb|edit 存在的数据库：site:域名 filetype:mdb|asp|# 查看脚本类型：site:域名 filetype:asp/aspx/php/jsp 迂回策略入侵：inurl:cms/data/templates/images/index/ Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"tool/":{"url":"tool/","title":"工具插件","keywords":"","body":"工具插件 小技巧 b站看视频,右侧视屏选集栏显示完整名称 document.getElementById('multi_page').style=\"width:500px\" 神奇的特殊字符 var a = 'N\\u035a\\u035a\\u035a\\u035a\\u035a\\u035a\\u035a\\u035a\\u035a\\u035a\\u030a\\u030a\\u030a\\u030a\\u030a\\u030a\\u030a\\u030a\\u030a\\u030a\\u030a\\u030a\\u030a\\u030a\\u030a\\u030a\\u030a\\u030a\\u030a\\u030a\\u030a\\u030aice' Chrome 插件 Infinity 标签页管理 安装方式 1. 谷歌市场搜索下载 2. 谷歌访问助手 免费访问: 谷歌搜索，Gmail邮箱，Chrome商店... 更好用的谷歌访问助手工具 pp访问助手 www.ppgoogle.net 沙拉查词 多个来源的网页翻译工具 Darkreader 网页暗色模式: https://darkreader.org/ Jetbrains系列产品 Jetbrains系列产品2019.2.3最新激活方法[持续更新] https://zhile.io/2018/08/25/jetbrains-license-server-crack.html?tdsourcetag=s_pctim_aiomsg 漂亮的 Markdown 编辑器 Typora https://www.typora.io/ Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"tool/PowerShell.html":{"url":"tool/PowerShell.html","title":"PowerShell 美化主题","keywords":"","body":"PowerShell 切换窗口到前台 $wshell = New-Object -ComObject wscript.shell $wshell.AppActivate('Teams') 美化 PowerShell 美化效果: 配置windows允许执行没有签名（远程）的Powershell脚本 在设置中面板中搜索PowerShell 找到开发人员设置,打勾这一项 下载Windows包管理工具 Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) 输入 choco -v验证是否安装成功 GIT choco install git 字体库 只需要安装字体库中 DejaVuSansMono 的字体就可以了. 字体下载好右键安装即可. powershell的git集成方案 posh-git Install-Module posh-git 基于posh-git的美化主题oh-my-posh Install-Module oh-my-posh 硬货在这里 刚刚前面做的全都是事前准备而已，这里才是真正影响Powershell主题的主要关键。直接复制到Powershell跑一下吧。 Install-Module -Name PSReadLine -Force -SkipPublisherCheck if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } @\" #requires -Version 2 -Modules posh-git function Write-Theme { param( [bool] `$lastCommandFailed, [string] `$with ) `$lastColor = `$sl.Colors.PromptBackgroundColor `$prompt = Write-Prompt -Object `$sl.PromptSymbols.StartSymbol -ForegroundColor `$sl.Colors.PromptForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor #check the last command state and indicate if failed If (`$lastCommandFailed) { `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.FailedCommandSymbol) \" -ForegroundColor `$sl.Colors.CommandFailedIconForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor } #check for elevated prompt If (Test-Administrator) { `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.ElevatedSymbol) \" -ForegroundColor `$sl.Colors.AdminIconForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor } `$user = [System.Environment]::UserName `$computer = [System.Environment]::MachineName `$path = Get-FullPath -dir `$pwd if (Test-NotDefaultUser(`$user)) { `$prompt += Write-Prompt -Object \"`$user@`$computer \" -ForegroundColor `$sl.Colors.SessionInfoForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor } if (Test-VirtualEnv) { `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.SegmentForwardSymbol) \" -ForegroundColor `$sl.Colors.SessionInfoBackgroundColor -BackgroundColor `$sl.Colors.VirtualEnvBackgroundColor `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.VirtualEnvSymbol) `$(Get-VirtualEnvName) \" -ForegroundColor `$sl.Colors.VirtualEnvForegroundColor -BackgroundColor `$sl.Colors.VirtualEnvBackgroundColor `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.SegmentForwardSymbol) \" -ForegroundColor `$sl.Colors.VirtualEnvBackgroundColor -BackgroundColor `$sl.Colors.PromptBackgroundColor } else { `$prompt += Write-Prompt -Object \"`$(`$sl.PromptSymbols.SegmentForwardSymbol) \" -ForegroundColor `$sl.Colors.SessionInfoBackgroundColor -BackgroundColor `$sl.Colors.PromptBackgroundColor } # Writes the drive portion `$prompt += Write-Prompt -Object \"`$path \" -ForegroundColor `$sl.Colors.PromptForegroundColor -BackgroundColor `$sl.Colors.PromptBackgroundColor `$status = Get-VCSStatus if (`$status) { `$themeInfo = Get-VcsInfo -status (`$status) `$lastColor = `$themeInfo.BackgroundColor `$prompt += Write-Prompt -Object `$(`$sl.PromptSymbols.SegmentForwardSymbol) -ForegroundColor `$sl.Colors.PromptBackgroundColor -BackgroundColor `$lastColor `$prompt += Write-Prompt -Object \" `$(`$themeInfo.VcInfo) \" -BackgroundColor `$lastColor -ForegroundColor `$sl.Colors.GitForegroundColor } # Writes the postfix to the prompt `$prompt += Write-Prompt -Object `$sl.PromptSymbols.SegmentForwardSymbol -ForegroundColor `$lastColor `$timeStamp = Get-Date -UFormat %r `$timestamp = \"[`$timeStamp]\" `$prompt += Set-CursorForRightBlockWrite -textLength (`$timestamp.Length + 1) `$prompt += Write-Prompt `$timeStamp -ForegroundColor `$sl.Colors.PromptForegroundColor `$prompt += Set-Newline if (`$with) { `$prompt += Write-Prompt -Object \"`$(`$with.ToUpper()) \" -BackgroundColor `$sl.Colors.WithBackgroundColor -ForegroundColor `$sl.Colors.WithForegroundColor } `$prompt += Write-Prompt -Object (`$sl.PromptSymbols.PromptIndicator) -ForegroundColor `$sl.Colors.PromptBackgroundColor `$prompt += ' ' `$prompt } `$sl = `$global:ThemeSettings #local settings `$sl.PromptSymbols.StartSymbol = '' `$sl.PromptSymbols.PromptIndicator = [char]::ConvertFromUtf32(0x276F) `$sl.PromptSymbols.SegmentForwardSymbol = [char]::ConvertFromUtf32(0xE0B0) `$sl.Colors.PromptForegroundColor = [ConsoleColor]::White `$sl.Colors.PromptSymbolColor = [ConsoleColor]::White `$sl.Colors.PromptHighlightColor = [ConsoleColor]::DarkBlue `$sl.Colors.GitForegroundColor = [ConsoleColor]::Black `$sl.Colors.WithForegroundColor = [ConsoleColor]::DarkRed `$sl.Colors.WithBackgroundColor = [ConsoleColor]::Magenta `$sl.Colors.VirtualEnvBackgroundColor = [System.ConsoleColor]::Red `$sl.Colors.VirtualEnvForegroundColor = [System.ConsoleColor]::White \"@>$env:userprofile\"\\Documents\\WindowsPowerShell\\Modules\\oh-my-posh\\2.0.230\\Themes\\Paradox.psm1\" @\" chcp 65001 Set-PSReadlineOption -EditMode Emacs function which(`$name) { Get-Command `$name | Select-Object Definition } function rmrf(`$item) { Remove-Item `$item -Recurse -Force } function mkfile(`$file) { \"\" | Out-File `$file -Encoding ASCII } Import-Module posh-git Import-Module oh-my-posh Set-Theme Paradox \"@ > $PROFILE chcp 65001 Set-PSReadlineOption -EditMode Emacs Import-Module posh-git Import-Module oh-my-posh Set-Theme Paradox 设置powershell字体,选择安装的powerline字体. 其他主题参考 主题页面 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-04-15 17:43:52 "},"tool/hexo.html":{"url":"tool/hexo.html","title":"Hexo 博客框架","keywords":"","body":"Hexo 博客搭建 博客的基础搭建请参考: 官方文档 推荐主题 主题: https://github.com/jerryc127/hexo-theme-butterfly 主题预览: https://jerryc.me/ 主题安装文档:https://jerryc.me/posts/21cfbf15 博客扩展设置: https://jerryc.me/posts/31391d01 为博客添加宠物 详细资料: https://github.com/EYHN/hexo-helper-live2d 宠物包: https://github.com/xiazeyu/live2d-widget-models npm install --save hexo-helper-live2d 在站點配置文件或者主題配置文件添加以下内容 live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-wanko # 宠物的模型 display: position: right width: 150 height: 300 mobile: show: true 安裝需要的寵物文件: npm install {packagename} Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"tool/chrome/":{"url":"tool/chrome/","title":"chrome","keywords":"","body":"Chrome 插件开发 使页面变为可编辑状态 document.body.contentEditable = \"true\" 获取tab的url chrome.tabs.getSelected(null,function(tab) { console.log(tab.url) }); Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"tool/chrome/event.html":{"url":"tool/chrome/event.html","title":"插件-事件监听","keywords":"","body":"Chrome 事件监听和响应 Chrome 插件为了安全性不能直接操作页面元素, 因此需要利用事件监听和响应来传递信息 案例: 修改哔哩哔哩视屏列表宽度 创建监听器的js bili.js chrome.extension.onRequest.addListener(//监听扩展程序进程或内容脚本发送的请求 function (request, sender, sendResponse) { if (request.action == \"multi_page\") { document.getElementById('multi_page').style=\"width:500px\" } sendResponse({\"success\":\"成功\"}) } ); 插件的弹出页 main.html B站视屏列表标题展开 在弹出页向监听器发送事件 main.js document.getElementById('b_video_list').onclick = function(e){ chrome.tabs.getSelected(null, function (tab) {//获取当前tab //向tab发送请求 chrome.tabs.sendRequest(tab.id, { action: \"multi_page\" },function(response){ console.log(response.success) }); }); } 在 manifest.json 中配置 { \"name\": \"ybtool\", \"description\": \"杨斌的工具包\", \"version\": \"1.0\", \"manifest_version\": 2, \"browser_action\": { \"default_icon\": \"main.png\", \"default_popup\": \"main.html\" }, \"content_scripts\": [ { \"matches\": [\"https://www.bilibili.com/*\"], // 为相关页面加上监听器 \"js\": [\"bili.js\"] } ], \"permissions\": [\"https://www.bilibili.com/video/*\",\"tabs\"] } 直接修改指定网站的DOM https://github.com/GoogleChrome/chrome-extensions-samples manifest.json { \"name\": \"zhihu\", \"action\": {}, \"manifest_version\": 3, \"version\": \"0.1\", \"description\": \"Turns the page red when you click the icon\", \"content_scripts\": [ { \"matches\": [ \"https://www.zhihu.com/*\" ], \"js\": [ \"background.js\" ], \"all_frames\": false } ], \"permissions\": [ \"https://www.zhihu.com/*\", \"activeTab\", \"scripting\" ] } background.js function reddenPage() { document.body.getElementsByClassName('Sticky AppHeader')[0].remove() document.body.getElementsByClassName('GlobalSideBar GlobalSideBar--old')[0].remove() document.body.getElementsByClassName('ModalExp-content')[0].remove() } reddenPage() Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-04-13 19:43:14 "},"tool/git/git.html":{"url":"tool/git/git.html","title":"git","keywords":"","body":"Git 覆盖分支 把本地的devlop分支强制(-f)推送到远程mastergit push origin devlop:master -f 用devlop覆盖当前分支git reset –hard develop git push origin master –f 撤销上一次commit操作 还没有push，只是在本地commit git reset --soft|--mixed|--hard --soft 保留源码,只回退到commit信息到某个版本.不涉及index的回退,如果还需要提交,直接commit即可. --mixed 会保留源码,只是将git commit和index 信息回退到了某个版本. --hard 源码也会回退到某个版本,commit和index 都会回退到某个版本.(注意,这种方式是改变本地代码仓库源码) Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-04-28 15:42:52 "},"tool/git/gituse.html":{"url":"tool/git/gituse.html","title":"在项目开发中使用git","keywords":"","body":"项目开发中使用Git 项目开发中如何使用git? 开发人员只需要在dev分支进行代码更新和提交就能满足日常工作需要. 拉取项目 复制项目的地址 2.创建一个文件夹,右键菜单中打开Git Bash命令行,如果没有安装Git,先安装Git工具. git clone git@192.168.10.45:zjapl/gov-gsrs.git 3.进入项目目录 gov-gsrs 进行开发 切换到开发分支 git checkout dev 更新代码 git pull origin dev 提交代码 git push origin dev Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"tool/gitbook.html":{"url":"tool/gitbook.html","title":"Gitbook 电子书","keywords":"","body":"将GitBook文档托管到Github 将打包的文档发布至公共 gitpage 在 github|gitee 创建一个仓库 创建gitbook文档, 使用 gitbook build打包 安装推送插件cnpm install -g gh-pages 将文档发布到github|gitee gh-pages -d _book 开启仓库的gitpage, 选择gh-pages分支. 本文档使用插件 { \"title\":\"学习笔记\", \"author\":\"杨斌\", \"language\" : \"zh-hans\", \"plugins\": [ \"-search\", \"back-to-top-button\", \"chapter-fold\", \"sharing\", \"donate\", \"search-pro\", \"insert-logo\", \"theme-default\", \"theme-comscore\", \"code\", \"splitter\", \"tbfed-pagefooter\", \"github\", \"hide-element\", \"katex\" ], \"pluginsConfig\": { \"donate\": { \"wechat\": \"https://gitee.com/yangb92/book/raw/gh-pages/git/wxpay.png\", \"alipay\": \"https://gitee.com/yangb92/book/raw/gh-pages/git/alipay.png\", \"title\": \"\", \"button\": \"赏\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\" }, \"insert-logo\": { \"url\": \"https://gitee.com/yangb92/book/raw/gh-pages/favorite.png\", \"style\": \"background: none; max-height: 80px; min-height: 10px\" }, \"theme-default\": { \"showLevel\": true }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy yangb \", \"modify_label\": \"该文章修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"github\":{ \"url\":\"https://github.com/yangb92\" }, \"hide-element\":{ \"elements\": [\".gitbook-link\"] } } } 数学符号使用 行内公式:\\$\\$ x_0 \\$\\$ 公式块: \\$\\$ x_0 = y_2 \\$\\$ 在线符号编辑器 http://latex.codecogs.com/eqneditor/editor.php 公示参考文档: https://blog.csdn.net/weixin_43159148/article/details/88621318 https://blog.csdn.net/weixin_43159148/article/details/88623751 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"tool/jmeter.html":{"url":"tool/jmeter.html","title":"JMeter 压力测试","keywords":"","body":"压力测试 Jmeter 下载地址: https://jmeter.apache.org/download_jmeter.cgi 打开软件 -右键添加-> 线程 --> setUp 线程组 -右键线程组-> 取样器 -> http请求 Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "},"tool/idea.html":{"url":"tool/idea.html","title":"IDEA插件","keywords":"","body":"IDEA 插件介绍 GenerateAllSetter 一键调用一个对象的set方法. (Alt+Enter) GenerateSerialVersionUID 生成唯一序列化ID JRebel 热部署插件 Lombok 自动生成Pojo的操作方法 POJO to Json 右键将java类型转成json Copyright © yangb all right reserved，powered by Gitbook该文章修订时间： 2021-03-19 10:57:47 "}}